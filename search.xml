<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>何为大学</title>
    <url>/yunruowuBlog/2021/06/16/%E4%BD%95%E4%B8%BA%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>今天在看书的时候，看到了作者在大学里面，学习了很多课程，听讲座，看书。很多课程在我看来是和她的研究没有联系的。换做是我的话，我会不会去选择这些课程呢？如果按照我现在的环境和状态，断然是不会把时间花费在这些课程上的。所以我发现了一个很奇怪的事情----在大学我到底应该做什么？</p>
<p>先谈一下自己的状态，现在是个研究生。可是我没有考虑过到底什么样的生活才是“好的”研究生生活。但是我也在这度过将近一年的时光了。在我看来，我和我的同学，并没有把学课程当成我们的一个优势，反而是一种负担。具体来说，选课时，不选自己感兴趣的，不选对自己有用的，选不点名的，选没有作业的，选好过的；上课时，能逃课的绝对不去上课，能划水的绝对不认真；作业，能不写的绝对不写，能抄的绝对不自己做；考试，能过就行，能不复习就不复习。这样的思想不是一个两个，和我一起上来的，十个有九个是这样的想法。我也是这样想的，一时间就陷入这样的困境里面，没有想过为什么这样是对的，好像这就是真理。对这样事情的思考绝对不可能归咎于自身，说到原因，学校课程安排不合理，课程学了也没有用。一直都是消息的拒绝。</p>
<p>在一个就是在学校，是否有学校的生活。没有感受过大家一起去听老师的课，不是因为学分，仅仅是因为课程魅力。没有去泡图书馆，除非是有什么逼迫。感觉我在这里，并不是上学的状态，反倒是一种很压抑的感觉。有个类似于高考的指挥棒一样的东西，它引导着我走向它规划的道路，而我这几年（包括本科四年）也都是这样被一些琐事所困扰，浑浑噩噩的度过，很多时候我没有本心，也没有寻找过本心。很难想象我是怎么走到这一步的。</p>
<p>不可否认，它有其自身的特殊性，但是这种特殊性让我觉得是一种局限性。虽然它从来没有强调过什么，但是只要出口有标准，所有人都会趋之若鹜的。可能这就是大局。在这里，我觉得自己不够真实</p>
]]></content>
      <categories>
        <category>悟与思</category>
      </categories>
      <tags>
        <tag>一点思考</tag>
      </tags>
  </entry>
  <entry>
    <title>共产党宣言</title>
    <url>/yunruowuBlog/2021/06/15/%E5%85%B1%E4%BA%A7%E5%85%9A%E5%AE%A3%E8%A8%80/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>一个幽灵，共产主义的幽灵，在欧洲游荡。为了对这个幽灵进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。</p>
<p>有哪一个反对党不被它的当政的敌人骂为共产党呢？又有哪一个反对党不拿共产主义这个罪名去回敬更进步的反对党人和自己的反动敌人呢？</p>
<p>从这一事实中可以得出两个结论：</p>
<p>共产主义已经被欧洲的一切势力公认为一种势力；</p>
<p>现在是共产党人向全世界公开说明自己的观点、自己的目的、自己的意图并且拿党自己的宣言来反驳关于共产主义幽灵的神话的时候了。</p>
<p>为了这个目的，各国共产党人集会于伦敦，拟定了如下的宣言，用英文、法文、德文、意大利文、弗拉芒文和丹麦文公布于世。</p>
<h3 id="一、资产者和无产者"><strong>一、资产者和无产者</strong></h3>
<p>至今一切社会的历史都是阶级斗争的历史。</p>
<p>自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工，一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局都是整个社会受到革命改造或者斗争的各阶级同归于尽。</p>
<p>在过去的各个历史时代，我们几乎到处都可以看到社会完全划分为各个不同的等级，看到社会地位分成多种多样的层次。在古罗马，有贵族、骑士、平民、奴隶，在中世纪，有封建主、臣仆、行会师傅、帮工、农奴，而且几乎在每一个阶级内部又有一些特殊的阶层。</p>
<p>从封建社会的灭亡中产生出来的现代资产阶级社会并没有消灭阶级对立。它只是用新的阶级、新的压迫条件、新的斗争形式代替了旧的。</p>
<p>但是，我们的时代，资产阶级时代，却有一个特点：它使阶级对立简单化了。整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级：资产阶级和无产阶级。</p>
<p>从中世纪的农奴中产生了初期城市的城关市民；从这个市民等级中发展出最初的资产阶级分子。</p>
<p>美洲的发现、绕过非洲的航行，给新兴的资产阶级开辟了新天地。东印度和中国的市场、美洲的殖民化、对殖民地的贸易、交换手段和一般商品的增加，使商业、航海业和工业空前高涨，因而使正在崩溃的封建社会内部的革命因素迅速发展。</p>
<p>以前那种封建的或行会的工业经营方式已经不能满足随着新市场的出现而增加的需求了。工场手工业代替了这种经营方式。行会师傅被工业的中间等级排挤掉了；各种行业组织之间的分工随着各个作坊内部的分工的出现而消失了。</p>
<p>但是，市场总是在扩大，需求总是在增加。甚至工场手工业也不再能满足需要了。于是，蒸汽和机器引起了工业生产的革命。现代大工业代替了工场手工业；工业中的百万富翁，一支一支产业大军的首领，现代资产者，代替了工业的中间等级。</p>
<p>大工业建立了由美洲的发现所准备好的世界市场。世界市场使商业、航海业和陆路交通得到了巨大的发展。这种发展又反过来促进了工业的扩展。同时，随着工业、商业、航海业和铁路的扩展，资产阶级也在同一程度上得到发展，增加自己的资本，把中世纪遗留下来的一切阶级排挤到后面去。</p>
<p>由此可见，现代资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物。</p>
<p>资产阶级的这种发展的每一个阶段，都伴随着相应的政治上的进展。它在封建主统治下是被压迫的等级，在公社里是武装的和自治的团体，在一些地方组成独立的城市共和国，在另一些地方组成君主国中的纳税的第三等级；后来，在工场手工业时期，它是等级君主国或专制君主国中同贵族抗衡的势力，而且是大君主国的主要基础；最后，从大工业和世界市场建立的时候起，它在现代的代议制国家里夺得了独占的政治统治。现代的国家政权不过是管理整个资产阶级的共同事务的委员会罢了。</p>
<p>资产阶级在历史上曾经起过非常革命的作用。</p>
<p>资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园般的关系都破坏了。它无情地斩断了把人们束缚于天然尊长的形形色色的封建羁绊，它使人和人之间除了赤裸裸的利害关系，除了冷酷无情的“现金交易”，就再也没有任何别的联系了。它把宗教虔诚、骑士热忱、小市民伤感这些情感的神圣发作，淹没在利己主义打算的冰水之中。它把人的尊严变成了交换价值，用一种没有良心的贸易自由代替了无数特许的和自力挣得的自由。总而言之，它用公开的、无耻的、直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。</p>
<p>资产阶级抹去了一切向来受人尊崇和令人敬畏的职业的神圣光环。它把医生、律师、教士、诗人和学者变成了它出钱招雇的雇佣劳动者。</p>
<p>资产阶级撕下了罩在家庭关系上的温情脉脉的面纱，把这种关系变成了纯粹的金钱关系。</p>
<p>资产阶级揭示了，在中世纪深受反动派称许的那种人力的野蛮使用，是以极端怠惰作为相应补充的。它第一个证明了，人的活动能够取得什么样的成就。它创造了完全不同于埃及金字塔、罗马水道和哥特式教堂的奇迹；它完成了完全不同于民族大迁徙和十字军征讨的远征。</p>
<p>资产阶级除非对生产工具，从而对生产关系，从而对全部社会关系不断地进行革命，否则就不能生存下去。反之，原封不动地保持旧的生产方式，却是过去的一切工业阶级生存的首要条件。生产的不断变革，一切社会状况不停的动荡，永远的不安定和变动，这就是资产阶级时代不同于过去一切时代的地方。一切固定的僵化的关系以及与之相适应的素被尊崇的观念和见解都被消除了，一切新形成的关系等不到固定下来就陈旧了。一切等级的和固定的东西都烟消云散了，一切神圣的东西都被亵渎了。人们终于不得不用冷静的眼光来看他们的生活地位、他们的相互关系。</p>
<p>不断扩大产品销路的需要，驱使资产阶级奔走于全球各地。它必须到处落户，到处开发，到处建立联系。</p>
<p>资产阶级，由于开拓了世界市场，使一切国家的生产和消费都成为世界性的了。使反动派大为惋惜的是，资产阶级挖掉了工业脚下的民族基础。古老的民族工业被消灭了，并且每天都还在被消灭。它们被新的工业排挤掉了，新的工业的建立已经成为一切文明民族的生命攸关的问题；这些工业所加工的，已经不是本地的原料，而是来自极其遥远的地区的原料；它们的产品不仅供本国消费，而且同时供世界各地消费。旧的、靠本国产品来满足的需要，被新的、要靠极其遥远的国家和地带的产品来满足的需要所代替了。过去那种地方的和民族的自给自足和闭关自守状态，被各民族的各方面的互相往来和各方面的互相依赖所代替了。物质的生产是如此，精神的生产也是如此。各民族的精神产品成了公共的财产。民族的片面性和局限性日益成为不可能，于是由许多种民族的和地方的文学形成了一种世界的文学。</p>
<p>资产阶级，由于一切生产工具的迅速改进，由于交通的极其便利，把一切民族甚至最野蛮的民族都卷到文明中来了。它的商品的低廉价格，是它用来摧毁一切万里长城、征服野蛮人最顽强的仇外心理的重炮。它迫使一切民族——如果它们不想灭亡的话——采用资产阶级的生产方式；它迫使它们在自己那里推行所谓的文明，即变成资产者。一句话，它按照自己的面貌为自己创造出一个世界。</p>
<p>资产阶级使农村屈服于城市的统治。它创立了巨大的城市，使城市人口比农村人口大大增加起来，因而使很大一部分居民脱离了农村生活的愚昧状态。正像它使农村从属于城市一样，它使未开化和半开化的国家从属于文明的国家，使农民的民族从属于资产阶级的民族，使东方从属于西方。</p>
<p>资产阶级日甚一日地消灭生产资料、财产和人口的分散状态。它使人口密集起来，使生产资料集中起来，使财产聚集在少数人的手里。由此必然产生的结果就是政治的集中。各自独立的、几乎只有同盟关系的、各有不同利益、不同法律、不同政府、不同关税的各个地区，现在已经结合为一个拥有统一的政府、统一的法律、统一的民族阶级利益和统一的关税的统一的民族。</p>
<p>资产阶级在它的不到一百年的阶级统治中所创造的生产力，比过去一切世代创造的全部生产力还要多，还要大。自然力的征服，机器的采用，化学在工业和农业中的应用，轮船的行驶，铁路的通行，电报的使用，整个整个大陆的开垦，河川的通航，仿佛用法术从地下呼唤出来的大量人口，——过去哪一个世纪料想到在社会劳动里蕴藏有这样的生产力呢？</p>
<p>由此可见，资产阶级赖以形成的生产资料和交换手段，是在封建社会里造成的。在这些生产资料和交换手段发展的一定阶段上，封建社会的生产和交换在其中进行的关系，封建的农业和工场手工业组织，一句话，封建的所有制关系，就不再适应已经发展的生产力了。这种关系已经在阻碍生产而不是促进生产了。它变成了束缚生产的桎梏。它必须被炸毁，它已经被炸毁了。</p>
<p>起而代之的是自由竞争以及与自由竞争相适应的社会制度和政治制度、资产阶级的经济统治和政治统治。</p>
<p>现在，我们眼前又进行着类似的运动。资产阶级的生产关系和交换关系，资产阶级的所有制关系，这个曾经仿佛用法术创造了如此庞大的生产资料和交换手段的现代资产阶级社会，现在像一个魔法师一样不能再支配自己用法术呼唤出来的魔鬼了。几十年来的工业和商业的历史，只不过是现代生产力反抗现代生产关系、反抗作为资产阶级及其统治的存在条件的所有制关系的历史。只要指出在周期性的重复中越来越危及整个资产阶级社会生存的商业危机就够了。在商业危机期间，总是不仅有很大一部分制成的产品被毁灭掉，而且有很大一部分已经造成的生产力被毁灭掉。在危机期间，发生一种在过去一切时代看来都好像是荒唐现象的社会瘟疫，即生产过剩的瘟疫。社会突然发现自己回到了一时的野蛮状态；仿佛是一次饥荒、一场普遍的毁灭性战争，使社会失去了全部生活资料；仿佛是工业和商业全被毁灭了，——这是什么缘故呢？因为社会上文明过度，生活资料太多，工业和商业太发达。社会所拥有的生产力已经不能再促进资产阶级文明和资产阶级所有制关系的发展；相反，生产力已经强大到这种关系所不能适应的地步，它已经受到这种关系的阻碍；而它一着手克服这种障碍，就使整个资产阶级社会陷入混乱，就使资产阶级所有制的存在受到威胁。资产阶级的关系已经太狭窄了，再容纳不了它本身所造成的财富了。——资产阶级用什么办法来克服这种危机呢？一方面不得不消灭大量生产力，另一方面夺取新的市场，更加彻底地利用旧的市场。这究竟是怎样的一种办法呢？这不过是资产阶级准备更全面更猛烈的危机的办法，不过是使防止危机的手段越来越少的办法。</p>
<p>资产阶级用来推翻封建制度的武器，现在却对准资产阶级自己了。</p>
<p>但是，资产阶级不仅锻造了置自身于死地的武器；它还产生了将要运用这种武器的人——现代的工人，即无产者。</p>
<p>随着资产阶级即资本的发展，无产阶级即现代工人阶级也在同一程度上得到发展；现代的工人只有当他们找到工作的时候才能生存，而且只有当他们的劳动增殖资本的时候才能找到工作。这些不得不把自己零星出卖的工人，像其他任何货物一样，也是一种商品，所以他们同样地受到竞争的一切变化、市场的一切波动的影响。</p>
<p>由于推广机器和分工，无产者的劳动已经失去了任何独立的性质，因而对工人也失去了任何吸引力。工人变成了机器的单纯的附属品，要求他做的只是极其简单、极其单调和极容易学会的操作。因此，花在工人身上的费用，几乎只限于维持工人生活和延续工人后代所必需的生活资料。但是，商品的价格，从而劳动的价格，是同它的生产费用相等的。因此，劳动越使人感到厌恶，工资也就越少。不仅如此，机器越推广，分工越细致，劳动量出就越增加，这或者是由于工作时间的延长，或者是由于在一定时间内所要求的劳动的增加，机器运转的加速，等等。</p>
<p>现代工业已经把家长式的师傅的小作坊变成了工业资本家的大工厂。挤在工厂里的工人群众就像士兵一样被组织起来。他们是产业军的普通士兵，受着各级军士和军官的层层监视。他们不仅仅是资产阶级的、资产阶级国家的奴隶，他们每日每时都受机器、受监工、首先是受各个经营工厂的资产者本人的奴役。这种专制制度越是公开地把营利宣布为自己的最终目的，它就越是可鄙、可恨和可恶。</p>
<p>手的操作所要求的技巧和气力越少，换句话说，现代工业越发达，男工也就越受到女工和童工的排挤。对工人阶级来说，性别和年龄的差别再没有什么社会意义了。他们都只是劳动工具，不过因为年龄和性别的不同而需要不同的费用罢了。</p>
<p>当厂主对工人的剥削告一段落，工人领到了用现钱支付的工资的时候，马上就有资产阶级中的另一部分人——房东、小店主、当铺老板等等向他们扑来。</p>
<p>以前的中间等级的下层，即小工业家、小商人和小食利者，手工业者和农民——所有这些阶级都降落到无产阶级的队伍里来了，有的是因为他们的小资本不足以经营大工业，经不起较大的资本家的竞争；有的是因为他们的手艺已经被新的生产方法弄得不值钱了。无产阶级就是这样从居民的所有阶级中得到补充的。</p>
<p>无产阶级经历了各个不同的发展阶段。它反对资产阶级的斗争是和它的存在同时开始的。</p>
<p>最初是单个的工人，然后是某一工厂的工人，然后是某一地方的某一劳动部门的工人，同直接剥削他们的单个资产者作斗争。他们不仅仅攻击资产阶级的生产关系，而且攻击生产工具本身；他们毁坏那些来竞争的外国商品，捣毁机器，烧毁工厂，力图恢复已经失去的中世纪工人的地位。</p>
<p>在这个阶段上，工人是分散在全国各地并为竞争所分裂的群众。工人的大规模集结，还不是他们自己联合的结果，而是资产阶级联合的结果，当时资产阶级为了达到自己的政治目的必须而且暂时还能够把整个无产阶级发动起来。因此，在这个阶段上，无产者不是同自己的敌人作斗争，而是同自己的敌人的敌人作斗争，即同专制君主制的残余、地主、非工业资产者和小资产者作斗争。因此，整个历史运动都集中在资产阶级手里；在这种条件下取得的每一个胜利都是资产阶级的胜利。</p>
<p>但是，随着工业的发展，无产阶级不仅人数增加了，而且它结合成更大的集体，它的力量日益增长，它越来越感觉到自己的力量。机器使劳动的差别越来越小，使工资几乎到处都降到同样低的水平，因而无产阶级内部的利益、生活状况也越来越趋于一致。资产者彼此间日益加剧的竞争以及由此引起的商业危机，使工人的工资越来越不稳定；机器的日益迅速的和继续不断的改良，使工人的整个生活地位越来越没有保障；单个工人和单个资产者之间的冲突越来越具有两个阶级的冲突的性质。工人开始成立反对资产者的同盟；他们联合起来保卫自己的工资。他们甚至建立了经常性的团体，以便为可能发生的反抗准备食品。有些地方，斗争爆发为起义。</p>
<p>工人有时也得到胜利，但这种胜利只是暂时的。他们斗争的真正成果并不是直接取得的成功，而是工人的越来越扩大的联合。这种联合由于大工业所造成的日益发达的交通工具而得到发展，这种交通工具把各地的工人彼此联系起来。只要有了这种联系，就能把许多性质相同的地方性的斗争汇合成全国性的斗争，汇合成阶级斗争。而一切阶级斗争都是政治斗争。中世纪的市民靠乡间小道需要几百年才能达到的联合，现代的无产者利用铁路只要几年就可以达到了。</p>
<p>无产者组织成为阶级，从而组织成为政党这件事，不断地由于工人的自相竞争而受到破坏。但是，这种组织总是重新产生，并且一次比一次更强大，更坚固，更有力。它利用资产阶级内部的分裂，迫使他们用法律形式承认工人的个别利益。英国的十小时工作日法案就是一个例子。</p>
<p>旧社会内部的所有冲突在许多方面都促进了无产阶级的发展。资产阶级处于不断的斗争中：最初反对贵族；后来反对同工业进步有利害冲突的那部分资产阶级；经常反对一切外国的资产阶级。在这一切斗争中，资产阶级都不得不向无产阶级呼吁，要求无产阶级援助，这样就把无产阶级卷进了政治运动。于是，资产阶级自己就把自己的教育因素即反对自身的武器给予了无产阶级。</p>
<p>其次，我们已经看到，工业的进步把统治阶级的整批成员抛到无产阶级队伍里去，或者至少也使他们的生活条件受到威胁。他们也给无产阶级带来了大量的教育因素。</p>
<p>最后，在阶级斗争接近决战的时期，统治阶级内部的、整个旧社会内部的瓦解过程，就达到非常强烈、非常尖锐的程度，甚至使得统治阶级中的一小部分人脱离统治阶级而归附于革命的阶级，即掌握着未来的阶级。所以，正像过去贵族中有一部分人转到资产阶级方面一样，现在资产阶级中也有一部分人，特别是已经提高到从理论上认识整个历史运动这一水平的一部分资产阶级思想家，转到无产阶级方面来了。</p>
<p>在当前同资产阶级对立的一切阶级中，只有无产阶级是真正革命的阶级。其余的阶级都随着大工业的发展而日趋没落和灭亡，无产阶级却是大工业本身的产物。</p>
<p>中间等级，即小工业家、小商人、手工业者、农民，他们同资产阶级作斗争，都是为了维护他们这种中间等级的生存，以免于灭亡。所以，他们不是革命的，而是保守的。不仅如此，他们甚至是反动的，因为他们力图使历史的车轮倒转。如果说他们是革命的，那是鉴于他们行将转入无产阶级的队伍，这样，他们就不是维护他们目前的利益，而是维护他们将来的利益，他们就离开自己原来的立场，而站到无产阶级的立场上来。</p>
<p>流氓无产阶级是旧社会最下层中消极的腐化的部分，他们在一些地方也被无产阶级革命卷到运动里来，但是，由于他们的整个生活状况，他们更甘心于被人收买，去干反动的勾当。</p>
<p>在无产阶级的生活条件中，旧社会的生活条件已经被消灭了。无产者是没有财产的；他们和妻子儿女的关系同资产阶级的家庭关系再没有任何共同之处了；现代的工业劳动，现代的资本压迫，无论在英国或法国，无论在美国或德国，都有是一样的，都使无产者失去了任何民族性。法律、道德、宗教在他们看来全都是资产阶级偏见，隐藏在这些偏见后面的全都是资产阶级利益。</p>
<p>过去一切阶级在争得统治之后，总是使整个社会服从于它们发财致富的条件，企图以此来巩固它们已获得的生活地位。无产者只有废除自己的现存的占有方式，从而废除全部现存的占有方式，才能取得社会生产力。无产者没有什么自己的东西必须加以保护，他们必须摧毁至今保护和保障私有财产的一切。</p>
<p>过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的、为绝大多数人谋利益的独立的运动。无产阶级，现今社会的最下层，如果不炸毁构成官方社会的整个上层，就不能抬起头来，挺起胸来。</p>
<p>如果不就内容而就形式来说，无产阶级反对资产阶级的斗争首先是一国范围内的斗争。每一个国家的无产阶级当然首先应该打倒本国的资产阶级。</p>
<p>在叙述无产阶级发展的最一般的阶段的时候，我们循序探讨了现存社会内部或多或少隐蔽着的国内战争，直到这个战争爆发为公开的革命，无产阶级用暴力推翻资产阶级而建立自己的统治。</p>
<p>我们已经看到，至今的一切社会都是建立在压迫阶级和被压迫阶级的对立之上的。但是，为了有可能压迫一个阶级，就必须保证这个阶级至少有能够勉强维持它的奴隶般的生存的条件。农奴曾经在农奴制度下挣扎到公社成员的地位，小资产者曾经在封建专制制度的束缚下挣扎到资产者的地位。现代的工人却相反，他们并不是随着工业的进步而上升，而是越来越降到本阶级的生存条件以下。工人变成赤贫者，贫困比人口和财富增长得还要快。由此可以明显地看出，资产阶级再不能做社会的统治阶级了，再不能把自己阶级的生存条件当作支配一切的规律强加于社会了。资产阶级不能统治下去了，因为它甚至不能保证自己的奴隶维持奴隶的生活，因为它不得不让自己的奴隶落到不能养活它反而要它来养活的地步。社会再不能在它统治下生存下去了，就是说，它的生存不再同社会相容了。</p>
<p>资产阶级生存和统治的根本条件，是财富在私人手里的积累，是资本的形成和增殖；资本的条件是雇佣劳动。雇佣劳动完全是建立在工人的自相竞争之上的。资产阶级无意中造成而又无力抵抗的工业进步，使工人通过结社而达到的革命联合代替了他们由于竞争而造成的分散状态。于是，随着大工业的发展，资产阶级赖以生产和占有产品的基础本身也就从它的脚下被挖掉了。它首先生产的是它自身的掘墓人。资产阶级的灭亡和无产阶级的胜利是同样不可避免的。</p>
<h3 id="二、无产者和共产党人"><strong>二、无产者和共产党人</strong></h3>
<p>共产党人同全体无产者的关系是怎样的呢？</p>
<p>共产党人不是同其他工人政党相对立的特殊政党。</p>
<p>他们没有任何同整个无产阶级的利益不同的利益。</p>
<p>他们不提出任何特殊的原则，用以塑造无产阶级的运动。</p>
<p>共产党人同其他无产阶级政党不同的地方只是：一方面，在无产者不同的民族的斗争中，共产党人强调和坚持整个无产阶级共同的不分民族的利益；另一方面，在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p>
<p>因此，在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。</p>
<p>共产党人的最近目的是和其他一切无产阶级政党的最近目的一样的：使无产阶级形成为阶级，推翻资产阶级的统治，由无产阶级夺取政权。</p>
<p>共产党人的理论原理，决不是以这个或那个世界改革家所发明或发现的思想、原则为根据的。</p>
<p>这些原理不过是现存的阶级斗争、我们眼前的历史运动的真实关系的一般表述。废除先前存在的所有制关系，并不是共产主义所独具的特征。</p>
<p>一切所有制关系都经历了经常的历史更替、经常的历史变更。</p>
<p>例如，法国革命废除了封建的所有制，代之以资产阶级的所有制。</p>
<p>共产主义的特征并不是要废除一般的所有制，而是要废除资产阶级的所有制。</p>
<p>但是，现代的资产阶级私有制是建立在阶级对立上面、建立在一些人对另一些人的剥削上面的产品生产和占有的最后而又完备的表现。</p>
<p>从这个意义上说，共产党人可以把自己的理论概括为一句话：消灭私有制。</p>
<p>有人责备我们共产党人，说我们消灭个人挣得的、自己劳动得来的财产，要消灭构成个人的一切自由、活动和独立的基础的财产。</p>
<p>好一个劳动得来的、自己挣得的、自己赚来的财产！你们说的是资产阶级财产出现以前的那种小资产阶级、小农的财产吗？那种财产用不着我们去消灭，工业的发展已经把它消灭了，而且每天都在消灭它。</p>
<p>或者，你们说的是现代的资产阶级的私有财产吧？</p>
<p>但是，难道雇佣劳动，无产者的劳动，会给无产者创造出财产来吗？没有的事。这种劳动所创造的资本，即剥削雇佣劳动的财产，只有在不断产生出新的雇佣劳动来重新加以剥削的条件下才能增殖的财产。现今的这种财产是在资本和雇佣劳动的对立中运动的。让我们来看看这种对立的两个方面吧。</p>
<p>做一个资本家，这就是说，他在生产中不仅占有一种纯粹个人的地位，而且占有一种社会地位。资本是集体的产物，它只有通过社会许多成员的共同活动，而且归根到底只有通过社会全体成员的共同活动，才能运动起来。</p>
<p>因此，资本不是一种个人力量，而是一种社会力量。</p>
<p>因此，把资本变为公共的、属于社会全体成员的财产，这并不是把个人财产变为社会财产。这里所改变的只是财产的社会性质。它将失掉它的阶级性质。</p>
<p>现在，我们来看看雇佣劳动。</p>
<p>雇佣劳动的平均价格是最低限度的工资，即工人为维持其工人的生活所必需的生活资料的数额。因此，雇佣工人靠自己的劳动所占有的东西，只够勉强维持他的生命的再生产。我们决不打算消灭这种供直接生命再生产用的劳动产品的个人占有，这种占有并不会留下任何剩余的东西使人们有可能支配别人的劳动。我们要消灭的只是这种占有的可怜的性质，在这种占有下，工人仅仅为增殖资本而活着，只有在统治阶级的利益需要他活着的时候才能活着。</p>
<p>在资产阶级社会里，活的劳动只是增殖已经积累起来的劳动的一种手段。在共产主义社会里，已经积累起来的劳动只是扩大、丰富和提高工人的生活的一种手段。</p>
<p>因此，在资产阶级社会里是过去支配现在，在共产主义社会里是现在支配过去。在资产阶级社会里，资本具有独立性和个性，而活动着的个人却没有独立性和个性。</p>
<p>而资产阶级却把消灭这种关系说成是消灭个性和自由！说对了。的确，正是要消灭资产者的个性、独立性和自由。</p>
<p>在现今的资产阶级生产关系的范围内，所谓自由就是自由贸易，自由买卖。</p>
<p>但是，买卖一消失，自由买卖也就会消失。关于自由买卖的言论，也像我们的资产阶级的其他一切关于自由的大话一样，仅仅对于不自由的买卖来说，对于中世纪被奴役的市民来说，才是有意义的，而对于共产主义要消灭买卖、消灭资产阶级生产关系和资产阶级本身这一点来说，却是毫无意义的。</p>
<p>我们要消灭私有制，你们就惊慌起来。但是，在你们的现存社会里，私有财产对十分之九的成员来说已经被消灭了；这种私有制这所以存在，正是因为私有财产对十分之九的成员来说已经不存在。可见，你们责备我们，是说我们要消灭那种以社会上的绝大多数人没有财产为必要条件的所有制。</p>
<p>总而言之，你们责备我们，是说我们要消灭你们的那种所有制。的确，我们是要这样做的。</p>
<p>从劳动不再能变为资本、货币、地租，一句话，不再能变为可以垄断的社会力量的时候起，就是说，从个人财产不再能变为资产阶级财产的时候起，你们说，个性被消灭了。</p>
<p>由此可见，你们是承认，你们所理解的个性，不外是资产者、资产阶级私有者。这样的个性确实应当被消灭。</p>
<p>共产主义并不剥夺任何人占有社会产品的权力，它只剥夺利用这种占有去奴役他人劳动的权力。</p>
<p>有人反驳说，私有制一消灭，一切活动就会停止，懒惰之风就会兴起。</p>
<p>这样说来，资产阶级社会早就应该因懒惰而灭亡了，因为在这个社会里劳者不获，获者不劳。所有这些顾虑，都可以归结为这样一个同义反复：一旦没有资本，也就不再有雇佣劳动了。</p>
<p>所有这些对共产主义的物质产品的占有方式和生产方式的责备，也被扩及到精神产品的占有和生产方面。正如阶级的所有制的终止在资产者看来是生产本身的终止一样，阶级的教育的终止在他们看来就等于一切教育的终止。</p>
<p>资产者唯恐失去的那种教育，绝大多数人来说是把人训练成机器。</p>
<p>但是，你们既然用你们资产阶级关于自由、教育、法等等的观念来衡量废除资产阶级所有制的主张，那就请你们不要同我们争论了。你们的观念本身是资产阶级的生产关系和所有制关系的产物，正像你们的法不过是被奉为法律的你们这个阶级的意志一样，而这种意志的内容是由你们这个阶级的物质生活条件决定的。</p>
<p>你们的利己观念使你们把自己的生产关系和所有制关系从历史的、在生产过程中是暂时的关系变成永恒的自然规律和理性规律，这种利己观念是你们和一切灭亡了的统治阶级所共有的。谈到古代所有制的时候你们所能理解的，谈到封建所有制的时候你们所能理解的，一谈到资产阶级所有制你们就再也不能理解了。</p>
<p>消灭家庭！连极端的激进派也对共产党人的这种可耻的意图表示愤慨。</p>
<p>现代的、资产阶级的家庭是建立在什么基础上的呢？是建立在资本上面，建立在私人发财上面的。这种家庭只是在资产阶级那里才以充分发展的形式存在着，而无产者的被迫独居和公开的卖淫则是它的补充。</p>
<p>资产者的家庭自然会随着它的这种补充的消失而消失，两者都要随着资本的消失而消失。</p>
<p>你们是责备我们要消灭父母对子女的剥削吗？我们承认这种罪状。</p>
<p>但是，你们说，我们用社会教育代替家庭教育，就是要消灭人们最亲密的关系。</p>
<p>而你们的教育不也是由社会决定的吗？不也是由你们进行教育时所处的那种社会关系决定的吗？不也是由社会通过学校等等进行的直接的或间接的干涉决定的吗？共产党人并没有发明社会对教育的作用；他们仅仅是要改变这种作用的性质，要使教育摆脱统治阶级的影响。</p>
<p>无产者的一切家庭联系越是由于大工业的发展而被破坏，他们的子女越是由于这种发展而被变成单纯的商品和劳动工具，资产阶级关于家庭和教育、关于父母和子女的亲密关系的空话就越是令人作呕。</p>
<p>但是，你们共产党人是要实行公妻制的啊，——整个资产阶级异口同声地向我们这样叫喊。</p>
<p>资产者是把自己的妻子看作单纯的生产工具的。他们听说生产工具将要公共使用，自然就不能不想到妇女也会遭到同样的命运。</p>
<p>他们想也没有想到，问题正在于使妇女不再处于单纯生产工具的地位。</p>
<p>其实，我们的资产者装得道貌岸然，对所谓的共产党人的正式公妻制表示惊讶，那是再可笑不过了。公妻制无需共产党人来实行，它差不多是一向就有的。</p>
<p>我们的资产者不以他们的无产者的妻子和女儿受他们支配为满足，正式的卖淫更不必说了，他们还以互相诱奸妻子为最大的享乐。</p>
<p>资产阶级的婚姻实际上是公妻制。人们至多只能责备共产党人，说他们想用正式的、公开的公妻制来代替伪善地掩蔽着的公妻制。其实，不言而喻，随着现在的生产关系的消灭，从这种关系中产生的公妻制，即正式的和非正式的卖淫，也就消失了。</p>
<p>有人还责备共产党人，说他们要取消祖国，取消民族。</p>
<p>工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。</p>
<p>随着资产阶级的发展，随着贸易自由的实现和世界市场的建立，随着工业生产以及与之相适应的生活条件的趋于一致，各国人民之间的民族分隔和对立日益消失。</p>
<p>无产阶级的统治将使它们更快地消失。联合的行动，至少是各文明国家的联合的行动，是无产阶级获得解放的首要条件之一。</p>
<p>人对人的剥削一消灭，民族对民族的剥削就会随之消灭。</p>
<p>民族内部的阶级对立一消失，民族之间的敌对关系就会随之消失。</p>
<p>从宗教的、哲学的和一切意识形态的观点对共产主义提出的种种责难，都不值得详细讨论了。</p>
<p>人们的观念、观点和概念，一句话，人们的意识，随着人们的生活条件、人们的社会关系、人们的社会存在的改变而改变，这难道需要经过深思才能了解吗？</p>
<p>思想的历史除了证明精神生产随着物质生产的改造而改造，还证明了什么呢？任何一个时代的统治思想始终都不过是统治阶级的思想。</p>
<p>当人们谈到使整个社会革命化的思想时，他们只是表明了一个事实：在旧社会内部已经形成了新社会的因素，旧思想的瓦解是同旧生活条件的瓦解步调一致的。</p>
<p>当古代世界走向灭亡的时候，古代的各种宗教就被基督教战胜了。当基督教思想在18世纪被启蒙思想击败的时候，封建社会正在同当时革命的资产阶级进行殊死的斗争。信仰自由和宗教自由的思想，不过表明竞争在信仰领域里占统治地位罢了。</p>
<p>“但是”，有人会说，“宗教的、道德的、哲学的、政治的、法的观念等等在历史发展的进程中固然是不断改变的，而宗教、道德、哲学、政治和法在这种变化中却始终保存着。</p>
<p>此外，还存在着一切社会状态所共有的永恒真理，如自由、正义等等。但是共产主义要废除永恒真理，它要废除宗教、道德，而不是加以革新，所以共产主义是同至今的全部历史发展相矛盾的。”</p>
<p>这种责难归结为什么呢？至今的一切社会的历史都是在阶级对立中运动的，而这种对立在不同的时代具有不同的形式。</p>
<p>但是，不管阶级对立具有什么样的形式，社会上一部分人对另一部分人的剥削却是过去各个世纪所共有的事实。因此，毫不奇怪，各个世纪的社会意识，尽管形形色色、千差万别，总是在某些共同的形式中运动的，这些形式，这些意识形式，只有当阶级对立完全消失的时候才会完全消失。</p>
<p>共产主义革命就是同传统的所有制关系实行最彻底的决裂；毫不奇怪，它在自己的发展进程中要同传统的观念实行最彻底的决裂。</p>
<p>不过，我们还是把资产阶级对共产主义的种种责难撇开吧。</p>
<p>前面我们已经看到，工人革命的第一步就是使无产阶级上升为统治阶级，争得民主。</p>
<p>无产阶级将利用自己的政治统治，一步一步地夺取资产阶级的全部资本，把一切生产工具集中在国家即组织成为统治阶级的无产阶级手里，并且尽可能快地增加生产力的总量。</p>
<p>要做到这一点，当然首先必须对所有权和资产阶级生产关系实行强制性的干涉，也就是采取这样一些措施，这些措施在经济上似乎是不够充分的和没有力量的，但是在运动进程中它们会越出本身，而且作为变革全部生产方式的手段是必不可少的。</p>
<p>这些措施在不同的国家里当然会是不同的。</p>
<p>但是，最先进的国家几乎都可以采取下面的措施：</p>
<ol>
<li>剥夺地产，把地租用于国家支出。</li>
<li>征收高额累进税。</li>
<li>废除继承权。</li>
<li>没收一切流亡分子和叛乱分子的财产。</li>
<li>通过拥有国家资本和独享垄断权的国家银行，把信贷集中在国家手里。</li>
<li>把全部运输业集中在国家的手里。</li>
<li>按照总的计划增加国家工厂和生产工具，开垦荒地和改良土壤。</li>
<li>实行普遍劳动义务制，成立产业军，特别是在农业方面。</li>
<li>把农业和工业结合起来，促使城乡对立逐步消灭。</li>
<li>对所有儿童实行公共的和免费的教育。取消现在这种形式的儿童的工厂劳动。把教育同物质生产结合起来，等等。</li>
</ol>
<p>当阶级差别在发展进程中已经消失而全部生产集中在联合起来的个人的手里的时候，公共权力就失去政治性质。原来意义上的政治权力，是一个阶级用以压迫另一个阶级的有组织的暴力。如果说无产阶级在反对资产阶级的斗争中一定要联合为阶级，如果说它通过革命使自己成为统治阶级，并以统治阶级的资格用暴力消灭旧的生产关系，那么它在消灭这种生产关系的同时，也就消灭了阶级对立的存在条件，消灭阶级本身的存在条件，从而消灭了它自己这个阶级的统治。</p>
<p>代替那存在着阶级和阶级对立的资产阶级旧社会的，将是这样一个联合体，在那里，每个人的自由发展是一切人的自由发展的条件。</p>
<h3 id="三、社会主义的和共产主义的文献"><strong>三、社会主义的和共产主义的文献</strong></h3>
<h4 id="1．反动的社会主义">1．反动的社会主义</h4>
<p>（甲）封建的社会主义</p>
<p>法国和英国的贵族，按照他们的历史地位所负的使命，就是写一些抨击现代资产阶级社会的作品。在法国的1830年七月革命和英国的改革运动中，他们再一次被可恨的暴发户打败了。从此就再谈不上严重的政治斗争了。他们还能进行的只是文字斗争。但是，即使在文字方面也不可能重弹复辟时期的老调了。为了激起同情，贵族们不得不装模作样，似乎他们已经不关心自身的利益，只是为了被剥削的工人阶级的利益才去写对资产阶级的控诉书。他们用来泄愤的手段是：唱唱诅咒他们的新统治者的歌，并向他叽叽咕咕地说一些或多或少凶险的预言。</p>
<p>这样就产生了封建的社会主义，半是挽歌，半是谤文，半是过去的回音，半是未来的恫吓；它有时也能用辛辣、俏皮而尖刻的评论剌中资产阶级的心，但是它由于完全不能理解现代历史的进程而总是令人感到可笑。</p>
<p>为了拉拢人民，贵族们把无产阶级的乞食袋当作旗帜来挥舞。但是，每当人民跟着他们走的时候，都发现他们的臀部带有旧的封建纹章，于是就哈哈大笑，一哄而散。</p>
<p>一部分法国正统派和“青年英国”，都演过这出戏。</p>
<p>封建主说，他们的剥削方式和资产阶级的剥削不同，那他们只是忘记了，他们是在完全不同的、目前已经过时的情况和条件下进行剥削的。他们说，在他们的统治下并没有出现过现代的无产阶级，那他们只是忘记了，现代的资产阶级正是他们的社会制度的必然产物。</p>
<p>不过，他们毫不掩饰自己的批评的反动性质，他们控告资产阶级的主要罪状正是在于：在资产阶级的统治下有一个将把整个旧社会制度炸毁的阶级发展起来。</p>
<p>他们责备资产阶级，与其说是因为它产生了无产阶级，不如说是因为它产生了革命的无产阶级。</p>
<p>因此，在政治实践中，他们参与对工人阶级采取的一切暴力措施，在日常生活中，他们违背自己的那一套冠冕堂皇的言词，屈尊拾取金苹果，不顾信义、仁爱和名誉去做羊毛、甜菜和烧洒的买卖。</p>
<p>正如僧侣总是同封建主携手同行一样，僧侣的社会主义也总是同封建的社会主义携手同行的。</p>
<p>要给基督教禁欲主义涂上一层社会主义的色彩，是再容易不过了。基督教不是也激烈反对私有财产，反对婚姻，反对国家吗？它不是提倡用行善和求乞、独身和禁欲、修道和礼拜来代替这一切吗？基督教的社会主义，只不过是僧侣用来使贵族的怨愤神圣的圣水罢了。</p>
<p>（乙）小资产阶级的社会主义</p>
<p>封建贵族并不是被资产阶级所推翻的、其生活条件在现代资产阶级社会里日益恶化和消失的唯一阶级。中世纪的城关市民和小农等级是现代资产阶级的前身。在工商业不很发达的国家里，这个阶级还在新兴的资产阶级身旁勉强生存着。</p>
<p>在现代文明已经发展的国家里，形成了一个新的小资产阶级，它摇摆于无产阶级和资产阶级之间，并且作为资产阶级社会的补充部分不断地重新组成。但是，这一阶级的成员经常被竞争抛到无产阶级队伍里去，而且，随着大工业的发展，他们甚至觉察到，他们很快就会完全失去他们作为现代社会中一个独立部分的地位，在商业、工业和农业中很快就会被监工和雇员所代替。</p>
<p>在农民阶级远远超过人口半数的国家，例如在法国，那些站在无产阶级方面反对资产阶级的著作家，自然是用小资产阶级和小农的尺度去批判资产阶级制度的，是从小资产阶级的立场出发替工人说话的。这样就形成了小资产阶级的社会主义。西斯蒙第不仅对法国而且对英国来说都是这类著作家的首领。</p>
<p>这种社会主义非常透彻地分析了现代生产关系中的矛盾。它揭穿了经济学家的虚伪的粉饰。它确凿地证明了机器和分工的破坏作用、资本和地产的积聚、生产过剩、危机、小资产者和小农的必然没落、无产阶级的贫困、生产的无政府状态、财富分配的极不平均、各民族之间的毁灭性的工业战争，以及旧风尚、旧家庭关系和旧民族性的解体。</p>
<p>但是，这种社会主义按其实际内容来说，或者是企图恢复旧的生产资料和交换手段，从而恢复旧的所有制关系和旧的社会，或者是企图重新把现代的生产资料和交换手段硬塞到已被它们突破而且必然被突破的旧的所有制关系的框子里去。它在这两种场合都是反动的，同时又是空想的。</p>
<p>工业中的行会制度，农业中的宗法经济，——这就是它的结论。</p>
<p>这一思潮在它以后的发展中变成了一种怯懦的悲叹。</p>
<p>（丙）德国的或“真正的”社会主义</p>
<p>法国的社会主义和共产主义的文献是在居于统治地位的资产阶级的压迫下产生的，并且是同这种统治作斗争的文字表现，这种文献被搬到德国的时候，那里的资产阶级才刚刚开始进行反对封建专制制度的斗争。</p>
<p>德国的哲学家、半哲学家和美文学家，贪婪地抓住了这种文献，不过他们忘记了：在这种著作从法国搬到德国的时候，法国的生活条件却没有同时搬过去。在德国的条件下，法国的文献完全失去了直接实践的意义，而只具有纯粹文献的形式。它必然表现为关于真正的社会、关于实现人的本质的无谓思辨。这样，第一次法国革命的要求，在18世纪的德国哲学家看来，不过是一般“实践理性”的要求，而革命的法国资产阶级的意志的表现，在他们心目中就是纯粹的意志、本来的意志、真正人的意志的规律。</p>
<p>德国著作家的唯一工作，就是把新的法国的思想同他们的旧的哲学信仰调和起来，或者毋宁说，就是从他们的哲学观点出发去掌握法国的思想。</p>
<p>这种掌握，就像掌握外国语一样，是通过翻译的。</p>
<p>大家知道，僧侣们曾经在古代异教经典的手抄本上面写上荒诞的天主教圣徒传。德国著作家对世俗的法国文献采取相反的作法。他们在法国的原著下面写上自己的哲学胡说。例如，他们在法国人对货币关系的批判下面写上“人的本质的外化”，在法国人对资产阶级国家的批判下面写上所谓“抽象普遍物的统治的扬弃”，等等。</p>
<p>这种在法国人的论述下面塞进自己哲学词句的做法，他们称之为“行动的哲学”、”真正的社会主义”、“德国的社会主义科学”、“社会主义的哲学论证”，等等。</p>
<p>法国的社会主义和共产主义的文献就这样被完全阉割了。既然这种文献在德国人手里已不再表现一个阶级反对另一个阶级的斗争，于是德国人就认为：他们克服了“法国人的片面性”，他们不代表真实的要求，而代表真理的要求，不代表无产者的利益，而代表人的本质的利益，即一般人的利益，这种人不属于任何阶级，根本不存在于现实界，而只存在于云雾弥漫的哲学幻想的太空。</p>
<p>这种曾经郑重其事地看待自己那一套拙劣的小学生作业并且大言不惭地加以吹嘘的德国社会主义，现在渐渐失去了它的自炫博学的天真。</p>
<p>德国的特别是普鲁士的资产阶级反对封建主和专制王朝的斗争，一句话，自由主义运动，越来越严重了。</p>
<p>于是，“真正的”社会主义就得到了一个好机会，把社会主义的要求同政治运动对立起来，用诅咒异端邪说的传统办法诅咒自由主义，诅咒代议制国家，诅咒资产阶级的竞争、资产阶级的新闻出版自由、资产阶级的法、资产阶级的自由和平等，并且向人民群众大肆宣扬，说什么在这个资产阶级运动中，人民群众非但一无所得，反而会失去一切。德国的社会主义恰好忘记了，法国的批判（德国的社会主义是这种批判的可怜的回声）是以现代的资产阶级社会以及相应的物质生活条件和相当的政治制度为前提的，而这一切前提当时在德国正是尚待争取的。</p>
<p>这种社会主义成了德意志各邦专制政府及其随从——僧侣、教员、容克和官僚求之不得的、吓唬来势汹汹的资产阶级的稻草人。</p>
<p>这种社会主义是这些政府用来镇压德国工人起义的毒辣的皮鞭和枪弹的甜蜜的补充。</p>
<p>既然“真正的”社会主义就这样成了这些政府对付德国资产阶级的武器，那么它也就直接代表了一种反动的利益，即德国小市民的利益。在德国，16世纪遗留下来的、从那时起经常以不同形式重新出现的小资产阶级，是现存制度的真实的社会基础。</p>
<p>保存这个小资产阶级，就是保存德国的现存制度。这个阶级胆战心惊地从资产阶级的工业统治和政治统治那里等候着无可幸免的灭亡，这一方面是由于资本的积聚，另一方面是由于革命无产阶级的兴起。在它看来，“真正的”社会主义能起一箭双雕的作用。“真正的”社会主义像瘟疫一样流行起来了。</p>
<p>德国的社会主义者给自己的那几条干瘪的“永恒真理”披上一件用思辨的蛛丝织成的、绣满华丽辞藻的花朵和浸透甜情蜜意的甘露的外衣，这件光彩夺目的外衣只是使他们的货物在这些顾客中间增加销路罢了。</p>
<p>同时，德国的社会主义也越来越认识到自己的使命就是充当这种小市民的夸夸其谈的代言人。</p>
<p>它宣布德意志民族是模范的民族，德国小市民是模范的人。它给这些小市民的每一种丑行都加上奥秘的、高尚的、社会主义的意义，使之变成完全相反的东西。它发展到最后，就直接反对共产主义的“野蛮破坏的”倾向，并且宣布自己是不偏不倚地超乎任何阶级斗争之上的。现今在德国流行的一切所谓社会主义和共产主义的著作，除了极少数的例外，都属于这一类卑鄙龌龊的、令人委靡的文献。</p>
<h4 id="2．保守的或资产阶级的社会主义">2．保守的或资产阶级的社会主义</h4>
<p>资产阶级中的一部分人想要消除社会的弊病，以便保障资产阶级社会的生存。</p>
<p>这一部分人包括：经济学家、博爱主义者、人道主义者、劳动阶级状况改善派、慈善事业组织者、动物保护协会会员、戒酒协会发起人以及形形色色的小改良家。这种资产阶级的社会主义甚至被制成一些完整的体系。</p>
<p>我们可以举蒲鲁东的《贫困的哲学》作为例子。</p>
<p>社会主义的资产者愿意要现代社会的生存条件，但是不要由这些条件必然产生的斗争和危险。他们愿意要现存的社会，但是不要那些使这个社会革命化和瓦解的因素。他们愿意要资产阶级，但是不要无产阶级。在资产阶级看来，它所统治的世界自然是最美好的世界。资产阶级的社会主义把这种安慰人心的观念制成半套或整套的体系。它要求无产阶级实现它的体系，走进新的耶路撒冷，其实它不过是要求无产阶级停留在现今的社会里，但是要抛弃他们关于这个社会的可恶的观念。</p>
<p>这种社会主义的另一种不够系统、但是比较实际的形式，力图使工人阶级厌弃一切革命运动，硬说能给工人阶级带来好处的并不是这样或那样的政治改革，而仅仅是物质生活条件即经济关系的改变。但是，这种社会主义所理解的物质生活条件的改变，绝对不是只有通过革命的途径才能实现的资产阶级生产关系的废除，而是一些在这种生产关系的基础上实行的行政上的改良，因而丝毫不会改变资本和雇佣劳动的关系，至多只能减少资产阶级的统治费用和简化它的财政管理。</p>
<p>资产阶级的社会主义只有在它变成纯粹的演说辞令的时候，才获得自己的适当的表现。</p>
<p>自由贸易！为了工人阶级的利益；保护关税！为了工人阶级的利益；单身牢房！为了工人阶级的利益。——这才是资产阶级的社会主义唯一认真说出的最后的话。</p>
<p>资产阶级的社会主义就是这样一个论断：资产者之为资产者，是为了工人阶级的利益。</p>
<h4 id="3．批判的空想的社会主义和共产主义">3．批判的空想的社会主义和共产主义</h4>
<p>在这里，我们不谈在现代一切大革命中表达过无产阶级要求的文献（巴贝夫等人的著作）。</p>
<p>无产阶级在普遍激动的时代、在推翻封建社会的时期直接实现自己阶级利益的最初尝试，都不可避免地遭到了失败，这是由于当时无产阶级本身还不够发展，由于无产阶级解放的物质条件还没具备，这些条件只是资产阶级时代的产物。随着这些早期的无产阶级运动而出现的革命文献，就其内容来说必然是反动的。这种文献倡导普遍的禁欲主义和粗陋的平均主义。</p>
<p>本来意义的社会主义和共产主义的体系，圣西门、傅立叶、欧文等人的体系，是在无产阶级和资产阶级之间的斗争还不发展的最初时期出现的。关于这个时期，我们在前面已经叙述过了（见《资产阶级和无产阶级》）。</p>
<p>诚然，这些体系的发明家看到了阶级的对立，以及占统治地位的社会本身中的瓦解因素的作用。但是，他们看不到无产阶级方面的任何历史主动性，看不到它所特有的任何政治运动。</p>
<p>由于阶级对立的发展是同工业的发展步调一致的，所以这些发明家也不可能看到无产阶级解放的物质条件，于是他们就去探求某种社会科学、社会规律，以便创造这些条件。</p>
<p>社会的活动要由他们个人的发明活动来代替，解放的历史条件要由幻想的条件来代替，无产阶级的逐步组织成为阶级要由一种特意设计出来的社会组织来代替。在他们看来，今后的世界历史不过是宣传和实施他们的社会计划。</p>
<p>诚然，他们也意识到，他们的计划主要是代表工人阶级这一受苦最深的阶级的利益。在他们心目中，无产阶级只是一个受苦最深的阶级。</p>
<p>但是，由于阶级斗争不发展，由于他们本身的生活状况，他们就以为自己是高高超乎这种阶级对立之上的。他们要改善社会一切成员的生活状况，甚至生活最优裕的成员也包括在内。因此，他们总是不加区别地向整个社会呼吁，而且主要是向统治阶级呼吁。他们以为，人们只要理解他们的体系，就会承认这种体系是最美好的社会的最美好的计划。</p>
<p>因此，他们拒绝一切政治行动，特别是一切革命行动；他们想通过和平的途径达到自己的目的，并且企图通过一些小型的、当然不会成功的试验，通过示范的力量来为新的社会福音开辟道路。</p>
<p>这种对未来社会的幻想的描绘，在无产阶级还很不发展、因而对本身的地位的认识还基于幻想的时候，是同无产阶级对社会普遍改造的最初的本能的渴望相适应的。</p>
<p>但是，这些社会主义和共产主义的著作也含有批判的成分。这些著作抨击现存社会的全部基础。因此，它们提供了启发工人觉悟的极为宝贵的材料。它们关于未来社会的积极的主张，例如消灭城乡对立，消灭家庭，消灭私人营利，消灭雇佣劳动，提倡社会和谐，把国家变成纯粹的生产管理机构，——所有这些主张都只是表明要消灭阶级对立，而这种阶级对立在当时刚刚开始发展，它们所知道的只是这种对立的早期的、不明显的、不确定的形式。因此，这些主张本身还带有纯粹空想的性质。</p>
<p>批判的空想的社会主义和共产主义的意义，是同历史的发展成反比的。阶级斗争越发展和越具有确定的形式，这种超乎阶级斗争的幻想，这种反对阶级斗争的幻想，就越失去任何实践意义和任何理论根据。所以，虽然这些体系的创始人在许多方面是革命的，但是他们的信徒总是组成一些反动的宗派。这些信徒无视无产阶级的历史进展，还是死守着老师们的旧观点。因此，他们一贯企图削弱阶级斗争，调和对立。他们还总是梦想用试验的办法来实现自己的社会空想，创办单个的法伦斯泰尔，建立国内移民区，创立小伊加利亚，即袖珍版的新耶路撒冷，——而为了建造这一切空中楼阁，他们就不得不呼吁资产阶级发善心和慷慨解囊。他们逐渐地堕落到上述反动的或保守的社会主义者的一伙中去了，所不同的只是他们更加系统地卖弄学问，狂热地迷信自己那一套社会科学的奇功异效。</p>
<p>因此，他们激烈地反对工人的一切政治运动，认为这种运动只是由于盲目地不相信新福音才发生的。</p>
<p>在英国，有欧文主义者反对宪章派，在法国，有傅立叶主义者反对改革派。</p>
<h3 id="四、共产党人对各种反对党派的态度"><strong>四、共产党人对各种反对党派的态度</strong></h3>
<p>看过第二章之后，就可以了解共产党人同已经形成的工人政党的关系，因而也就可以了解他们同英国宪章派和北美土地改革派的关系。</p>
<p>共产党人为工人阶级的最近的目的和利益而斗争，但是他们在当前的运动中同时代表运动的未来。在法国，共产党人同社会主义民主党联合起来反对保守的和激进的资产阶级，但是并不因此放弃对那些从革命的传统中承袭下来的空谈和幻想采取批判态度的权利。</p>
<p>在瑞士，共产党人支持激进派，但是并不忽略这个政党是由互相矛盾的分子组成的，其中一部分是法国式的民主社会主义者，一部分是激进的资产者。</p>
<p>在波兰人中间，共产党人支持那个把土地革命当作民族解放的条件的政党，即发动过1846年克拉科夫起义的政党。</p>
<p>在德国，只要资产阶级采取革命的行动，共产党就同它一起去反对专制君主制、封建土地所有制和小市民的反动性。</p>
<p>但是，共产党一分钟也不忽略教育工人尽可能明确地意识到资产阶级和无产阶级的敌对的对立，以便德国工人能够立刻利用资产阶级统治所必然带来的社会的和政治的条件作为反对资产阶级的武器，以便在推翻德国的反动阶级之后立即开始反对资产阶级本身的斗争。</p>
<p>共产党人把自己的主要注意力集中在德国，因为德国正处在资产阶级革命的前夜，因为同17世纪的英国和18世纪的法国相比，德国将在整个欧洲文明更进步的条件下，拥有发展得多的无产阶级去实现这个变革，因而德国的资产阶级革命只能是无产阶级革命的直接序幕。</p>
<p>总之，共产党人到处都支持一切反对现存的社会制度和政治制度的革命运动。</p>
<p>在所有这些运动中，他们都强调所有制问题是运动的基本问题，不管这个问题的发展程度怎样。</p>
<p>最后，共产党人到处都努力争取全世界民主政党之间的团结和协调。</p>
<p>共产党人不屑于隐瞒自己的观点和意图。他们公开宣布：他们的目的只有用暴力推翻全部现存的社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链。他们获得的将是整个世界。</p>
<p>全世界无产者，联合起来！</p>
]]></content>
      <categories>
        <category>共产主义</category>
      </categories>
      <tags>
        <tag>共产主义</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念刘和珍君</title>
    <url>/yunruowuBlog/2021/06/13/%E7%BA%AA%E5%BF%B5%E5%88%98%E5%92%8C%E7%8F%8D%E5%90%9B/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>一</p>
<p>中华民国十五年三月二十五日，就是国立北京女子师范大学为十八日在段祺瑞执政府前遇害的刘和珍杨德群两君开追悼会的那一天，我独在礼堂外徘徊，遇见程君，前来问我道，“先生可曾为刘和珍写了一点什么没有?”我说“没有”。她就正告我，“先生还是写一点罢;刘和珍生前就很爱看先生的文章。”</p>
<p>这是我知道的，凡我所编辑的期刊，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了《莽原》全年的就有她。我也早觉得有写一点东西的必要了，这虽然于死者毫不相干，但在生者，却大抵只能如此而已。倘使我能够相信真有所谓“在天之灵”，那自然可以得到更大的安慰，——但是，现在，却只能如此而已。</p>
<p>可是我实在无话可说。我只觉得所住的并非人间。四十多个青年的血，洋溢在我的周围，使我难于呼吸视听，那里还能有什么言语?长歌当哭，是必须在痛定之后的。而此后几个所谓学者文人的阴险的论调，尤使我觉得悲哀。我已经出离愤怒了。我将深味这非人间的浓黑的悲凉;以我的最大哀痛显示于非人间，使它们快意于我的苦痛，就将这作为后死者的菲薄的祭品，奉献于逝者的灵前。</p>
<p>二</p>
<p>真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。这是怎样的哀痛者和幸福者?然而造化又常常为庸人设计，以时间的流驶，来洗涤旧迹，仅使留下淡红的血色和微漠的悲哀。在这淡红的血色和微漠的悲哀中，又给人暂得偷生，维持着这似人非人的世界。我不知道这样的世界何时是一个尽头!</p>
<p>我们还在这样的世上活着;我也早觉得有写一点东西的必要了。离三月十八日也已有两星期，忘却的救主快要降临了罢，我正有写一点东西的必要了。</p>
<p>三</p>
<p>在四十余被害的青年之中，刘和珍君是我的学生。学生云者，我向来这样想，这样说，现在却觉得有些踌躇了，我应该对她奉献我的悲哀与尊敬。她不是“苟活到现在的我”的学生，是为了中国而死的中国的青年。</p>
<p>她的姓名第一次为我所见，是在去年夏初杨荫榆女士做女子师范大学校长，开除校中六个学生自治会职员的时候。其中的一个就是她;但是我不认识。直到后来，也许已经是刘百昭率领男女武将，强拖出校之后了，才有人指着一个学生告诉我，说：这就是刘和珍。其时我才能将姓名和实体联合起来，心中却暗自诧异。我平素想，能够不为势利所屈，反抗一广有羽翼的校长的学生，无论如何，总该是有些桀骜锋利的，但她却常常微笑着，态度很温和。待到偏安于宗帽胡同，赁屋授课之后，她才始来听我的讲义，于是见面的回数就较多了，也还是始终微笑着，态度很温和。待到学校恢复旧观，往日的教职员以为责任已尽，准备陆续引退的时候，我才见她虑及母校前途，黯然至于泣下。此后似乎就不相见。总之，在我的记忆上，那一次就是永别了。</p>
<p>四</p>
<p>我在十八日早晨，才知道上午有群众向执政府请愿的事;下午便得到噩耗，说卫队居然开枪，死伤至数百人，而刘和珍君即在遇害者之列。但我对于这些传说，竟至于颇为怀疑。我向来是不惮以最坏的恶意，来推测中国人的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终微笑着的和蔼的刘和珍君，更何至于无端在府门前喋血呢?</p>
<p>然而即日证明是事实了，作证的便是她自己的尸骸。还有一具，是杨德群君的。而且又证明着这不但是杀害，简直是虐杀，因为身体上还有棍棒的伤痕。</p>
<p>但段政府就有令，说她们是“暴徒”!</p>
<p>但接着就有流言，说她们是受人利用的。</p>
<p>惨象，已使我目不忍视了;流言，尤使我耳不忍闻。我还有什么话可说呢?我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵!不在沉默中爆发，就在沉默中灭亡。</p>
<p>五</p>
<p>但是，我还有要说的话。</p>
<p>我没有亲见;听说她，刘和珍君，那时是欣然前往的。自然，请愿而已，稍有人心者，谁也不会料到有这样的罗网。但竟在执政府前中弹了，从背部入，斜穿心肺，已是致命的创伤，只是没有便死。同去的张静淑君想扶起她，中了四弹，其一是手枪，立仆;同去的杨德群君又想去扶起她，也被击，弹从左肩入，穿胸偏右出，也立仆。但她还能坐起来，一个兵在她头部及胸部猛击两棍，于是死掉了。</p>
<p>始终微笑的和蔼的刘和珍君确是死掉了，这是真的，有她自己的尸骸为证;沉勇而友爱的杨德群君也死掉了，有她自己的尸骸为证;只有一样沉勇而友爱的张静淑君还在医院里呻吟。当三个女子从容地转辗于文明人所发明的枪弹的攒射中的时候，这是怎样的一个惊心动魄的伟大呵!中国军人的屠戮妇婴的伟绩，八国联军的惩创学生的武功，不幸全被这几缕血痕抹杀了。</p>
<p>但是中外的杀人者却居然昂起头来，不知道个个脸上有着血污……</p>
<p>六</p>
<p>时间永是流驶，街市依旧太平，有限的几个生命，在中国是不算什么的，至多，不过供无恶意的闲人以饭后的谈资，或者给有恶意的闲人作“流言”的种子。至于此外的深的意义，我总觉得很寥寥，因为这实在不过是徒手的请愿。人类的血战前行的历史，正如煤的形成，当时用大量的木材，结果却只是一小块，但请愿是不在其中的，更何况是徒手。</p>
<p>然而既然有了血痕了，当然不觉要扩大。至少，也当浸渍了亲族;师友，爱人的心，纵使时光流驶，洗成绯红，也会在微漠的悲哀中永存微笑的和蔼的旧影。陶潜说过，“亲戚或余悲，他人亦已歌，死去何所道，托体同山阿。”倘能如此，这也就够了。</p>
<p>七</p>
<p>我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。</p>
<p>我目睹中国女子的办事，是始于去年的，虽然是少数，但看那干练坚决，百折不回的气概，曾经屡次为之感叹。至于这一回在弹雨中互相救助，虽殒身不恤的事实，则更足为中国女子的勇毅，虽遭阴谋秘计，压抑至数千年，而终于没有消亡的明证了。倘要寻求这一次死伤者对于将来的意义，意义就在此罢。</p>
<p>苟活者在淡红的血色中，会依稀看见微茫的希望;真的猛士，将更奋然而前行。</p>
<p>呜呼，我说不出话，但以此记念刘和珍君!</p>
<p>四月一日</p>
<p>发表于一九二六年四月十二日《故事会》周刊第七十四期</p>
<p>选自《华盖集续编》(《鲁迅全集》第3卷，人民文学出版社1981年版)</p>
]]></content>
      <categories>
        <category>琐记</category>
      </categories>
      <tags>
        <tag>琐记</tag>
      </tags>
  </entry>
  <entry>
    <title>dsdddddd</title>
    <url>/yunruowuBlog/2021/06/01/dsdddddd/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>dsds dasdas ad a<br>
】咋会谁</p>
]]></content>
  </entry>
  <entry>
    <title>hexo_todo</title>
    <url>/yunruowuBlog/2021/06/01/hexo-todo/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="偷懒之余，又想起了我的博客，准备重新搞起">偷懒之余，又想起了我的博客，准备重新搞起</h2>
<p>最重要的：环境，美观，之前的东西很多都不好使了，需要更新迭代一下。</p>
<ul>
<li>[ ] Valine评论，邮件提示，删除power——by</li>
<li>[ ] 美化</li>
<li>[ ] 购买域名</li>
<li>[ ] 添加搜索</li>
<li>[ ] 百度搜索录入</li>
</ul>
<p>$$<br>
y_y<br>
$$<br>
$$<br>
\begin{Bmatrix}<code> </code>a &amp; b \<code> </code>c &amp; d<code> </code>\end{Bmatrix}</p>
<p>\left[<br>
\begin{matrix}<br>
a &amp; b &amp; c &amp; d &amp; e\<br>
f &amp; g &amp; h &amp; i &amp; j \<br>
k &amp; l &amp; m &amp; n &amp; o \<br>
p &amp; q &amp; r &amp; s &amp; t<br>
\end{matrix}<br>
\right]<br>
$$</p>
]]></content>
  </entry>
  <entry>
    <title>testy</title>
    <url>/yunruowuBlog/2021/03/07/testy/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script>]]></content>
  </entry>
  <entry>
    <title>glex</title>
    <url>/yunruowuBlog/2020/11/05/glex/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Send">Send</h2>
<ol>
<li>posix_memalign()分配内存大小</li>
<li>glex_open() 建立连接
<ol>
<li>init_ipc()   <em>open the MPI and DMA socket</em></li>
<li>init_tcp()</li>
<li>init_shmem()</li>
<li>init_ipc_shmem()</li>
</ol>
</li>
<li>glex_num_of_device()获取设备数量
<ol>
<li><strong>glex_acc_sim()</strong>
<ol>
<li>sned()</li>
<li>wait_ack()</li>
</ol>
</li>
</ol>
</li>
<li>glex_open_device(dev_id, &amp;dev)，把设备地址和设备id进行匹配。</li>
<li>glex_create_ep()
<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_get_ep_addr()获取ep的地址
<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_register_mem()
<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
<li>glex_send_imm_mp() 发送mp消息
<ol>
<li>pack_sock_imm_mp_req()</li>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_receive_mp()接受数据
<ol>
<li>glex_acc_sim()</li>
</ol>
</li>
<li>glex_rdma()
<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
</ol>
<h2 id="Receive">Receive</h2>
<ol>
<li>posix_memalign()分配内存大小</li>
<li>glex_open() 建立连接
<ol>
<li>init_ipc()   <em>open the MPI and DMA socket</em></li>
<li>init_tcp()</li>
<li>init_shmem()</li>
<li>init_ipc_shmem()</li>
</ol>
</li>
<li>glex_num_of_device()获取设备数量
<ol>
<li><strong>glex_acc_sim()</strong>
<ol>
<li>sned()</li>
<li>wait_ack()</li>
</ol>
</li>
</ol>
</li>
<li>glex_open_device(dev_id, &amp;dev)，把设备地址和设备id进行匹配。</li>
<li>glex_create_ep()
<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_get_ep_addr()获取ep的地址
<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_register_mem()
<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
<li>glex_receive_mp()接受数据
<ol>
<li>glex_acc_sim()</li>
</ol>
</li>
<li>glex_send_imm_mp() 发送mp消息
<ol>
<li>pack_sock_imm_mp_req()</li>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_rdma()
<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
</ol>
<p>本地发送，本地接收。</p>
<p>一个节点，同时运行两个程序。</p>
]]></content>
  </entry>
  <entry>
    <title>Evaluation of an InfiniBand Switch:Choose Latency or Bandwidth, but Not Both</title>
    <url>/yunruowuBlog/2020/10/25/Evaluation-of-an-InfiniBand-Switch-Choose-Latency-or-Bandwidth-but-Not-Both-1/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script>]]></content>
  </entry>
  <entry>
    <title>中国计算机学会推荐会议</title>
    <url>/yunruowuBlog/2020/10/21/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="关于网络的">关于网络的</h2>
<p>顶会</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021175201851.png" alt="image-20201021175201851"></p>
<p>B类</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021175246058.png" alt="image-20201021175246058"></p>
<h2 id="体系结构">体系结构</h2>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021180139218.png" alt="image-20201021180139218"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021180324206.png" alt="image-20201021180324206"></p>
]]></content>
      <categories>
        <category>HiNA</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/yunruowuBlog/2020/10/17/test/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5299ace821708f1c10cdcbef94e4dc3e8d322ee7ec9cef9ae54bb32888bd5fa6">1b693c4938223286468132b2f7068bf65f3e8392e22eae8bba33e532b69054de0ff9611dc2ceb2a764d77ed0f1a789d5b6114cac5dec392d17e4f528d3222b583179156c751d26656cbb9583e26375abb01bfe108d1b066e6be706544eec6aacf87239d6e44ecbb9919c6fa82bb491981437483c9bc85108f89097f4c081d7b2edbbe3e5f372dde6bc056a8b9b5b77d8c44782a36c130f4dec61cd561e5b2947bae9268a39c350a9259370777e7132a4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>python打包为.exe程序</title>
    <url>/yunruowuBlog/2020/10/16/python%E6%89%93%E5%8C%85%E4%B8%BA-exe%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Python导出exe打包">Python导出exe打包</h2>
<p>最近做项目，看见可以把.py直接打包成.exe，在此学习一下。</p>
<p>工具：pyinstaller</p>
<p>下载：conda install pyinstaller</p>
<p>普通命令： pyinstaller -F -w  [.py]</p>
<p>pyinstaller [options] script [script …] | specfile</p>
<p>详解命令</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/5890308-fb1ad502516d7bc1.webp" alt="参数列表"></p>
<p>​			pyinstaller.exe后面如果加上-F就是打包为一个exe文件（文件会比较大），如果不加就会有很多库文件；加上-w就是打包为没有cmd窗口的exe,不加运行时就会出现cmd窗口。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Traffic Engineering with Forward Fault Correction</title>
    <url>/yunruowuBlog/2020/10/09/Traffic-Engineering-with-Forward-Fault-Correction/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Abstract">Abstract</h2>
<h3 id="1-Question">1. Question?</h3>
<p>网络存在故障，已有的解决办法都是在拥塞出现后，采取行动，是一种后手的行为，加上大型网络传播的延迟，故障的恢复需要大量时间。</p>
<p>作者提出了积极的故障处理办法，尤其是，TE应该在网络中传播流量，以便只要故障总数最多为k（可配置范围），就不会发生拥塞。此保证应适用于任意组合的故障。方法称为前向故障校正（FFC）</p>
<h3 id="2-Method">2. Method?</h3>
<p>FFC</p>
<p>两个挑战：最小化吞吐量损失和计算可伸缩性</p>
<h4 id="FFC-Overview-and-Challenge">FFC Overview and Challenge</h4>
<ol>
<li>
<p>FFC for control plane faults</p>
<p>控制平面FFC保证只要发生配置故障的交换机数量最多为k，就不会发生拥塞。</p>
<p>正常情况下，网络会因为配置失败产生拥塞</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009153846174.png" alt="image-20201009153846174"></p>
<p>讲配置修改为：这样第一个网络可以容忍k=2,第二个网络k=1.</p>
<p>a）的网络缺点是网络吞吐量低于没有故障和FFC时的吞吐量。但是，如果没有流量需求（或网络拓扑）的进一步变化，此吞吐量开销将是暂时的，比如可以在s2和s3配置好之后，将s1到s4的流量提高到10。即使是暂时的吞吐量降低，也是FFC提供的鲁棒性的开销。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009153952523.png" alt="image-20201009153952523"></p>
</li>
<li>
<p>FFC for data plane faults</p>
<p>数据平面FFC保证了多达k条链路或交换机发生故障时，重新缩放后不会发生拥塞。</p>
<p>考虑下面的情况：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009154532269.png" alt="image-20201009154532269"></p>
<p>上图出现链路失败时，重新分配后，会导致网络的拥塞。</p>
<p>但是按照下图的分配方法，任意一条链路失败后，不会发送网络拥塞</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009154541378.png" alt="image-20201009154541378"></p>
<p>缺点：</p>
<p>​	像控制平面FFC一样，数据平面FFC也会降低吞吐量。但是，控制平面的FFC仅在更新网络时承担开销，但数据平面FFC的开销却是持久的。两种情况的区别在于，当链路或交换机发生故障时，网络容量会减少。为了避免发生故障后发生拥塞，我们必须保留备用容量来吸收发生故障的元素所承载的流量。</p>
</li>
<li>
<p>Applying FFC</p>
<p>不同的需要对应不同的网络配置，k的选择，需要进去取舍。</p>
</li>
<li>
<p>Challenges and overview of techniques</p>
<p>第一， The first is the scalability with which robust traffic distributions can be computed.</p>
<p>​				可伸缩性，可用来计算可靠的流量分布。</p>
<p>第二，We must meet the computational challenge while meeting the second challenge of minimizing the loss in network throughput.</p>
<p>​		满足计算挑战，同时还要满足使网络吞吐量损失最小化的第二个挑战。</p>
<p>解决办法：</p>
<ul>
<li>交通量和传播条件作为线性约束条件（公式时精确的，但是又很多限制）</li>
<li>将约束转换为所谓的“bounded M-sum”问题。此类问题中的所有约束都可以减少为对最大（或最小）M个变量的单个约束。</li>
<li>最后，借助排序网络，我们使用有效的线性表达式对这些变量进行编码。</li>
<li>结果是具有O（kn）约束的FFC公式。</li>
</ul>
<p>两个设置：</p>
<ol>
<li>故障的影响易于建模。如果交换机配置失败，它将保留其旧配置；如果链路失败，则入口交换机将确定性地重新调整流量。这种简单性使我们能够使用有效的线性约束来捕获FFC施加的条件。</li>
<li>虽然故障很常见，但故障率（即发生故障的元件比例）很低。因此，足以防止少量故障（k）。解决k的高值将需要大量计算并且会产生高吞吐量开销</li>
</ol>
</li>
</ol>
<h3 id="3-Answer">3. Answer?</h3>
<h4 id="3-1-Basic-FFC-Formulation">3.1 Basic FFC Formulation</h4>
<h5 id="3-1-1-Basic-TE-without-FFC">3.1.1 Basic TE (without FFC)</h5>
<p>​	输入是图G =（V，E），其中V和E是交换机集以及交换机之间的有向链接。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009181529820.png" alt="image-20201009181529820"></p>
<p>​	The TE problem can be solved based on path-constrained multicommodity flow problem ：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201010083835104.png" alt="image-20201010083835104"></p>
<p>等式2表示没有链接应该过载，等式3指出，流在其所有隧道中的分配总和不应小于其分配速率。等式4指出分配给流的速率不应超过需求，并且所有变量均为非负数。</p>
<h5 id="3-1-2-Modeling-control-plane-faults">3.1.2 Modeling control plane faults</h5>
<ol>
<li>
<p>控制面板错误：</p>
<p>FFC的目标是计算新配置$( { b_f},{a_{f,t}} )$以便只要$k_c$或者更少的交换机无法更新他们的旧配置$( { b_f^{‘}},{a_{f,t}^{’}} )$就不会发生拥塞。</p>
<p>令$λ_v=  1$表示至少有一个以v作为入口开关的流配置失败；$ λ_v= 0$表示从v开始的所有流都配置成功。网络中控制平面故障的个别情况可以用表示每个开关状态的向量$λ= [λ_v| v∈V]$表示。因此FFC对于$k_c$个失败是具有鲁棒性的就要求网络在情况合集$Λ_{kc}= {λ|\sum_{v∈V}\ {λ_v}≤ k_c}$下没有过载的链路。可以被捕获为：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163513463.png" alt="123"></p>
<p>$\hat{a}_{v,e} $表示是在没有配置错误的情况下可以从v开始的流到达链路e的总流量也就是：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163648041.png" alt="image-20201011163648041"></p>
<p>S[t,v]表示隧道t的源交换机是否为v。</p>
<p>$\hat{\beta}_{v,e} $表示是发生故障（λv= 1）时链路e中从v开始的流（flow)的流量(trafic)上限。即：</p>
<p><img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201011163706163.png" alt="image-20201011163706163"></p>
<p>$\beta_{f,t}$，当$f$发生故障时，$f$流在隧道t上的流量的上限，由于我们假设速率限制器的更新成功，因此可以将$\beta_{f,t}$建模为：</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163721701.png" alt="1231"></p>
<p>$w’_{f，t}$表示流f在旧配置下隧道t的分配权重（已知）</p>
<p>但是上式约束很多，解决几乎不可能。</p>
<h5 id="3-1-3-Modeling-data-plane-faults">3.1.3 Modeling data plane faults</h5>
<p>​	对于数据平面故障，FFC的目标是计算流量分配，以便即使在最多$k_e$链路失败和最多$k_v$交换机失败后也不会发生拥塞。</p>
<p>需要保证，发生的故障的链路不是连接在发生故障的交换机上。</p>
<p><strong>建模：</strong></p>
<ol>
<li>
<p>$\mu_e=1$代表链路e发送了错误	$\eta_v=1$代表交换机v发送了错误</p>
</li>
<li>
<p>数据平面故障的情况可以表示为${\mu,\eta}$ ，其中向量$\mu=[\mu_e|e \in E],\eta=[\eta_v|v \in V]$.那么对于最多$k_e$链路失败和最多$k_v$交换机失败后也具有鲁棒性的TE要求在下面的硬件条件：$U_{k_e,k_v}= { (\mu,\eta)|\sum_e \mu_e\leq k_e,\sum_v \eta_v \leq k_v }$。</p>
</li>
<li>
<p>数据错误，入口交换机重新调整流量时，它们会改变网络上的流量分布，即将流量从受影响的隧道移到剩余的隧道中。给定故障情况${\mu,\eta}$，我们知道每个流$f$的剩余隧道$T^{\mu, \eta}_f$，这些隧道不穿越任何故障的链路或交换机。FFC要求f的剩余隧道能够保持其分配的速率。即满足：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163919417.png" alt="image-20201011163919417"></p>
<p>这个表明，当流$f$的$T^{\mu, \eta}_f = \phi$时，$b_f=0$</p>
<p>上式保证了没有链路会过载。</p>
<p>LEMMA 1: 满足约束公式2–4,9在故障情况（µ，η）的TE配置$（{a_{f，t}，b_f }）$在所有入口交换机重新缩放后不会导致链路过载。</p>
<p>证明：</p>
<p>当发生数据平面故障情况（µ，η）时，流$f$在剩余隧道$t\in T^{\mu,\eta}_f$上的业务负载为：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011164411420.png" alt="image-20201011164411420"></p>
<p>在链路$e$上的总流量负载为：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011164542058.png" alt="image-20201011164542058"></p>
<p>得证。</p>
<p><strong>Robust tunnel layout</strong></p>
<h5 id="3-1-3-Efficiently-solving-FFC-constraints">3.1.3 Efficiently solving FFC constraints</h5>
<p>为了轻松解决大量FFC约束，我们将它们转换为“有界M-sum”问题，然后使用分类网络对转换后的问题进行编码。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011165405226.png" alt="image-20201011165405226"></p>
<ol>
<li>Transformation to bounded M-sum</li>
<li>Encoding for largest (or smallest) M variables</li>
<li>Throughput and computational overhead</li>
</ol>
<h5 id="3-1-4-Encoding-for-largest-or-smallest-M-variables">3.1.4 Encoding for largest (or smallest) M variables</h5>
</li>
</ol>
<p>最终的结果，效果很明显：</p>
<ol>
<li>ffc的开销可以忽略不记</li>
<li>数据丢失减少了7-300倍</li>
<li>对于不同优先级的网络，可以在保证网络总吞吐量损失忽略不计的情况下，可以保护高优先级流量免受几乎所有损失。</li>
</ol>
<h2 id="Introduction">Introduction</h2>
<h3 id="1-为什么研究这个课题">1.为什么研究这个课题?</h3>
<h3 id="2-目前这个课题研究到了哪个阶段">2.目前这个课题研究到了哪个阶段?</h3>
<h3 id="3-作者的理论基于哪些假设">3.作者的理论基于哪些假设?</h3>
<ol>
<li>
<p>具有TE的网络，假设基于隧道的转发。一个或多个隧道（tunnel）在每个入口-出口交换机对之间传输流量。我们称此流量(traffic)为流量(flow)。在入口交换机上配置的相对权重决定了如何在隧道之间分配流量。</p>
</li>
<li>
<p>Impact of data plane faults</p>
<p>当链路或者交换机失效时，会影响所以通过它的通道，检测到之后，入口交换机会根据配置的权重将流量重新缩放到其余隧道。设一个流有3条权重为（0.5,0.3,0.2）的隧道。当第三条隧道发生故障时，权重（0.5 0.8,0.3 0.8,0）用于拆分流量。</p>
<p>​	举例子：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009124937857.png" alt="image-20201009124937857"></p>
<p>实际网络中的测试：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009130211633.png" alt="image-20201009130211633"></p>
</li>
<li>
<p>Impact of control plane faults</p>
<p>说明在配置交换机的过程的延迟或失败是如何导致拥塞的。</p>
<p>举例说明：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009125758340.png" alt="image-20201009125758340"></p>
<p>实际网络</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009130222759.png" alt="image-20201009130222759"></p>
<p>所以网络的流量控制改变需要按照步骤进行，上图中，步骤为：</p>
<p>​	1）更新s2和s3处的流量分配比率；  2）如果成功，则更新流率s1→s4。这样，如果s2（或s3）更新失败，将不会发生拥塞。但是，配置失败将使网络更新停止，因为在步骤1结束之前，步骤2无法继续进行。它们还会降低吞吐量，因为如果步骤1失败，则流s1→s4无法启动。</p>
</li>
<li>
<p>Slow reaction to faults</p>
</li>
</ol>
<h2 id="Conclusion">Conclusion</h2>
<h3 id="1-文章的缺陷">1.文章的缺陷</h3>
<h3 id="2-关于该课题，作者的构思">2.关于该课题，作者的构思?</h3>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
      </categories>
  </entry>
  <entry>
    <title>PCF: Provably Resilient Flexible Routing</title>
    <url>/yunruowuBlog/2020/09/28/PCF-Provably-Resilient-Flexible-Routing/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Abstract">Abstract</h2>
<h3 id="1-Question">1. Question?</h3>
<p>现有的无拥塞机制（尤其是FFC）所达到的性能远远低于网络的固有能力。</p>
<h3 id="2-Method">2. Method?</h3>
<p>提出PCF,一套新颖的无拥塞机制来弥合这一差距。 PCF通过更好地建模网络结构，并通过谨慎地增强网络响应的灵活性，同时确保可以对故障情况下的性能进行简单建模来实现这些目标。  PCF的所有方案都涉及相对轻量的故障操作，许多方案都可以使用类似于FFC的局部比例路由方案来实现。</p>
<h3 id="3-Answer">3. Answer?</h3>
<p>通过正式的理论结果和对21种Internet拓扑的经验实验来证明PCF的有效性。</p>
<p>PCF的方案可证明优于FFC，并且在实践中，它们在整个拓扑中的吞吐量可以比FFC高出平均1.11倍至1.5倍，而在某些情况下可以提供2.6倍的收益。</p>
<h2 id="Introduction">Introduction</h2>
<h3 id="1-为什么研究这个课题">1.为什么研究这个课题?</h3>
<p>ISP和云提供商的wan经常出现故障，但是网络必须满足日益严格的性能需求。</p>
<p>Many recent works have developed flexible ways of routing traffic motivated by the goal of efficiently utilizing network capacity.</p>
<p>但是这些方案会导致网络在故障时出现拥塞。</p>
<h3 id="2-目前这个课题研究到了哪个阶段">2.目前这个课题研究到了哪个阶段?</h3>
<p>现在大家都研究设计流量工程机制（traffic engineering mechanisms），以在典型的故障情况下主动确保网络无拥塞（即，确保没有链路承载的流量超过其容量）</p>
<p>最具有代表性，最先进的技术：FFC,将带宽分配给流，以便在f或更少的链路发生故障时不会发生拥塞。为此，FFC沿着一组预先指定的隧道将流量从每个入口分流到出口。</p>
<h3 id="3-作者的理论基于哪些假设">3.作者的理论基于哪些假设?</h3>
<p>FFC</p>
<h3 id="4-作者的工作">4.作者的工作</h3>
<p>证明了FFC的性能和不足</p>
<p>提出了PCF(Provably Congestion-free and resilient Flexible routing)，一个全新的可以确保网络在出现故障时无拥塞的们同时性能接近网络的固有能力。PCF通过更好地建模网络结构并采用更灵活的响应策略来实现这些目标。PCF解决的关键挑战是如何增强网络响应的灵活性，同时确保可以对故障情况下的性能进行精确建模。</p>
<p>开发了作为PCF一部分的多种机制，使架构师可以在可实现的性能保证与部署复杂性之间进行权衡。</p>
<p>首先，提出了一种使用了FFC响应机制的带宽分配的替代方法，该方法</p>
<p>​	<strong>（i）可以提供更好的性能保证；</strong></p>
<p>​	<strong>（ii）确保分配不会因其他隧道而降低。</strong></p>
<p>其次，提出<strong>了LS(logical sequence )</strong>，基于LS探索了更灵活的网络响应。</p>
<h2 id="Conclusion">Conclusion</h2>
<h3 id="1-文章的缺陷">1.文章的缺陷</h3>
<h3 id="2-关于该课题，作者的构思">2.关于该课题，作者的构思?</h3>
<p>tunnel-based routing</p>
<p>导入</p>
<p>目标</p>
<p>前测</p>
<p>互动</p>
<p>后测</p>
<p>总结</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>congestion</tag>
      </tags>
  </entry>
  <entry>
    <title>Tales of the Tail-Hardware, OS, and Application-level Sources of Tail Latency</title>
    <url>/yunruowuBlog/2020/09/06/Tales-of-the-Tail-Hardware-OS-and-Application-level-Sources-of-Tail-Latency/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Abstract">Abstract</h2>
<h3 id="1-Question">1. Question?</h3>
<h3 id="2-Method">2. Method?</h3>
<h3 id="3-Answer">3. Answer?</h3>
<h2 id="Introduction">Introduction</h2>
<h3 id="1-为什么研究这个课题">1.为什么研究这个课题?</h3>
<h3 id="2-目前这个课题研究到了哪个阶段">2.目前这个课题研究到了哪个阶段?</h3>
<h3 id="3-作者的理论基于哪些假设">3.作者的理论基于哪些假设?</h3>
<h2 id="Conclusion">Conclusion</h2>
<h3 id="1-文章的缺陷">1.文章的缺陷</h3>
<h3 id="2-关于该课题，作者的构思">2.关于该课题，作者的构思?</h3>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>tail</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-12</title>
    <url>/yunruowuBlog/2020/09/03/LeetCode-12/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="消除游戏"><a href="https://leetcode-cn.com/problems/elimination-game/">消除游戏</a></h2>
<p>题目描述：给定一个从1 到 n 排序的整数列表。<br>
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。<br>
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。<br>
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。<br>
返回长度为 n 的列表中，最后剩下的数字。</p>
<h2 id="想法">想法</h2>
<p>感觉不是很困难，然后就想着尝试解一下，然后发现自己又不会写代码了。感觉思路好乱，根本把握不住问题的根本，只能想着简单的例子来凑代码，比较难受。</p>
<p>最终的解答还是很容易的，但是要利用数学来求解，自己没有忘这边考虑，走了很差的路子。</p>
<h2 id="解答">解答</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n==<span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>*(n/<span class="number">2</span>+<span class="number">1</span>-<span class="built_in">lastRemaining</span>(n/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证明：	<a href="https://blog.csdn.net/afei__/article/details/83689502">证明方法</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Evaluation of an InfiniBand Switch:Choose Latency or Bandwidth, but Not Both</title>
    <url>/yunruowuBlog/2020/08/28/Evaluation-of-an-InfiniBand-Switch-Choose-Latency-or-Bandwidth-but-Not-Both/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="RDMA-背景知识">RDMA 背景知识</h2>
<h3 id="A-RDMA-verbs">A. RDMA verbs</h3>
<p>verbs决定了通信操作的类型。RDMA的verbs可以分成两类，双边<strong>two-sided(SEND, RECV)<strong>的和单边的</strong>one-sided(READ, WRITE)</strong>。two的涉及到两个通信端点，这种情况下，远程主机需要提前发布（pre-post）RECV,本地主机需要发布SEND。one-part仅仅涉及一个通信端点（源）。使用WRITE可以直接在远程主机写入数据，使用READ直接从远程主机内存直接读取数据，并且不需要通知远程主机。</p>
<p>RDMA的动词遵循异步I/O模型。数据传输是非阻塞的，因此允许程序在发布的请求完成之前继续执行。通过向完成队列发送CQE信号，告知完成；应用程序轮询队列接收CQE确定完成。</p>
<h3 id="B-RDMA-transport">B. RDMA transport</h3>
<p>RDMA提供了不可靠（UD）和可靠（RC）传输类型。  UD传输不保证请求的交付。此外，UD仅提供双面动词。对于RC传输，RNIC使用确认（ACK）来保证请求的传递。此外，RC传输支持单侧和双侧动词。</p>
<h3 id="C-RDMA-execution-path">C. RDMA execution path</h3>
<p>根据动词和传输类型的选择，RDMA事务遵循通信主机之间特定的交互序列。不论什么事务，每次事务开始时，host通过PCIe的MMIO事务向本地RNIC发送请求，RNIC根据请求中的动词类型，决定处理请求的办法：<br>
如下图：</p>
<p><strong>RDMA operations execution sequence：</strong></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201026101151798.png" alt="image-20201026101151798"></p>
<ul>
<li>READ： 本地RNIC通过网络结构发送请求。远程RNIC通过从主机的内存层次结构读取的DMA服务请求，并将数据发送回本地RNIC。接收到数据后，本地RNIC发出DMA写操作以将数据存储在本地内存中。之后，本地RNIC执行另一次DMA写操作以发出CQE。</li>
<li>WRITE：首先，本地RNIC通过DMA读取获取有效负载。接下来，通过网络结构发送请求。远程RNIC 执行一个DMA写的操作将数据存储在主机的内存中，然后发送一个ACK.</li>
</ul>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201026102358284.png" alt="image-20201026102358284"></p>
<ul>
<li>SEND：首先，本地RNIC通过DMA读取获取有效负载。然后，该请求通过网络结构发送。远程RNIC收到请求后，会发回ACK（如果使用RC传输），并通过DMA写入将有效负载写入其主机的内存中。根据SEND请求使用的RDMA传输方式的不同，本地RNIC会在网络（fabric）发送请求后立即发出CQE（UD，图c），或者一旦从远程RNIC接收到ACK（RC，图d），则发出 。</li>
</ul>
<h2 id="IB">IB</h2>
<h3 id="I-InfiniBand-QoS-support">I. InfiniBand QoS support</h3>
<p>为了提供按流的性能差异，IB提供了一组优先级，称为服务级（SL），可以将其分配给流。IB使用SL的抽象来隐藏其两个有助于实现QoS的体系结构组件:</p>
<ol>
<li>Virtual Lane (VL):</li>
<li>Virtual Lane Arbitration (VLArb):</li>
</ol>
<h3 id="II-IB-SWITCH-LATENCY-MEASUREMENT">II. IB SWITCH LATENCY MEASUREMENT</h3>
<p>IB网络可以达到10微秒内的延迟，导致测量需要很准确，但是如此低的延迟为准确的NIC至NIC延迟测量提出了一些挑战。主要挑战是将交换机的延迟与其他组件（尤其是软件和PCIe）隔离开。</p>
<p>解决办法：</p>
<ol>
<li>
<p>理想的：直接通过交换机测量单向端口到端口的延迟。</p>
<p><strong>代价</strong>：需要使用昂贵的数据采集设备</p>
</li>
<li>
<p>另一种：端点上使用精确的亚微秒时钟同步。</p>
<p>**不足和假设：**基于两个方向上的单向等待时间相同的假设，在拥塞情况下，尤其是在聚合交通模式下，情况并非如此。</p>
</li>
<li>
<p>ping-pong style test: 获得软件中的往返时间（round-trip time:RTT）</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201026195810000.png" alt="image-20201026195810000"></p>
<p>问题：</p>
<ol>
<li>远程：远程端处理的偏差，而且是生成和传输ack所必须的，远程侧处理包括用于生成响应的软件开销以及用于向RNIC传输数据或从RNIC传输数据所需的PCIe事务。但是不会影响真正的网络延迟，所以需要排除在测量中。</li>
<li>本地：本地处理延迟，软件捕获到的是请求的发送时间而不是传输时间（transmiting time）。所以会造成测量偏差。</li>
</ol>
<p>相关工作：</p>
<ol>
<li>RDMA Bench</li>
<li>Perftest</li>
<li>QPerf</li>
</ol>
</li>
</ol>
<h3 id="RPERF">RPERF</h3>
<p>​		细节：RPerf测量本地主机和远程主机之间的RTT，并利用RDMA谓词来准确地测量延迟，而不包括端点延迟。接下来，我们描述RPerf设计的关键方面。</p>
<ol>
<li>
<p>Excluding remote-side processing：post-poll方法</p>
<ul>
<li>利用RC传输，远程RNIC在其中生成响应而不涉及目标主机，RPerf避免了远程端的软件处理开销。</li>
<li>使用SEND verb ，排除远端PCIe的延迟，SEND使远程RNIC在收到请求后立即生成对源RNIC的响应，而无需等待PCIe事务在远程端完成。</li>
</ul>
</li>
<li>
<p>Excluding local-side processing：</p>
<ul>
<li>local-side processing overhead：actions at the local host and the RNIC</li>
<li>解决：发送lookback message，通过本地RNIC从主机发送到自身的消息（over-<br>
the-wire SEND）</li>
</ul>
</li>
<li>
<p>RTT calculation:同时发送两个消息，一个是over-the-write，一个是lookback message。</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200829090835329.png" alt="image-20200829090835329"></p>
<p>$$<br>
RTT = (T_W-T_P)-(T_L-T_P)=T_w-T_L<br>
$$</p>
<p>额外的技巧：为了最小化由软件引起的性能差异，每个RPerf线程都固定到CPU内核，并且为所有必需的缓冲区分配了巨大的页面。为了准确捕获事件的时间戳，RPerf通过rdtsc  x86汇编指令使用时间戳计数器，该指令在用户空间内提供高精度的时间戳测量。 RPerf遵循英特尔关于TSC校准和访问的建议。  RPerf的多个实例可以在不同的服务器上运行，并且用户可以指定流量模式（例如，一对一或多对一）来测量系统的特定方面，例如零负载延迟，峰值带宽或负载延迟。</p>
<h2 id="实验">实验</h2>
<h3 id="实验设置">实验设置</h3>
<ol>
<li>Hardware testbed</li>
<li>Simulator</li>
<li>Traffic pattern</li>
<li>Metrics</li>
</ol>
<h3 id="性能表现">性能表现</h3>
<h4 id="ONE-TO-ONE-TRAFFIC">ONE-TO-ONE TRAFFIC</h4>
<p>对照组：有无switch， Perftest and Qperf.</p>
<h5 id="A-Latency-and-bandwidth-without-the-switch-AND-B-Latency-and-bandwidth-with-the-switch">A. Latency and bandwidth without the switch AND  B. Latency and bandwidth with the switch</h5>
<ol>
<li>RTT</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028203924233.png" alt="image-20201028203924233"></p>
<ol start="2">
<li>Bandwith</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204009514.png" alt="image-20201028204009514"></p>
<h5 id="C-Latency-calculation-by-existing-tools">C. Latency calculation by existing tools</h5>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204412779.png" alt="image-20201028204412779"></p>
<h4 id="融合流量下的表现">融合流量下的表现</h4>
<p>在这种设置中，数量众多的BSG（从1到5）将带宽密集的流以4096B有效负载的大小发送到一台目标服务器，从而形成一种融合的流量模式。同时，LSG将对延迟敏感的流发送到同一目标服务器。</p>
<h5 id="Latency-of-LSG">Latency of LSG:</h5>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204658627.png" alt="image-20201028204658627"></p>
<h5 id="Bandwidth-of-BSGs">Bandwidth of BSGs:</h5>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204706756.png" alt="image-20201028204706756"></p>
<h4 id="尝试保护延迟敏感的流程">尝试保护延迟敏感的流程</h4>
<h5 id="A-BSGs-with-different-message-sizes">A. BSGs with different message sizes</h5>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205112105.png" alt="image-20201028205112105"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205133251.png" alt="image-20201028205133251"></p>
<h5 id="B-Packet-scheduling-policy-at-the-switch">B. Packet scheduling policy at the switch</h5>
<ol>
<li>
<p>FCFS policy:</p>
</li>
<li>
<p>Round-Robin policy:使用RR策略，仲裁器可以在每个回合中选择一个端口，并在该端口的开头选择数据包。在这种情况下，每当LSG数据包到达时，它最多等待活动端口的数量。</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205219090.png" alt="image-20201028205219090"></p>
<ol start="3">
<li>
<p>Packet scheduling policies in a multi-hop topology</p>
<p>我们将模拟设置扩展到两跳拓扑，其中一对交换机连接在一起。两个BSG和一个LSG连接到上游交换机，三个BSG连接到下游交换机。目标服务器也连接到下游交换机。所有BSG都将4096B消息发送到目标服务器。</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205655531.png" alt="image-20201028205655531"></p>
<h5 id="C-InfiniBand-QoS">C. InfiniBand QoS</h5>
<p>使用专有的SL</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028210109093.png" alt="image-20201028210109093"></p>
<p>区分流类型并为每种流类型分配优先级可以有效地保护对延迟敏感的流。</p>
<h6 id="Gaming-the-dedicated-SL-VL-setup">Gaming the dedicated SL/VL setup:</h6>
<p>带宽密集的流假装成短消息</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>IB</category>
      </categories>
      <tags>
        <tag>IB</tag>
      </tags>
  </entry>
  <entry>
    <title>学习MakeFile</title>
    <url>/yunruowuBlog/2020/08/21/%E5%AD%A6%E4%B9%A0MakeFile/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="一、Why">一、Why?</h2>
<p>​		最近在学习oMnet++，经常需要用到一些工程，里面有很多Makefile文件，经常会出现报错，尤其是在安装软件的时候，经常遇到，平时遇到的可能都是利用工具自动生成的，问题比较少。</p>
<p><a href="https://blog.csdn.net/weixin_38391755/article/details/80380786">先放链接</a></p>
<p><a href="https://www.w3cschool.cn/mexvtg/adisqozt.html">w3school的教程</a></p>
<h2 id="二、-程序的编译和链接">二、 程序的编译和链接</h2>
<p>​		一般来说，无论是C、C++、还是pas，首先要把源文件编译成<em><strong>中间代码文件</strong></em>，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做<em><strong>编译（compile）</strong></em>。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p>
<p>​	<strong>编译时</strong>，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。<br>
​    <strong>链接时</strong>，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“<em><strong>*库文件”（Library File)*</strong></em>，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）。</p>
<h3 id="Make">Make</h3>
<p>Make命令直接用了这个意思，就是要做出某个文件。make是根据makefile中的规则来构建文件的。</p>
<h3 id="Makefile文件的格式">Makefile文件的格式</h3>
<ol>
<li>
<p>文件格式：</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>上面第一行冒号前面的部分，叫做&quot;目标&quot;（target），冒号后面的部分叫做&quot;前置条件&quot;（prerequisites）；第二行必须由一个tab键起首，后面跟着&quot;命令&quot;（commands）。</p>
<p>&quot;目标&quot;是必需的，不可省略；&quot;前置条件&quot;和&quot;命令&quot;都是可选的，但是两者之中必须至少存在一个。</p>
<p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p>
</li>
<li>
<p>目标（target)</p>
<p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p>
<ol>
<li>
<p>伪目标</p>
<p>除了文件名，目标还可以是某个操作的名字，这称为&quot;伪目标&quot;（phony target）。</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">      rm *.o</span><br></pre></td></tr></table></figure>
<p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于&quot;伪目标 &quot;，作用是删除对象文件。</p>
<p>但是如果目录里存在了clean文件，那么make会认为文件已经存在，没有必要重新构建了，就不会执行指定的rm命令。</p>
<p>解决办法，指明为目标：</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标</p>
</li>
<li>
<p>前置条件(prerequisites)</p>
<p>前置条件通常是一组文件名，之间用空格分隔。它指定了&quot;目标&quot;是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），&quot;目标&quot;就需要重新构建。</p>
</li>
<li>
<p>命令（commands）</p>
<p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建&quot;目标&quot;的具体指令，它的运行结果通常就是生成目标文件。</p>
<p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure>
<p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p>
<p>每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>
<p>如果需要在一起使用:</p>
<p>​	一个解决办法是将两行命令写在一行，中间用分号分隔。</p>
<p>​	另一个解决办法是在换行符前加反斜杠转义。</p>
<p>​	最后一个方法是文件头部加上<code>.ONESHELL:</code>命令。</p>
</li>
</ol>
<h2 id="三、-Makefile的语法">三、 Makefile的语法</h2>
<h3 id="3-1注释">3.1注释</h3>
<p>​		井号（#）在Makefile中表示注释。可以单独一行,或者在行尾.</p>
<h3 id="3-2-回声（echoing）">3.2 回声（echoing）</h3>
<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>
<p>在命令的前面加上@，就可以关闭回声.</p>
<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p>
<h3 id="3-3-通配符">3.3 通配符</h3>
<p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（<em>）、问号（？）和 […] 。比如，</em> .o 表示所有后缀名为o的文件。</p>
<h3 id="3-4-模式匹配">3.4 模式匹配</h3>
<p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br></pre></td></tr></table></figure>
<p>等同于下面的写法。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">f1.o: f1.c</span></span><br><span class="line"><span class="section">f2.o: f2.c</span></span><br></pre></td></tr></table></figure>
<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p>
<h3 id="3-5-变量和赋值符">3.5 变量和赋值符</h3>
<p>Makefile 允许使用等号自定义变量。</p>
<p>调用时，变量需要放在 $( ) 之中</p>
<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p>
<p>有时，变量的值可能指向另一个变量。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">v1 = <span class="variable">$(v2)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p>
<p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-内置变量（Implicit-Variables）">3.6 内置变量（Implicit Variables）</h3>
<p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，</p>
<p>$(MAKE) 指向当前使用的Make工具。</p>
<h3 id="3-7-自动变量（Automatic-Variables）">3.7 自动变量（Automatic Variables）</h3>
<p>Make命令还提供一些自动变量，它们的值与当前规则有关</p>
<ol>
<li>
<p><strong>$@</strong></p>
<p>$@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的</p>
<p>$@ 就指代foo。</p>
</li>
<li>
<p><strong>$&lt;</strong></p>
<p>指代指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。</p>
</li>
<li>
<p><strong>$?</strong></p>
<p>指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p>
</li>
<li>
<p><strong>$^</strong></p>
<p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么</p>
<p>$^ 就指代 p1 p2 。</p>
</li>
<li>
<p>$*</p>
<p>$ *指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，</p>
<p>$* 就表示 f1。</p>
</li>
<li>
<p><strong>$(@D) 和</strong></p>
<p>** $(@F)**</p>
<p>$(@D) 和</p>
<p>$(@F) 分别指向</p>
<p>$@ 的目录名和文件名。</p>
<p>比如，$@是 src/input.c，</p>
<p>那么$(@D) 的值为 src ，</p>
<p>$(@F) 的值为 input.c。</p>
</li>
</ol>
<h3 id="3-8-判断和循环">3.8 判断和循环</h3>
<p>Makefile使用 Bash 语法，完成判断和循环。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">  libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(LIST)</span>; do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">     done</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in one two three; do \</span><br><span class="line">        echo $i; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>
<p>上面代码的运行结果。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>
<h3 id="3-9-函数">3.9 函数</h3>
<p>Makefile 还可以使用函数，格式如下。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$&#123;function arguments&#125;</span><br></pre></td></tr></table></figure>
<p>Makefile提供了许多<a href="http://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>，可供调用。下面是几个常用的内置函数。</p>
<p><strong>（1）shell 函数</strong></p>
<p>shell 函数用来执行 shell 命令</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcfiles := <span class="variable">$(<span class="built_in">shell</span> echo src/&#123;00..99&#125;.txt)</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）wildcard 函数</strong></p>
<p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcfiles := <span class="variable">$(<span class="built_in">wildcard</span> src/*.txt)</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）subst 函数</strong></p>
<p>subst 函数用来文本替换，格式如下。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> from,to,text)</span></span><br></pre></td></tr></table></figure>
<p>下面的例子将字符串&quot;feet on the street&quot;替换成&quot;fEEt on the strEEt&quot;。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure>
<p>下面是一个稍微复杂的例子。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># bar is now `a,b,c&#x27;.</span></span><br></pre></td></tr></table></figure>
<p><strong>（4）patsubst函数</strong></p>
<p>patsubst 函数用于模式匹配的替换，格式如下。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br></pre></td></tr></table></figure>
<p>下面的例子将文件名&quot;x.c.c bar.c&quot;，替换成&quot;x.c.o bar.o&quot;。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>
<p><strong>（5）替换后缀名</strong></p>
<p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">min: $(OUTPUT:.js=.min.js)</span></span><br></pre></td></tr></table></figure>
<p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>送别歌</title>
    <url>/yunruowuBlog/2020/08/20/%E9%80%81%E5%88%AB%E6%AD%8C/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><span id="more"></span>
<div align = center>
    <h2>送别歌 
    </h2>
	<div>
    李叔同
    </div>
    <div>
        长亭外，古道边，芳草碧连天。</div><div>
    </div>晚风拂柳笛声残，夕阳山外山。<div>
    </div>天之涯，地之角，知交半零落。<div>
    	一壶浊酒尽馀欢，今宵别梦寒。
    </div>  
<div>
    长亭外，古道边，芳草碧连天。
    </div>
<div>
    晚风拂柳笛声残，夕阳山外山。
    </div>
<div>
    情千缕，酒一杯，声声离笛催。
    </div>
<div>
    </div>
问君此去几时来，来时莫徘徊。<div>
    </div>
草碧色，水绿波，南浦伤如何？<div>    
    </div>
人生难得是欢聚，惟有别离多。<div>    
    </div>
情千缕，酒一杯，声声离笛催。<div>    
    </div>
问君此去几时来，来时莫徘徊.
    </div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=26090155&auto=0&height=66"></iframe>
]]></content>
      <categories>
        <category>诗</category>
      </categories>
      <tags>
        <tag>歌</tag>
        <tag>李叔同</tag>
      </tags>
  </entry>
  <entry>
    <title>8.14计算机年会</title>
    <url>/yunruowuBlog/2020/08/14/8-14%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B9%B4%E4%BC%9A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f54187751dcc408599647e4ba712beaaa8fcaf293ec387f97090521cfcccf341">165d50f05814027fb7fe5e4ae8a088d86787c748b405550d35a33d270865828af0e723dde51bc85b7a01fcf562f051f99ace83b56e471196fc2ce027ed35af0d7f6b416deab04ce8deff2de8bd5aecde5004d6fb92ec4631d18a24dcfab2bdd6ac2fbc37a171b1eedb2144adac16eb97672ae6710a122b699fa24f158530a50baf0e2716d763ccae4e5b24c96625d518d62cc11caab47cb6af86b473c9bf9c7ba8919fec4ea1b81e25a7eb9ef34fd5803271c36358241f12184126bb8afab751aa107b00d3fa2dc7621a0e9938c1d99d37222199086712aedcdea99f7e8981e939e3ece2b41c9f08104f6cb8cae842d217de10bf2e3397b280bb0974f847c9ffeafde4ac242ac0b9ac3c5ed109186f2b8cb752ade219cb4d5a3e572ae9560a0ba94d5bfa051ec34d73c1d23d533c4f246ec974e497e9b657f32b129abeb5eeacaf37096b15a21cd149f68a0f56bc9773b0e3bb81f423f0115daad4e9d16cf9bd37b9eabe15016adbb80417d92f3f07cf2a697d0a59c564e48136ec7003f34fba3970fd97471bf0ee4837a8e27a6d2e292b25c8facdb6297bdd487899189207c31e9ece42bdd397a161473e8a2d56bea7a30424f0c9e830d7e85e33983c3f00afa9bb7e95b09d6bb6f4b3f8fd6db386b2bbdcebbcad731f62b51e31cc9c4beeee342e4c0229c199068db645042d71fe600a867181e3a5f305bdd465b634bd1a192356e449172a70d07d34981d0cc43a41cf36f49a7ace26a98422288a278bd83572b45ec6815ea4ab7bf88b02519ea9f25afbe0139ee69d2ae2ae320cba35ffb0d3bb23c1d5454986386b2879f0bac0ed8565cf571232d9bce51ab2f152bd919bc6352bb3f8ed6f0c0120f34b776d3678ec39ac02dca5caf927f6940ce65545c9fb420b753b0f223312641077ceae21c723cb289f342cf5c85a70b223251709f274824317917f825ed24406eebb85813e253f24e54403efd4cca192afd937023e006c31426fabd389c5c6b869295ffe552be18ebdf5467ca167c8f583f9091d7d492ef35e5cc5a61f6503092dc3847918155e83f128b9fd13f1c44efe8621ae5a951599f6cf212f5c7d5888e5086504a2978baeba1150676f1895cc007e7ab7b6b72a45e974aaa3898730f9f32f45efdb761e572a0e535d6e94b03f46929ff3734af8b9f9045d0aa4c8195072d8e50d9263b08adf86a9941c68cd77154a1b4701db22c8c4010641318177c9813677996ea66134d0451dfb93566c13761832224ba74a9f0026ee3612179edaf723dcc1fc9eff1884b76c0df98e119100f503375bd103f210b3151e2ec1cbab060d4018dc0a1a4bbef7624573059479f117396a8777f8f545b9773cd422526d8d7df60ba1e02530a9fa29201b4a1129b30b878ba1263c0b1b0379295054eafa55d12b16cfb34fd33b5d9b627f47e936a8f7598fa92c8fc54fa8aa4653b0589752ae28a80e54c220803d70607b32f1a146f138397f0f49d9936aa8df531bb1b58397aa8f521816f164e699269ff5383662af02fed02e341292c4bc536a77542d8961f954d7e5965929f0528cfbdc4439a99aaf0805fd66542e1468c82860e4a35a2758e0179334e4f38dc6e3bae88e17e47493111f5ea7f4ba9ab8559e2418585b26f13d4738b8878bfc07a5ad103b8df47b96371679df9f86135990bd16805858975c40748df04988063a4d9732f06710fedf4a14dd7254532d0c508c95e7507b9bbefc0a3feb7f7540958827a8923212ef4093c0bbdb3ce164838f99c8f1fcc707d324271cdc3f8662ea4de609b53bfc0ba5849c1a85f26663915048c11883cfb7966d3c43a4247e0a92b55cec3cadc56fa0ce9b61c8aad10ab2677bb81e5fdc99dbb489eaa2f86c796792f00ac823ca4cbd2e323e281ef60b3c4d14cd84ccbe89f5274bac7b4aff972d2fe7e024541d3a147d171249eab59f6400c8cfaf2e4a395f9d1601c2fafcaf7e080cad944a180d31e7ef40ca09e7d22d0f17d9db67de6a30d1d7e8157055f7838619c4c3b94ac8791eef8c4d42b5f4cbaedbf2d7663f12ab67f2c9038da3410f8217b675f012918eecc983fedc43eb7ad4ea4b5335dafd9355ef82e2d7e7b4d1dcc27b0df515500eefb4b549f81301abc6461a9c2e776d7969fa610274ce1dd64329d383ee22d2f21166cd6096acf8c0e79b0cf16e54d15b11f1ff3b400d261c845f4400e1a01c4455e332b6fb86bc32bb62c96a608dea78994274ffa790088b7c33ac7fd2f2c5612a2fa89e721a44943ed0131c46ce92196d6a7ccb754d53069ebf21e6b5806a396571acc2de63ffd993b7dcdf911202b81d33bf4abe5e01278723956cce077ad3a8f8fee09eb614321533c90f65797060721ab96ce89a71c883abcbf033d825a3564f41511b445a4f47b1d54ee5ddcaee03bb1e330d458bd5166ccea4f76bc8c087c3d473e9348559f7e486a8d18df4aaf74918ce87cc64e43ea724dfad2ddfcd6428e6b784c38ce63f87bf7903a9ca76fa7aa11f715612feed984ba3cf7738ffaf551c962d58f0a428531b87468d5a6e77a6b9b8d31b08341f35ae0fdac9ec8932737a916998da676206174774ba2cf045db658372df195fd71c456d24771497e1766df3c0a4b531a346dd911c3d129ce273177e90e10e3c01551172ca63a11acab5eb117bd1ae8826cd12415967684b5a72eecc4620d272470e20ef8634f0f34505916e345ac1d66c83736fee0c9e99f3ea163f4fc9d4fc04e87d5389d45d333bd66408c1a6303c5c37c302c71ee4de9abc37d908cb4a8ee26ac519c691d9bb49c79f8c545dfb51c0ca50efe7df00dd72673c406be01de8fb6ed28ec7e64cd6e05c8c40587f893b5ef47ccd26c394f8901668aa2ff11d7152fa2c58a79aba10ebc23c23dabcf7972c8b33514029f6b66fcc8e9fa4dc09c15d1cf20b543b3e3523e42fc7d5b26eaafa68ac170d131d032e01a371fa7f5f9b594cb6d98ba7c39a4afecfb1fd13331e3d8eaa238a22da61a05686898e3e191d412ce49cbd76b7ad9a0c5eddb47b92a2e34a2960c403facad7f83297ccf74e06994ff8224a327cb89a75ee65f4d982ae49b9dc97e0cfda2d51b9a54545ad78afa772b3dd7006a8e9c94d61946408e523abbcd004c78ca5b8c8bee5d8a0d5df4ad18b396fd4673b5b0d71c4d694f3a69ea3a7c1d8d1b947f5ffbd28ef56e8fcc3ea7564a93c5417ea570b28dfa9c7cc0cfcb58503c6607a2c382dfee52220985329cf197cb3b9272f3794dfea1e9fa740c588c2d448f6f75f3527aba97414a39cab9481e93efdb2386624814e619c27a74d0d677d76b41195f28a385ec19c46f03ed21fce1602fb8136a20a36abf26c0314d2931e895276656ab99d6f8c6c8c9288116e23adabf66d3db2180f1c3bbbc15dabe41e6df0472ae615976c9562791453ab2f73bb5011e49d774bdb8a21c16d1a826884fc4328917131784b25362fbcbae77dd736b63cd2785d247fdad45d1f6fbc6ebcd20bece19d8cc23d348c3ad3e53db4714a147d8197840c39bf54c0fd3cb954e87568127e58cb9db643fc1d5bdae806e2310b55777e0b5db5bd4a8d9c9eff183c8b7bbf7be9724e7839eb9fe80ad9ce8bafa2a9f31333ff7c6b4aa2af1b3356bddd849c076f0665cd161eda5eb5f644931c3bde1c470f217d3333e3fa07f4f84f05c4a106e3b705dcc9e74165cc3bdc5ba678671a0f2244c08e112adf3e9929525805c604a629232392d76cfb80fb358a4c562372db752ac373efc748a88dcf09c32cda3dfd2284f0ea0678664c8ea4509dbf4aee310c522d53c83ad3877a2c591112b2b23d8aae18bdb272d4f01320f00283e1226f326c3f0178d0dd9b905dcf9f246cad67e59b15c5ec83687e7189525eda6b1b3abab2551e5023eab356ef04265a7103a25b1467495262b3ebfd4142bd5c431ec49c8a405d3cd443e756ca9f8fde0d08c55eeb76a49dc592f713d3addfb994a99c1fe3822251830e6ffcadbc2e8beb80a64339e13da7630f2c460a8e6141d212739ab4e5a41d13f613aa44f4b0f09c0ccd8edb353147d57f3506e44a9f11431f12619f6ab38c39cb59a757a4d961728aaf68be0900f77e97d6c7d806e207dc1b50a51293f4ac8067239d9a3da7e1b4d5bfdc5a79782e623e5e734b4973a32eefeaca66fdc243011b51c3844f1d43aff20d258d818f261048c76e6027114a7026dbc251b3cd37c449fbef8667b377f6ea17202c8af03b9686f3bbf81237a35cc9cc69008abb9f45241a04ffd1cac86a2402b24ab4f0bdf9734c055f3eeec2fe1e406cd0adb17146aa7043a38c55cbfbb209edfdc191d1bb98ad52902c92ccfa4bcdb39a9f961774ef8395e0a8e851270d46561a12248753479dc36b674baaf2c2b37f139613ceeea0399130eacb3ef74d73a721c6008bd279902bf515b79eb99361d5b4fb0b2f41ada97154d5217453297f7264a97773e2d5ec92b0df8c0e9b324d1663394e87ed9cc85235e29fad9a64313f2d69de8986cbb586e5414dce6e153ca5cffbcdb67903ccbbe57b814162a27698e196fdd7a170f6ed11c9ce2f72b8c4fb5b387eaae13539d029f00d94594948c02c615232357e4b167bcd1f0ef681b8acdb26422c806a330589297b4dcfb23b43fbaa3ea99e55079b8b7bdcd0970abb63</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>一次计算机体系结构会议</title>
    <url>/yunruowuBlog/2020/08/13/%E4%B8%80%E6%AC%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8670d500437026c6fdb3a49935c44bab6a8f9fa768034b88adbe8a4e112a01bc">bee165724e9d24650c72d2b35b712e0a09c7fad0164dae025b06bf97463afdc42ff0032c2b9488585170d4d5b99b396dd12d2169e3967068eee961af20ed7ba37b8fae722b0957d1be24ac865e063d6bb5ea4a2e9c8b18e33da142dfc39591b5478649330c3fcb54c5ea2f9ee0e270012b4b1becb06cc477b73293e1d9650abf8f263654de108820c50266bd78c92a3ceccb42250bb9c59ed2a65e0d156c8778d03d840c07ee41534a11c72ad2ffb864b412d62e797ff011e2651fe37bbaabba0a7cee9d52d5c5a593d59d9917503be30a355f02a09fbcf39934dd227f7e3b267120e7caaeb3273911233838e94b99d1f0cb8465bc052d2a0104e0bff51b43ebe854c98bd8441a539f29e7bef584a3150bbd4dc935f52620a128c5cd2dcb2ac7ed8202bad46c362dde65aac59c4ac7f9529c6f6d021a6985797c784d4b19f45f6eab4a16e5b7d20ea706341ae722e1d3bcba94a1972e9cb731b405835c9911ed3082e87d16ea1640b89652124e56b57636dda83d12d9628b873f0751814774e667ead496a982f69e68de851587e471382f5f65ed9ff3b9b7538ffba10f643dcb2d2c03cf155a3489a5abfe26b71b2a66a9def5c0b3003ab0cdc1a2329c6dbafc7c2a617200ef1fa67b25b8a456c66456998d14994d6d84ee160b7978c0c4ad16bb006288a3df3fa08ab3b8391b4d8844040a79231d45ac64c398c7fcd24698d5dd7280794c2ce5a0253b1bda343865390254d2b27ed5291168adae1c363f60fea4dcab2b8ce53559d370be9ccb3a37a9457584eb95002444a33d0af13a915ff0978e6d1c2a007cb56d04cd88d21142696094e78fa826ac22209ac1dfabc2fa19266485724d7a6b0bd3c82b3f957edb1db88b0890d564f69d0c51223148e133e68ca520a7bf54c99688e74ec94288d9cf0da90901e31bbccd5cb5d291e5885a1cf4c09fde9373fbb186b2d5efcfd2a1d9555e4acf8098535bdde0b54022e5afe358ae696ddeea2583f4f5ffbfc718c147968e32204304a0470ff3bc301dfd106e07df8b4044a9fcbd5ac64114829dd8ac57994189003946e728f66e2a40335f93ff72c56d311004fc6ef9d250bd5204d158985274611f96d382fb94ed49d51f74ef74974cff03191185071e925b538b150d128981f3aca30ef0bce378d22891978733b7a61bf34980369a73e8815ca8ff93e41a44c36a29bc246430d2d5e9c178f82f563b651ed2725f5afa887f327e7e4313f6375e32b7ec242d1b28d8aa88a26fb6e4db9ac273cc2d87900fa6cbea3e622296a70eb113e65d9be5fbd7a974ffa26a91155ad5b639aa6131c8df30ff243181d03133868727abff3be51f94e184ce38dc44df9dd798f9881a319559d798c60e8534c3452832bc5e2e99cc3168ccb74053ea20114cd433d93325d97b926649da84bfd5d918f5aec13683009d850b54e3b1ad2aab535b6938a2f4992185954b8ac43f24b4ede294f01abf256b5f8aa83e1cca211a7ece4aa253ba557c384b2441b4bf94902b929e2341bf635e8754b7871da35a0250741331ab907a38eaa415e085f37a8fa8350f7a4af3f0a5eb6d780d1191030b5c519baba0469245f79f6dfc502f8866a5ff8a3075db8ffc236cca22a9529799f96e656a53357be1f7ccf907b2a555ce42256384f49241c4ed1c05011713d68d0d86ca50d434523970cbdf55273544d9ce89325ffa18decd2fadb3abe4fa3f72a7eb560e954335776d60ff914374be3c3715a5844ccfa9cb038fc8b04999b548ccc026e99613729917cde759ca2dcc9dc067961a295de2fc04f9c9c4306a860d8916001480ef9543f79bba6b45945d8137c51d920bd8f5fd1712ebb62989421ad0966b2078e012dd3936adc697e19516e41be485e79e6f36770b64de27ead3ffccf052b718257916aea96df4a36782454d925afa804c80349d0b104a854cde1b336bd22324701a5c6c946f953d1f826e149968f9c7ea142799aefa46600e2ebb217cc2256ebe665b39919b9660d0a2ff89afca3f7b8dc046d5a54f64e8047c9e254f3fd5cf9f30948b06878a3d23c5f4391524ca1e476011436b24ef12a757ff52b6e65b36ef4ac84eb57e0c98f17549642eff9d3ac9fe208b45497e1b709693dd68a1885ab66d5a58b5f5f6d45897417346b35e632e3b5c5bece806303ef08541f5a0bb5fe780b5dd32e3a1cae68368f7b35152efec74bcb9843f124e270e9098856cba5f21e49658586c108b1ba56a57f379136d4fe6f85ec33e0772f017cbec948196cd2c68f6674289c3707e9805eadbf96ea011a3126119f013d5f333cce3cdbad7a45bdad3cfe3566cccb0287d0ff9ba9fad590d72a52e045d318c115d19b80caabf205c64f13026a5c63be12253b4d8651589cfcc2a7d6112b002956b013fc9c7f206f23af2de68abd52cbfef9a471681452f6d47d5447fd4515abfcb390652a00606085cd88e7675ad6fd55d10662bfbc1650be1841272087f515643931623c69f2297b1bcd4fbcdd336179831466d10561094ba58e693d500199a5d013d87d5c22c2c9fea7e4eeceeb5054e36a2a1c0fc137be12ca33e7ff479d4dd43a9733a62108a62c40a2ae98f887e509cbded45e28a296323a77041b7b943b3ff7b925f3d531df8d87f4495c4ec12994d5c18ecd99a9c4cdb58707904bc9df5285ae1ad54d648d46e63d4f09b8b0e60f6a9b2cf2ac3793054eb15b9a2a016e2719f8c4b7e20b11eeee0999fb3eadead0e2c2871c0443c2ff30c396a93c205f92a12aeefb4410c237ba2ff9306ced6df59a5d1b7c3d3f0d6a2111a531a2bfb78c7b334e05f2d0b966ae219327d554191800ef7efb457289ffbfca0f37b419e7cc8e2ab4b5baf4c34b12f0007f4e72f0400062ae5b7090fbd761239177c260dad6ef0d4227b1ba99dbeaab964fb071774d71e4d15f2f9955aa9079a7b5b5738310ba50729a4bea280a7ae724ea8f92e8ebb952a7727a9e2273cb3fa001c10c4bb7c7be82315ba54fc39235e29d9e386b010b37b2a47b1466ceb257b9f63db34597c66914c22d013ebaa4c0878572942d17cebc6d1fa0540501bee36f65c2782f3bf24bc245e5f41a56329c8ed09883209d053a8d53e85e7a017bacc493144f61444b0769a4699a30bfc6b9442144b7f1e08b359c4792d8c509dfc86169e673a6195119a05ef75ad00845fa8c8306fff5a6baed1a7573825a55faa71b9dd62f2064f24273b9e9afccb05dcb18306d184fd258fcf1c9c8e6f4c56161b104bd98468374d1c83baa2d412d595cb7287685bfa09a922cd26f864938ee2c043e5f8f50df5c3363c0149cffc7c84afe8b4778b3fc33b21572fded6e4eca9b8857593a469bced182825b6b01fc280955437055a8cad15f512484eb459ca5a62e58d1e294c8f1e337e311d67abfc8424e576e9e2c8672d02a5e3dcb8578debc18434580ea886ea840ec17829de6a17c23ab8e685305784d989534a31f2c2b2b4717d6a69028cf380688ad0a68e40c2e450468767b8c6276d501f5599a3b87b21e9c51b93e317241c8c0f7a74ff96fa988a25858630853821e0d1eb63a2c7adf1c5a344c780e9b39b63eea1981daffabb414e1d3039bdd0b72b7bae78b2faca3f7d259d2df6e27deee8f45e38f3ae9413289a5144b4d5c95cc6fde37e65dd6f515a84262458986289cdb40000a0b5ee4e111beec8f9980fc0d25c498ba7b340bae72c3ad0ed19a1a3681e37fa3a2e342f2d10182739434cacf561c353be6a858220c5cb6b776d3606cfb55fabbeef8260da6af0a5e19eba8b669314b55771a5f9827f818cdc4c0205af10cc741d6c549a27166989a1f2aedbca74b69a73e12767814241b9ace584cd3fbb2a1dc3aee82a5a71c675bba1a1a58b763bb82db32b21210e326e3a4face6982049c8593c10fc86f4e4da06f86a3d67a0f857dfab0a61341576b0e41b316051996b55b6d77735128faf8872036e9c73658ab64686b0c76bc34b96594d508e36cd2acde78c50bf7df138975b2fa95e4a6ffe8c1beba5fa8c6ba9937b9dfcce9576fa3a6eaada80d7e4d920479e2e4cf43738955ddcc984cb4b6e6ad7d89804c5d60e2716111dd763fb9bb996a3278be560f8c59d50c554f803cdb5c22042854eea7a1b40d6e28d4df24495cef10f912d79df5d106d4171b26849191dbfcf18db58364c489b0ab2d622bb6c4d4f3e9ff73e4966f033efaaf384b67d350925167e34e5eab97cded11c8224a4feb73316ac79964d0767ba694634c9da8ecb2b64d570470f3805beb4d88e20174f6c120369a244734c29e853f1ff486d4f133316d5685472f3669bc6f10cfe61813b77f651cbbceda51b443b929581ff805c6cec5c0caa383f43a37b4570594a21514ae1dfb2abae32a312a389c0237f957902b1082b02aff98e207042ad2647585a10e0d5eeea4011587bb3cc8a04087756a510d0aea38b1176a80befcf7637571a40a99666f386e71c61f8c0907924ff22088caf11f15c2dbbec1b8a8771691d4f9c2c941f9d16ca3aa1247cb72ecd5f414291ccdc04919ecc18dc67b1e1d9a9832c42a7b547788b83416f39aca172974e06db77c94a725cb643e8b91a27df1e1d6b96db5912deb26654731c217f9bfebae75e93ca25fd35469c74cc927af68e626d9fdd5aea573597ca5e9e327e49c8accc06046b0ef87d7cd532daae903b2d7bcfdfdd445091aa8b204a81709b4ddde0702ef42d7f8872e61b71a65f335e6a30cc567afc00aa76dea89903aad045f37ed46d8d53b52ce12a0f15b694dbfb9ec43553795314b9f0782ebb1f3a71e1c04a96f692060ed83bbfb82e3e92482ae37bdc7f0838cbf1d83531024bd21278bf295a836cd31df4b95ea8520379df49e6ae3c8f5d1922623bcfc04dd896af05e9f0cb6b32ed1f8f192af8bdcdf6d02e4b553e36d1fca08bd04b6c47abec5229d7b89d96aa9ca54b00ddba93137ab5fff79e9ee639bf33a6ed5555d1d89b0142df7a2453dc2f4007989e67213eafaf6b5b521f50a296246457da4c505ebe416b0237d8b7750376a53fb4dd92ade607036ac648b168d783e23b8781c0385bdfabb8387864ebe6d21d1e021719294abcb9a38b117cb1ff13339982b6614c455cc3efd1d7e4b3bd131553f8b9dc7c80fcf0f045220661cbe73e455ea9eaaf33ae0c9b12414d7ca2de1802a01c896365f3cc7345e360ad9a0730eac272f7dee2d7887fb6532bce6e92d2ffccc7d57b66c071a81a4eae9092c9a4d3f00a4795c59ec1fc61b1f95578ad6893f0c296f02af43698ea8eeaae0d078910409cc728a8e42c2b0777d008f2f3d4aed430b2edb8b3c1d91e2ab3c524b9a934a979738296df24f29a45e7d1893b6402ee72bf254a18883f1f5f99519c0c718d95652554a6cf2afc3afff0407cd1ff0f17dc4ed8bbe4c9754268753fce3af81aa7fdae778fffcdaa363d73dd77db38de8182e5bbc9f59e9797ed207104eb4c67f65eb5a97736ebddf90f4a6fd8d8e6c46db1277722dab2e4a96302b2bed4cea0f01dd5493b6d06a1faa20da2d342c72be13292e7afa07012c5cb99dc416ec755c7b2008246f5aac681f293f53293ff15169675eae4d15fcd76ce3edabafc9a536e3a67e7ddf24835702d7918468e4a5cd16c45d64035f4eb893448128fa43778024e7108b9d3c19917e5527de24b642983cef02e55f374e5b86db3216bbac67b6b1c31bf6bd203612dd1ae5450cfcfa812373e5693ea805d9a9832f19244897c45139cc1a3686c03ecef194ef85edcd40f9fa82f2dece48cf1e7c7169f021877d7300fc4f7f05da0b8d4183188e8a8fc5d3ba7fe63fc34d78bd36366348941ee5c5123132d14498d814945520b9c30dffe461c5f87371135ea600bbfcc6b97cca654974fa8dcac4597e5f06f8c75851b3913b25da5587b5fff89ea830ef917f86c95527d3e65634d183eab22ff29999e2f7c64ec32beb80ecd3d219cdc90c92e7e97b36770c8de68fa6516c1d06a3b8a16626de0bb604e569cf380a078e5016ffd9f980a33d058e48b4b67aa413f3a9c2f80360634fc1fbeefc5b15eeaac08d909f90bd7d560cb98fa09911b7f27a4593d2bb668db5f45afca56b201fc4674c9e65425da9ac9c1952ae7b1c5c2d61c91c2b8068373657bb0da8c391bec5632aefc7fd5eabeb9caa2d0dad98c5cee56bab019b886b583445becef53c70ab1410f91caf52a08d6e99c7e6adee3fb34a6784c39903a8f26b0578e95591db6e12b8f4d6643ea46bc5683fc370f57c3ad1f5e3171ca44c7bff14ff7ace1838d0191fefe1691e9726c0c5a6a4c23c49b93494ea5cba4ce440ac4044ec3a0a020cb621dc410dec5220680c1c4cf4b80fe9b5f55f8f10f51fbff0b03a41df8dbd2917189cb2203dce4a2e5840731d021bc76f0f5a85c461f8e682790c24d6100e7e889b672a8eb3cf9f02e86d2353ce9f37042dd5428c5916ef83a44ff8b8c2ba11dbac16cbafed76d739eeda9bd445780a565331db92df2be06c45783afbf25f9e98a0e9fed1facfea1b896e5dfcc36040eeb594e83248357eb20be3bf262d973f71f298873302bd0a01bc23e78d9b2d6ec6640044273a85e8017bd8f3f03e9cc6342ed2becdc729ae869ac40232cf9cf9e0a156dbab6b10d376a50c42fa60c259c1526463b4d05eba501760736c2ee3ab11384e9b3592c1d6207ef5d5e5ab483ebb10e2fc8092fec305346f0eae389407aa4a1744da83bd77a1f893f70d7b307495d9cda33c5612165bd52e348005e8a230a5ab7814b4518524ef2a49810490faa4807228065e39e60ae69bc7b44a4bb803b407dcb402680d535a6c227f8cee923c3206aaa59102cd12ecdd7b0126b7e8c64c888cfc3cca189e4ec905ee929a6119c14ddca974127d4b789496744ee524df53d7c6a57e8e9d440d10384fdabdbe28cad1550bffab8a0165fcadb177e9e8dfb89a271a91c1c8d17ca933e62c0b8ab0d32d42f626015781258f6ca0b95f3acc4b8c1ac643ba8b9363adc560470d29c7785a229a7570a35ce74a73e2508a6f463a885479570fe8b31f4f2b3c2484ae71bdf1011de0a531e6f4f2f8de89394a310c6bd881b6f7f07373722e9b2c6a2774e1de3502487be6454b16a093bf6a8e7342814c1fecc927fad4ddce877490cbf16105f272baa3a4e998091d3481d2fc35a9f101f9d94ec469f9cc05b8e9f5049d548d65b5fc314891ec7b0128e64878e0340e50f047822c1056448e311358347b19cd7d3b472fd86118f98a899211d2774c59b940c1187e44f7a96eb71ebd11949f38106bfe05aab59bff76985d543ed717a9a8fe8d6e3f69ae64a9c9df8f649f4c05f175fdb3ff16d3d449a609c4f31988eb7af6e336a0b31706420266bf7c6b48c1ab0888d04234a21da6d435bb535259ebb4fbef3a51a2ff72bbdf8d583c910347dcce735e30c34c50061f2cca81fddd28e782af3a0f79b0aaf688d53a2d722c91913ce8340747aa682e596f404b08070579499198f3c51e4e866f0dd6bf0c530ccb6cc71da1b6e91bd43b4e3f84953a259d0364a9ae888be536231bb443de9922d7833473f9a5b45cb243f9b27b1231df1c97a847ac0715d624912dad09943e79a7c14a641d1f9be67978795c57c18c83babc05bf3c7537fe928343ebe87c35f9e62e6f64fc1628f383c1936661d5dbebb47e93d68031dc89a9e2dcf6a029b7c6fd9016d22b4cff4d6dbf42e09436a200bf25cbedec90b62fa9aaea005e361a7214f9eb22b227b25011dc1aa5db7270c1b70a278fe319257dabbb0cf1b8ee05b1a43ae7461b390663da6850e9aa8b2603561c645330e9b64e31771e81ce7c69bf15f9b6de011de47d5640e42d1bf975bda5672ff73877e429b08cb8e54f28c97f7388f3bda856d19a3031153143676d57931f2e4935afc2c5e9eef12cf81894d81ffd81d94a8f71ac074a2bb3b2109c1b102256add72f851051240d2c4089b255f3d2d4830075339bc488704b0c2d2159b04367fd711e67418b5db9857d712b20a0da9c00afd7505aacfdd9764d6e04fb11c36625106f353a0f8fba652424656e773487f46f336128d7ef74cc7f1f4b24376b46b254fdb3c0538c9e10daaf98b3e3d2242d44f9818fd6d53618b2e533cf47189e63c82569da7ecbe5480d4624dde60b253cb0e8a82360ef9408b7e97cc3b08cf2acf6f88adb55f416356b67b0be149ef9e4f46cc6ba8c8c37da838b67a3b9873c98358e943a521b4bc38f11bb022f5587270f40c658708a854ab252598139aaa512defa3cf18ac46cac3e32f3460559907a2c9abe5a736930a3a73767be880145e14677650615a90be43b485fc1a899a668fd3399fcb7e48a2c647e732441efed9b7feacd45c7b675b8f531f9859a59414811aa31b77064e7c998b4c900fe7983d3745b40ad608c9cdd6d4dd4a41f7a88ddfb56b9fa3a11a08d98dd0fee3cdc985387b79ad4963ce2c80436b4caa6243b84af726a0d7ddb40ea64c5786e1bffc6628b52983ad215239967e4b05482f37167a20d201dd025934028f2f5ac4298787ce55a9bd670cfc580139562b20f7b19c655bcedfb2c07bbfb76a9f17246ff12d60f4de4968f7a3222ca7ff44e67b7997d34fd8391c354e4bd396e6a36d5df4fcc675f518f15c2702148c59e7ad8f6fd68e8f22244aace585e9c5ea0766736152518f2b7bf6f83a14438d98c1e31bb5622bdd72366f9bf71b3690dce0105b4121c98171b2ba5011891f5453fb7cb4e7ed152ace6ab77fd6c2d017ec90e98a80d432c2ddb89238a2f44572920a18e5de70ac9bce814ac0464994298b9515d5f6b05c4062f723e55832237d666f8ae7a9ba0c61bbf6ce8e85a9ef59bd3035e80407cd5fa7d9bbe6556d7ba565660b85d0be141a16f4f7d3d216632d2f00a161c0aeca56b313bcc6fcfd71969baac01077494d1ccb1eef47a30c84c39c70f788cfa69f5e205abb369f4e1313d8c15acf8504d7098eafa50c6c4e42cf4754f3ef0a31c3e2506c20570a4171634c80696340468d0c62874c5c93fac34c62cee493acb19c5c21ba20dfb33673897fd60cf9fe5753105d12b7123fc8c8a92f2addb3d2e2ceeb28d8ac966498abdff4e4bb09f185e5174233053e086c54a1fc796c4df298401591773f117ef4d23651e048a5184f22fbe858a6582224366a69822c0ddc1e2bffcc7fe6c159dd7410e18ba24274a771aeb501bfab9b4c9d59d2ccaf78a60d07ff209a06879f1242b0af7d68c219f732194a729be2612f1417fd510e0ceb064808857ddc686b5e849e1f9b380d91881e258fc42484cd2c20fc3e4dbbda31a7f86d51b192b5cf894056c96a96544ed1644bb511c7060011b01db43af4c0edcd52c1f76a601d5b3ce7af035cf37a8a9ffacce00f249cb21d764a432cec6f798145d2f2cb4eb5d6a87bf9840320b4a9d31125cc8f1045473404097045cd78c49993fda1211a6f5ab82e3c1d33286106316da16f81a8d4b2684667d930311836597aa8f3dce34feb8dd18c8874721ef1d4a2445a4bd4ba331e1f2c43092439748eccc71f086bfa396370dc1431f7501857cc19014b9a04eb31f9fcf6576ab89122a1a539ede1e5951b38edf22f92928b5aa33b7e9df05b9f59db311c8665458e3a53a1115c92e18bbcc43692c13a50354af132046cf8218a76ed0a0f209bc3e13c41ca01de517bc05647c34b574d9af28974921de130679108d0dbc849e3f952db3c7c750d626420aee2770b6849b4983398d6a6eb068c46f66346ee3d7db6f6244aa69cc1a7c41c3f873563446db287b5e9e6b767e72524a7144bfb38a15665950be3647725639fa78a24cc06202786a877f817101e5823f84b5a300469f73ba83c851b8c4e850ba2d3186506a467b2ffc388d344d9d305cdfae927d45ea6aa86e1e30eed0e9c8652fbb0e0b478e996657e3df453360e155599430820d87f07e8afe476d5b624fa6e12b9914bab2537043d3e95732cfdb0fb4b9c0681da35ebb929411ef41ea5be86bfb9b48c6965c5675e38b9e0515a2f133c4ab2f70899c6df3596a39ddf694cee35b7bab460b9de69f22e7b0e1d0797343c72b490bb64bc2e08f188c2becc9cf3ecbcd07d844012e89c79ca4aa3fa049187cfd83dff52e3f8a1da8a7ba4c4064af2c38d08afc8f755e15a9cddad146da22332c883fefc060690f9f4c92ccf04694fbf59aeb39b2d127e3a69d7b3374b190def9c3545aeebf7bb75093d22a92ca7bfc649b46136dfd5a080a69da58d328b4aa5a3adf4d2356cc185431027163da8120230f5d2ea47afc0a00e544b8f07e22d29f2d766fbaa0d77561f8ae3499ff3e64ec35cb79f50c91628cbd625b8f8b6217ad0476d1f73797798b3b949b4267d8e06de868a99c741d46435b43b4d18e47904ea3fe97c3d66c7dc6c30007a17160aee0331481a94af68b158a8d056362f7f0049d5be9c16ff5d45b04749ae8d457180d433f11f804d05da3e47eb0bd2c274a9c02783f3eabcf7127c70c8141b54805dc9bcce8dc43ac12714197c52f21644a73596f7de4b7d88982528c774a970d6a986725536bbde901c91c1ec2a7df4edb6044036da5d87cc95b90485878639bffdf38107ee21a7bd81f6001e87a26961039eb365bb817f3cf8b89ecead91cdffb310d8d5b1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>游园不值</title>
    <url>/yunruowuBlog/2020/08/11/%E6%B8%B8%E5%9B%AD%E4%B8%8D%E5%80%BC/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><div align = center>
    <h2> 游园不值
    </h2>
	<div>
    [宋]叶绍翁
    </div>
    <div>应怜屐齿印苍苔，小扣柴扉久不开。
    </div>
    <div>
        春色满园关不住，一枝红杏出墙来。
    </div>
</div>
]]></content>
      <categories>
        <category>诗词赋</category>
        <category>叶绍翁</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>叶绍翁</tag>
      </tags>
  </entry>
  <entry>
    <title>道德经（第七十六章）</title>
    <url>/yunruowuBlog/2020/08/10/%E9%81%93%E5%BE%B7%E7%BB%8F%EF%BC%88%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 align = center>道德经（第七十六章）</h2>
<p>人之生也柔弱，其死也坚强。草木之生也柔弱，其死也枯槁。故坚强者死之徒，柔弱者生之图。是以兵强则灭，木强则折。强大处下，柔弱处上。</p>
]]></content>
      <categories>
        <category>道德经</category>
      </categories>
      <tags>
        <tag>道德经</tag>
      </tags>
  </entry>
  <entry>
    <title>江南春</title>
    <url>/yunruowuBlog/2020/08/09/%E6%B1%9F%E5%8D%97%E6%98%A5/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><div align=center>
    <h2>
        江南春
    </h2>
    <p>
        [唐]	杜牧
    </p>
    <p>
        千里莺啼绿映红，水村山郭酒旗中。
    </p>
    <p>
        南朝四百八十寺，多少楼台烟雨中。
    </p>
</div>
]]></content>
      <categories>
        <category>诗词赋</category>
        <category>杜牧</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>杜牧</tag>
      </tags>
  </entry>
  <entry>
    <title>YunBlog可以评论啦</title>
    <url>/yunruowuBlog/2020/08/08/hexo-Next%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>##起因</p>
<p>​		本来我这个博客也没有很多人看到，只是自己写着玩的，所以就没有设置评论的功能。</p>
<p>​		但是今天有个小可爱问我怎么没有评论功能，导致她想评论的时候，没有办法。那不行呀，必须服务好她。所以就在网上找了一些教程。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808212733403.png" alt="image-20200808212733403"></p>
<p>​		首先是查看有哪些评论系统，网址在这里，<a href="https://www.zhihu.com/question/267598518">Hexo（NexT 主题）评论系统哪个好？</a></p>
<p>​		然后选择了Valine，然后它主页说hexo已经可以支持这个评论系统了，那下面的事情就简单很多了。接下来找了一个教程：<a href="https://yuanmomo.net/2019/06/20/hexo-add-valine/">Hexo Next 主题添加 Valine 评论系统</a>。感谢博主的帮助。</p>
<h3 id="系统配置：">系统配置：</h3>
<ol>
<li>
<p>申请 LeanCloud账户，这个具体干啥的我也没研究，感觉功能挺多。</p>
</li>
<li>
<p>申请应用，按照下图添加两个类：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808213759214.png" alt="image-20200808213759214"></p>
</li>
<li>
<p>最后应用Keys中记住两个<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214003660.png" alt="image-20200808214003660"></p>
<p>​	这是要填写在配置文件中的。</p>
</li>
</ol>
<h2 id="配置文件：">配置文件：</h2>
<ol>
<li>编辑 next的_config.yml 文件</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214252561.png" alt="image-20200808214252561"></p>
<p>修改 valine.min.js 的 cdn 文件地址，到这里 <a href="https://www.jsdelivr.com/package/npm/valine">https://www.jsdelivr.com/package/npm/valine</a> 这个地址选择最新版本的Valine，然后获取cdn地址，修改到 主题配置文件 _config.yml 即可。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214325591.png" alt="image-20200808214325591"></p>
<h2 id="成果：">成果：</h2>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214539154.png" alt="image-20200808214539154"></p>
<p>搞定啦！🐱‍🏍💞</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>南园十三首（其五）</title>
    <url>/yunruowuBlog/2020/08/08/%E5%8D%97%E5%9B%AD%E5%8D%81%E4%B8%89%E9%A6%96%EF%BC%88%E5%85%B6%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2><div align=center >
    南园十三首（其五）
</div></h2>
<div align = center>
    [唐]李贺
</div>
<div align=center >
    <p>	
        男儿何不带吴钩，收取关山五十州。
    </p>
    <p>
        请君暂上凌烟阁，若个书生万户侯?
    </p>
</div>
]]></content>
      <categories>
        <category>诗词赋</category>
        <category>李贺</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>李贺</tag>
      </tags>
  </entry>
  <entry>
    <title>且行且珍惜</title>
    <url>/yunruowuBlog/2020/08/07/%E4%B8%94%E8%A1%8C%E4%B8%94%E7%8F%8D%E6%83%9C/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2><div align=center>且行且珍惜</div>
<div align=center>[明]无名氏</div>
<div align=center >
    看山思水流，触景进乡愁，问君意随流，绵愁几时休。
</div>
<div align=center >
    念己勿念欲，行己知行义，相离莫相忘，且行且珍惜。
</div>
]]></content>
      <categories>
        <category>诗词赋</category>
        <category>无名氏</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>无名氏</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL无法使用</title>
    <url>/yunruowuBlog/2020/08/07/WSL%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="WSL无法正常启动，报错">WSL无法正常启动，报错</h2>
<p>win10更新之后，打开wsl报错，报错内容是：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808151143995.png" alt="image-20200808151143995"></p>
<p>然后在网上找办法，最后在vscode的github上的issue找到了解决办法：</p>
<p><a href="https://github.com/microsoft/WSL/issues/5633">GitHub/vscode</a></p>
<p>这是一个解决办法，可以在cmd和powershell中使用：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808151412228.png" alt="image-20200808151412228"></p>
<p>下面的可以在windows Terminal和vscode中使用：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808151509638.png" alt="image-20200808151509638"></p>
]]></content>
      <categories>
        <category>WSL</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>杂曲歌辞•杨柳枝</title>
    <url>/yunruowuBlog/2020/08/06/%E6%9D%82%E6%9B%B2%E6%AD%8C%E8%BE%9E%E2%80%A2%E6%9D%A8%E6%9F%B3%E6%9E%9D/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2><div align=center>杂曲歌辞•杨柳枝</div>
<div align=center>[唐]白居易</div>
<div align=center>一树春风千万枝， 嫩于金色软于丝。
<div align=center>永丰西角荒园里， 尽日无人属阿谁。]]></content>
      <categories>
        <category>诗词赋 - 白居易</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>白居易</tag>
      </tags>
  </entry>
  <entry>
    <title>win+ununtu双系统</title>
    <url>/yunruowuBlog/2020/08/04/win-ununtu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="win-ununtu双系统">win+ununtu双系统</h2>
<p>​	现在学习需要使用Ubuntu16的系统，但是系统要求比较高，不能在虚拟机上安装，需要安装原生的系统，但是我的win10确实是很好了，舍不得放弃它，没办法只能装个双系统了。</p>
<p>​	教程都是在百度上找的，下面这个很全面，很实用，我已经按照这个完成了。下面放出链接：<a href="https://blog.csdn.net/fanxueya1322/article/details/90205143">win+Ubuntu</a>。</p>
<p>​	安装过程还是比较顺利的，就是安装的时间花费比较久。</p>
<p>​	下一步就是美化Ubuntu了。</p>
<p>​	我承认自己不折腾会死。💖🐱‍🏍</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Congestion Avoidance through Packet-chaining Reservation</title>
    <url>/yunruowuBlog/2020/08/03/Network-Congestion-Avoidance-through-Packet-chaining-Reservation/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Network-Congestion-Avoidance-through-Packet-chaining-Reservation">Network Congestion Avoidance through Packet-chaining Reservation</h2>
<p>基于数据包链预约的主动拥塞控制协议</p>
<p>​		预约的本质就是在整个网络中做仲裁，而仲裁时间和仲裁粒度必须要匹配。基于此，本文提出了数据包链预约协议（Packet-chaining Reservation Protocol，PCRP），选取合适的预约粒度以和预约的时间相匹配，提升预约的准确性和灵活性；还通过在全网提升短流的优先级的方法，有效的保障了短流的利益，降低流完成时间。</p>
<h3 id="数据包链预约协议">数据包链预约协议</h3>
<p>​		对应于在 SRP 中分配预约时间片的方法，PCRP 采用以数据包链（packet chaing）为单位进行预约的方法。术语“packet-chaing”是几年前首次提出的，它通过将发往同一目的地的数据包链接在一起来操作，以复用数据包在通过交换机时的交换机连接，减少交换机仲裁次数。本文借鉴了数据包链的概念来描述流中几个连续数据包的集合。为了优化流完成时间，PCRP 在发送端采用基于SRPT 的调度策略，并使用多优先级队列来支持接收端的基于优先级的调度。此外，PCRP 使用动态优先级表来执行多次授权。将详细描述 PCRP。</p>
<h4 id="1-1设计空间">1.1设计空间</h4>
<p>​		由预约协议表示的主动拥塞控制机制基本上通过调整发送端的行为来避免网络拥塞。发送端可以控制要发送的数据量：不发送，发送一个数据包或发送整个流。SRP，SMSRP 和 BFRP 都是极端的。它们实际上是以整个流为粒度进行预约的，第二章解释了这种情况的缺点。在另一个极端，预约是以数据包为粒度的，这就要求接收端在每次发送端想要发送数据包时发送信用数据包。但是，我们没有时间去安排和调度每个数据包。因此，短流将因等待接收端的调度决定而受到影响，并且大量的信用数据包将使网络负担加重。</p>
<p>​		PCRP 设计空间的一个挑战是如何选择链接数据包的大小来平衡准确性和预约开销之间的矛盾。一方面，在预约期调度每个数据包在时间上是昂贵的。另一方面，使用流的粒度进行调度将显着地降低预留准确性。为了匹配作为单个往返时间（RTT）的网络仲裁周期，我们将 RTT 的数据量作为数据包链的大小。这是一个很好的折衷方案。</p>
<p>​		PCRP 的另一个挑战是如何最大限度地避免短流受到协议本身的干扰。因为长流比短流长得多并且可以严重阻塞短流，所以我们必须在长流前安排短流传输以减少短流的完成时间。PCRP 为短流分配更高的优先级，以确保在发送端，网络和接收端中更早地调度这些流。此外，PCRP 允许多个请求和多个授权以实现过度匹配。我们缓冲到达的数据包链并优先考虑短流的数据包链接。结合过度匹配和优先级策略，PCRP 可以显着减少流完成时间。</p>
<h4 id="1-2-执行过程">1.2 执行过程</h4>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806091617781.png" alt="image-20200806091617781"></p>
<p>​		PCRP 将每个流划分为多个数据包链，每个数据包链包含固定数量的数据包（流的尾数据包链包含的数据包数可能少于此值）。如图（a）所示，数据包链的大小设置为可以在 RTT 中传输的数据量。Flow 1 分为三个数据包链，其中尾数据包链仅包含两个数据包。由于 flow 2 的长度小于数据包链，因此整个流是一个数据包链。</p>
<p>​		由于 PCRP 不需要预先进行发送预约请求，因此发送端可以以投机的方式直接将每个流的第一个数据包链发送到网络中。投机包具有比正常包更高的优先级，并且不会在网络中被丢弃。虽然第一个数据包链可以以投机方式直接发送，但剩余的数据包链必须在发送之前等待接收端的授权（grant）才能激活。图（b）显示了 PCRP 过程。发送源 <em>S</em> 直接将 flow 1 的第一个数据包链的数据包逐个注入网络，并向接收端请求发送下一个数据包链。在从 <em>S</em> 接收到数据包之后，接收端D 计算剩余的 flow 1 的长度，并确定是否有必要向 <em>S</em> 发送授权数据包。如果需要，则向 <em>S</em> 发送授权数据包。同时，授权数据包携带优先级信息，用于引导 flow1 的下一个数据包链（即非投机数据包链，正常数据包链）中在进入网络时的的优先级。在 <em>S</em> 从 <em>D</em> 接收到授权数据包并激活下一个数据包链之后，数据包链中的数据包可以参与发送方的调度仲裁，直到整个流被发送完成。由于合理的数据包链大小设置，flow 1 的传输过程是连续的。</p>
<p>​		PCRP 允许接收端同时授权多个不同的流，其中高优先级的短流优先于低优先级的长流。一个例子如图3.3（c）所示。当 <em>D</em> 从 <em>S</em>1 接受 flow 1 时，由 <em>S</em>2 发送的较短流 flow 2 到达 <em>D</em>。此时，<em>D</em> 将基于其优先级优先处理 flow 2 的数据包，并将到达的 flow 1 的数据包临时存储到 NIC。在完全接收 flow 2 之后，再从 NIC 的缓冲区中提取来自 flow 1 的数据包进行处理。发送源 <em>S</em>1 等待 <em>D</em> 发送的第二个授权数据包到达并重新开始 flow 1 的发送。由于数据包链的大小恰好是可以在 RTT中传输的数据量，所以当 flow 1 的最后一个数据包链到达时，存储在 <em>D</em> 的 NIC缓冲器上的数据包刚好被 <em>D</em> 处理完毕，因此在重新启动之后 flow 1 的传输仍然是连续的。</p>
<h4 id="1-3发送端行为">1.3发送端行为</h4>
<p>​		当应用程序生成流时，PCRP 发送端首先将其划分为多个数据包链。数据包链具有以下状态：</p>
<p>​		<strong>投机</strong>：每个流的第一个数据包链可以在没有授权的情况下以投机模式直接发送，并承担向接收端发出类似预约请求的任务。</p>
<p>​		<strong>非活动</strong>：除流的第一个数据包链外，任何后续数据包链默认情况下都处于非活动状态。需要激活它们才可以进行发送，这些数据包链必须等待来自接收端的授权。</p>
<p>​		<strong>活动</strong>：收到授权后，发送端激活相应的数据包链。激活的数据包链可以参与调度仲裁，直到它被发送。</p>
<p>​		相应地，每个流也有两种状态：就绪和等待。当流具有投机或活动数据包链时，流处于就绪状态; 如果流的数据包链都是非活动状态，则流处于等待状态。</p>
<p>​		PCRP 在发送端利用 SRPT（最短剩余处理时间）仲裁策略。SRPT 调度策略的基本机制是根据流的大小确定流的优先级，从而可以优先传输剩余最小的流。这种策略的优点是即将完成传输的流不会被另一个较小的短流中断。但是，使用SRPT，更多的投机数据包链将无节制注入网络，然后汇聚到接收端。为了减轻对接收端和网络的压力并更好地保证预约的效率，我们将变量 EU-Flow（最早未完成流）添加到调度器中。每次发送数据包时，发送端调度器将进行仲裁。调度器首先检查 EU-Flow 变量记录的流是否就绪。如果是，则调度器选择其为将要传输的流; 如果没有，它将使用 SRPT 策略选择另外一个已就绪的流进行传输。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806092714656.png" alt="image-20200806092714656"></p>
<p>​		图显示了 PCRP 发送端的调度策略。图的左侧是每个流的剩余长度。Flow 3 处于等待状态，不能参与仲裁。调度器首先检查 EU-flow 是否准备就绪。Flow 4 准备就绪，因此调度器选择它。其他已就绪的流，如 flow 2，其剩余大尽管小于 flow 4 的剩余大小，必须暂时等待。EU-Flow 机制确保了首先开始发送的流优先从发送端发送。这不仅避免了发送端向网络中注入大量投机数据包所造成的拥塞，而且避免了短流被超短流拦截而引起的不必要的性能下降。</p>
<p>​		在 HPC 的通信负载中，长流的长度经常是短流的几百倍。如果调度器总是执行上述方法，那么长流将被饿死。为了避免长流被饿死，PCRP 会考虑流在调度器中的等待时间。如果长流的等待时间超过流最大等待时间（Maximum Flow Wait Time，MFWT），则长流的优先级将增加，以便调度其可以及时将其发送。请注意，我们不会将长流的优先级提高到最高级别，以避免阻塞其他短流的发送。在我们的实现中，MFWT 根据 HPC 网络负载特性设置为固定值。</p>
<h4 id="1-4-接受端行为">1.4 接受端行为</h4>
<p>​	PCRP 接收端根据其优先级调度数据包链。我们在 NIC 上添加了一些轻量级缓冲区，以临时存储到达接收端的数据包，这些缓冲区以多个优先级队列的形式组织，如图3.5所示。接收端 NIC 首先根据优先级从队列中提取数据包，从最高到最低。但是，NIC 的接口速率是固定的，即每个周期只能接收一个 flit，并且必须串行处理 flit。到达的数据包不会自动驻留在缓冲区中，这样优先级队列就不能发挥作用。为此，我们在 NIC 上添加了一个等待窗口。在此窗口中，NIC 仅接收数据包但不处理它，因此这些数据包将驻留在缓冲区中。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806093144375.png" alt="image-20200806093144375"></p>
<p>​		PCRP 在接收端侧维护动态优先级表。当 NIC 从队列中提取新流数据包进行处理时，它会将流的信息添加到动态优先级表，并根据流的大小对表重新进行排序。然后，NIC 对动态优先级表进行索引，并通过比对流的大小和剩余的大小来确定提取的流是否需要授权。此外，NIC 从动态优先级表中获取该流的优先级，并通过授权报文向发送端通知优先级信息。当发送端收到授权时，它会激活相应的数据包链并用授权数据包携带的优先级标记它。当数据包链到达接收端时，它根据其优先级进入相应的队列。</p>
<p>​		但是，接收方无法在没有限制的情况下授予所有到达的流量。PCRP 设置了在接收端可以授权的流的数量的上限。也就是说，当表已满时，NIC 将不会在新的流到达时更新动态优先级表，并且除非表中的旧流已被处理掉，否则无法发送授权数据包。设置授权的上限阈值是一种预约的方式。PCRP 接收端可以同时响应多个流的预约请求，并将不能立即处理的数据包链临时存储到缓冲区中。</p>
<h4 id="3-5-数据包链优先级">3.5 数据包链优先级</h4>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806093612568.png" alt="image-20200806093612568"></p>
<p>​		PCRP 发送端发送的每个数据包链都带有优先级。投机数据包链的优先级由集中统计单元根据流的大小分布决定，正常数据包链的优先级由接收端的授权决定。</p>
<p>​		每个数据包链中的所有数据包都具有相同的优先级。投机数据包链具有比正常数据包链更高的优先级。如果网络支持 8 个优先级，并且 <em>P</em>0 <em>&gt; P</em>1 <em>&gt;</em>…<em>&gt; P</em>7，一种可能的解决方案是将 <em>P</em>0 到<em>P</em>3 分配给投机数据包链，将 <em>P</em>4 到<em>P</em>7 分配给正常数据包链。</p>
<p>​		<strong>投机数据包链优先级</strong>。投机数据包链的优先级由集中统计单元获得，集中统计单元计算网络中流的长度分布，然后通知发送方。如图3.6所示，集中统计单元收集接收端接收到的流的大小信息，然后计算网络中流的累积分布函数（CDF）。集中统计单元将 CDF 分成四个相等的部分（基于投机数据包链被分配四个优先级的假设），然后获得对应于每个优先级的大小范围。发送端收到该信息后，根据每个流的大小设置其第一个数据包链的优先级（投机数据包链接）。由于 HPC 网络中的实时流量不会频繁更改，因此无需实时更新优先级信息。因此，为了减少浪费网络带宽，以较低的固定频率动态更新投机数据包链的优先级信息。</p>
<p>​		**正常数据包链优先级。**正常数据包链的优先级信息由接收端实时动态调整。接收端维护一个动态优先级表，并根据流的大小对其进行排序。流的长度越小，优先级越高。如果表中的流的数量超过了可以分配给正常数据包链的优先级的数量，则所有后续所有的流都被赋予最低优先级。如图3.5所示，分配给第一个到第五个流的优先级分别是 <em>P</em>4，<em>P</em>5，<em>P</em>6，<em>P</em>7 和 <em>P</em>7，并且所有排序在更后面的流将被分配给最低优先级。</p>
<p>​		动态优先级表有助于接收端更准确地处理正常的数据包链优先级。另外，接收端不需要考虑整个网络的流的大小分布情况，而优先级可以由动态优先级表直接分配。这确保了在优先处理短流的同时网络性能受到的影响较小。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>PCRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Omnet++</title>
    <url>/yunruowuBlog/2020/08/03/Omnet++/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Omnet">Omnet++</h2>
<p>主要由六个部分组成：</p>
<ol>
<li>仿真内核库（simulation kernel library,简称Sim）</li>
<li>网络描述语言的编译器（network description compiler, nedc）</li>
<li>图形化的网络编辑器（graphical network description editor,GNED）</li>
<li>仿真程序的图形化用户接口－Tkenv</li>
<li>仿真程序的命令行用户接口－Cmdenv</li>
<li>图形化的输出工具－Plove和Scalar<br>
整个结构如下：<br>
<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/p1.png" alt="p1"></li>
</ol>
]]></content>
      <categories>
        <category>Omnet++</category>
      </categories>
      <tags>
        <tag>Omnet++</tag>
      </tags>
  </entry>
  <entry>
    <title>CRSP: Network Congestion Control Through Credit Reservation</title>
    <url>/yunruowuBlog/2020/08/03/CRSP-Network-Congestion-Control-Through-Credit-Reservation/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Network-Congestion-Control-Through-Credit-Reservation">Network Congestion Control Through Credit Reservation</h2>
<p>​		ECN对参数敏感，网络拥塞的响应时间较慢，而SRP的预留操作不准确。为了实现更有效的拥塞管理，提出了CRSP，一种主动的信用保留调度协议，它可以有效避免端点的拥塞并减少流完成时间。与SRP相似，CRSP还需要在发件人和目的地之间进行预留许可的握手操作，以避免形成网络拥塞。但是我们以控制报文少的轻量级版本实现了CRSP，并且CRSP的开销小于SRP。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200804095356406.png" alt="image-20200804095356406"></p>
<p>​		CRSP的操作如图5所示。发送方中的活动流通过首先发送保留数据包Res（1）来启动与目的地的通信。预留包是小且具有最高优先级。它在单独的控制虚拟通道（VC）上传输以确保快速传输。每个预留分组携带预留大小n，这意味着预留流的迁移数量。目的地将根据预留大小和Res来为流量分配信用。发送预留数据包后，该流将等待目的地分配的信用的答复，并且不会发送此流的任何信息。</p>
<p>​		在目的地中，添加了一个保留缓冲区（Res  buf）以缓冲预约数据包。目的地接收到预约包后，它将被放入预约缓冲区的尾部。另外，在目标中添加了一个名为“信用池”的计数器。目的地中的信用编号存储在贷方池中，它指示目的地的吞吐能力。信用号由目的地的接受率决定。在每个周期中，目的地将首先在预留缓冲区的前面获取一个预留数据包，然后将预留大小（即Res中的n）与尚未分配的剩余信用数进行比较（2）。如果剩余信用数大于预留数据包所需的数量，目的地将源节点所有所需的信用分配给源节点，目标节点将通过生成授权数据包以通知源，预留流被允许发出数据包。到目的地（3）。同时，目的地将更新信用缓冲区并从预留缓冲区中弹出相应的预留包（4）。可以从预留数据包的源获取授权数据包的目的地。但是，如果剩余积分的数量不足以分配给预留包，则预留缓冲区前面的预留包将必须等待下一个周期，而不是被丢弃。也就是说，如果剩余的信用额度小于预留数据包所需的信用额度，则信用额度缓冲器将不会被更新（5）。</p>
<p>​		当源节点接收到一个流的授权包时，它将立即发布该流的数据包（6）。  CRSP根据流调度数据包，以确保将流完成时间最小化，这意味着只有当流已被传输时，才能选择具有最小q的其他流来发布。当目的地接收到数据包时，已分配到相应流的信用额将被收回。恢复的信用将添加到信用缓冲池中，然后分配给其他流。所有传输将重复此过程。但是，值得注意的是，当目的地将信用分配给多个流时。这些流可能会在某个时间到达目的地，这也可能导致端点拥塞的形成。为了避免这种情况，我们设置阈值p以限制信用缓冲池的大小。阈值p表示允许源节点保留的信用池中的流数。如果将阈值设置得太大，则表示信用池允许大量流在一段时间内进行保留，并且这些保留的流可能同时到达目标节点，从而导致目标节点发生拥塞。如果阈值设置太小，则网络带宽无法充分利用，将降低吞吐量。在此实验中，我们将阈值p设置为两个最大流量的大小。</p>
<p>​		CRSP旨在最小化流延迟并获得更高的网络带宽。  CRSP避免在发送方将数据包发布到网络之前形成端点拥塞。与其他基于时分协议的主动式拥塞管理机制（例如SRP）相比，CRSP更加准确有效。为了最小化控制数据包的开销，所有保留数据包，授权数据包都被最小化，并在单独的高优先级VC上传输以保证快速传递。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>CRSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Channel Reservation Protocol for Over-Subscribed Channels and Destinations</title>
    <url>/yunruowuBlog/2020/08/03/Channel-Reservation-Protocol-for-Over-Subscribed-Channels-and-Destinations/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Channel-Reservation-Protocol-for-Over-Subscribed-Channels-and-Destinationsv">Channel Reservation Protocol for Over-Subscribed Channels and Destinationsv</h2>
<h3 id="1-信道保留协议CHANNEL-RESERV-ATION-PROTOCOL">1. 信道保留协议CHANNEL RESERV ATION PROTOCOL</h3>
<p>​		使用CRP，每个超额预订的信道和目的地都会保留一个预留表。该表中的每个单元代表一个未来的时隙，并以时钟周期（连续）粒度记录可用带宽。源发送记录参与资源可用性的请求。然后，目的地将计算满足请求大小的最早的公共可用性，并以授予进行响应。然后，Grant然后在转移回源时最终确定参与资源中的保留。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803174200355.png" alt="image-20200803174200355"></p>
<h4 id="1-1-Reservation-Tables">1.1 Reservation Tables</h4>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803175034293.png" alt="image-20200803175034293"></p>
<p>​		将预留表与每个资源相关联。表的每个单元格对应一个时隙，该单元格中的值表示相应时隙中可用带宽的cycles数。上图显示了32个表单元（$V_{cells}$）的示例配置，每个表单元占用512个周期（$C_{max}$）。在此示例中，将来最多可以保留16384个周期的资源。在图中，单元格A对应于包含周期0-511的时隙，单元格B代表周期512-1023的时隙，依此类推。如图所示，时隙（单元）A具有512个可用周期，而时隙B仅具有10个可用周期。<br>
​		如果$t[i]&gt;0,t[i]+t[i+1]\geq x$，则资源可以在时隙i内容纳大小为x的请求。也就是说，对应的表格单元必须至少有一个空闲时钟周期，并且该表格单元与下一个单元的总和必须至少为请求大小。这允许请求跨越两个相邻的单元格，从而减少碎片的不利影响。<br>
​		当时间提前$C_{max}$个cycles时，保留表在逻辑上会移动一个单元格。在上面的示例中，当系统时间变为512时，删除单元格A，并将表向左移动一个。在右侧插入了一个值为$C_{max}$的新单元格。为了保持同步，必须使用某种技术*（A fine-grain clock synchronization mechanism for myrinet clusters. ）*将所有资源同步到全球时基，且精度至少为±$C_{max}$个cycles。<br>
​        为每个关键资源维护保留表。每个目标的网络接口卡（NIC）均包含该目标的出口通道的表格。每个路由器为驱动潜在瓶颈通道（例如群集间通道）的每个输出端口维护一个表。</p>
<h4 id="1-2-Reservation-Handling-in-Channels">1.2 Reservation Handling in Channels</h4>
<p>​        预留请求携带一个长度为$V_{cell}$的位向量，其中每个位都表示一个时隙的可用性。请求向量初始化为全true。每次请求向量传递资源时，该资源都会重置向量中与资源没有请求带宽的时隙相对应的任何位。实际上，每个资源在通过时将其可用性与请求向量进行“AND”运算。当请求向量到达目的地时，它表明：在请求通过资源时所有必需的关键资源都具有足够带宽来处理请求的时隙。 <img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200803184015703.png" alt="image-20200803184015703"></p>
<p>​		预留向量与预留表同时向左移动一位。当预留向量发生移位时，将在右边插入一个T比特，因为最初在新的时隙内资源可用。保留向量移位由路由器执行。</p>
<p>​		考虑下图。在此示例中，单元格A和C保持为T，因为该表可以容纳这些时隙中的80个周期的请求。单元D将其位设置为false，因为它没有剩余带宽，而单元E将其位设置为false，因为单元E和F的总和不足以进行请求。最后，单元格B保持为真，因为单元格B和C的总和可以容纳80个循环。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803184159859.png" alt="image-20200803184159859"></p>
<h4 id="1-3-Rservation-Handling-in-Destinations">1.3 Rservation Handling in Destinations</h4>
<p>​		目的地将到达的请求的预留向量与其自己的表进行比较，并计算出请求路径上所有参与资源（包括目的地）可以容纳的最早时隙。与信道中的向量处理类似，如果时隙具有可用周期并且其和下一个小区的可用带宽之和满足传入请求，则认为该时隙在目标位置可用。</p>
<p>​		在对它们的可用性进行“与”运算后放入请求向量中，目的地生成一个授权响应，该响应带有一个时间戳，该时间戳对应于最终向量的最左边的T位。这是所有必需资源都可用的最早时间。</p>
<p>​		此操作如下图所示。在此示例中，目的地的单元格A无法容纳请求，因为目的地的保留表中的单元格A和B的总和小于所请求的80个周期。但是，单元格B可以容纳该请求，因为合并的单元格B和C具有140个自由周期。单元C也能够容纳该请求。我们选择单元格B作为最早可以处理请求并减少单元格B和C的表条目的表格，以保留80个周期（每个单元格40个）。实际的预留周期跨越了两个时隙，包】括时隙B的最后40个周期和时隙C的前40个周期。时间戳记为984，对应于时隙B的最后40个周期的第一个周期</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803184701842.png" alt="image-20200803184701842"></p>
<h4 id="1-4-Grant-and-Retry-Operation">1.4 Grant and Retry Operation</h4>
<p>​		当授权数据包返回源时，它们会沿其路由递减每个保留表的相应单元，以将分配的带宽标记为其他流不可用（图2中的C点）。如果那时与时间戳相对应的单元没有足够的周期来满足请求，则从下一个单元中减去任何剩余的时隙。在图5的示例中，目标为80个保留周期的周期生成了周期984的授予时间戳记。当该授权到达具有图4中所示的预留表的信道时，单元B对应于周期984，因此将减少10，并将其设置为0，而将单元C减少剩余的70个周期，从而将其设置为30。</p>
<p>​		如果两个表单元格不再具有足够的周期来满足请求，则授权将转换为重试响应。如果带宽是在保留请求到达其目的地，生成授权并返回到参与信道（从图2中的A点到C点）所花费的时间内由另一个流保留的，则可能会发生这种情况。如果预订请求的最终向量没有T位或不存在公共可用性，则目的地也会发出重试。重试指示在短暂的延迟($R_{cycles}$)后源重新传输。唯一的例外是当发出重试的原因是目的地的预订表在任何时间段内都无法使用指定的预订大小，而与预订请求的向量无关。在这种情况下，重试将指示源在$V_{cells}×C_{maxcycles}$之后减去往返延迟后重新发送其请求</p>
<p>​		当授权在信道上转换为重试时，目的地中预留和信道中回复已经遍历过的预留不会取消。我们的实验证实了推测性数据包（在下面说明）和控制数据包有效地利用了带宽。大量超额预订的资源更靠近流量源会增加带宽不必要地在下游资源中以这种方式分配的可能性。</p>
<p>​		为了防止由于多个流试图保留相同的时隙而导致重试，保留请求可以选择在它们遍历参与信道时急切地保留最早的时隙（图2中的A点）。如果有目的地，目的地将优先授予该预定的时隙。预留赠款会释放对赠款流程的所有不必要的急切保留。由于急切的预约与流标识符相关联，因此这需要标签匹配。为单个请求急于保留一个以上的时隙（$R_{res}$），会增加目的地授予预保留时隙的可能性，即使存在合格请求，也会增加空闲带宽的可能性。授予和重试被强制使用请求路径的相反方向返回，以便它们可以操纵正确的通道保留表。通过使请求数据包记录其路径或在确定性路由的情况下通过简单的计算来标识反向路径。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>CRP</tag>
      </tags>
  </entry>
  <entry>
    <title>BFRP: Endpoint Congestion Avoidance Through Bilateral Flow Reservation</title>
    <url>/yunruowuBlog/2020/08/03/BFRP-Endpoint-Congestion-Avoidance-Through-Bilateral-Flow-Reservation/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Bilateral-Flow-Reservation-Protocol，BFRP">Bilateral Flow Reservation Protocol，BFRP</h2>
<p>​		与基于数据包的调度机制不同，BFRP通过调度流来避免拥塞。我们的设计基于SRP的调度策略。流完成时间与大流和小流的发送顺序有关。首先安排小流量可以减少平均流量完成时间。但是，当调度程序每次选择最小流量时，大流量可能会饿死。为了避免这种情况，我们为每个流设置优先级p，并且p等于流大小。每次调度程序对流进行舍入时，p的值都会减少d。当大流量四舍五入时，p的值将变得非常小，调度程序每次都会选择具有最小p的流量，以避免出现饥饿的情况。</p>
<p>​		图3显示了BFRP的过渡过程。在一个节点中，整个过程分为三种状态：SPECa，SPECb和NORMAL。如果网络没有拥塞，则BFRP将不会进入NORMAL状态。  SPECa状态是BFRP中发送方的初始状态。首先，发送方将选择具有最小p的流，并将推测性数据包发送到网络中。当发送方收到否定确认数据包（NACK）时，它将发送y预留数据包到目标，然后进入SPECb状态。但是，在SPECb状态下，如果发送方在预留数据包发送开始到授权时间到达之间的时间内未执行任何操作，则会急剧增加准备发送的其他流的排队延迟，从而导致平均流量延迟增加。因此，建议在达到授权时间之前，先发送其他流的推测包。详细地说，在发送方发送预留数据包之后，数据包调度程序会在其他发送队列中选择具有最小p的就绪流，然后提前发送这个流推测性数据包。当发送方收到确认数据包（ACK）时，它将继续发送推测数据包。当接收到NACK时，为了确保源的多个预约流没有冲突授予时间，发送方将不对此流进行预留，以确保只有一个流预约给目标。但是，调度程序将选择另一个具有最小p的流进行传输。在授予时间到来之前，BFRP进入正常状态，并且数据包调度程序选择保留的流，发送方以正常模式发送该流的数据包。传输完成后，调度程序将根据此规则选择其他准备传输的流。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803203856734.png" alt="image-20200803203856734"></p>
<p>​		下图显示了BFRP的操作。首先，我们假设网络没有拥塞。数据包调度程序从发送方队列（1）中选择具有最小p的流。之后，发送方将推测性数据包发送到目的地（2）。推测数据包在低优先级VC上传输。每个推测性分组都与生存时间survival time（ST）和排队时间相关联，如果网络中的推测性分组的排队时间大于ST，则该推测性分组将被丢弃。在我们的实现中，ST是基于高负载均匀流量下网络的数据包延迟分布的固定值，当推测性数据包进入路由器的输入端口时，数据包的排队时间开始。当排队时间到达输出端口中VC的开头时，将检查排队时间。接收到推测性数据包后，目的地需要用ACK进行回复，以通知发送方这些数据包已被接受。当网络没有拥塞时，通常会接受推测性数据包，并且目标返回ACK（3）。这样，分组将以推测性分组的形式传输，并且不会带来任何其他开销。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200804090633984.png" alt="image-20200804090633984"></p>
<p>​		在拥塞的网络中，初始操作与上述相同。但是，当面临端点拥塞时，由于到达ST的排队时间，推测性数据包将被丢弃。届时，NACK将在路由器中生成并发送回发送方（5）。发送方中的NACK管理器收到NACK数据包后，发送方将从SPECa状态转换为SPECb状态，然后发送预约数据包与目标进行握手（6）。预留数据包很小，优先级最高。它在单独的VC上传输，以确保高优先级传递。预留数据包包含一个值n，它是将要发送的数据包的数量。</p>
<p>​		一旦接收到预留包，接收器中的时间管理器将根据预留包中的n为发送方分配授权时间（$t_s$），并在回复包中返回相应的授权时间（7）。之后，时间管理器状态将正确更新。如果有另一个发送方发送的其他保留数据包到达此接收方，则时间管理器将返回给该保留数据包不早于$t_s  + n(1+ε)T_p$的开始时间，其中常数$T_p$是接收方接收所需的时间信道来接收消息，并且ε取决于控制分组的带宽开销。发送方的授权管理器将在收到授权数据包后开始计时，然后数据包调度程序将选择准备发送到其他发送队列中的，具有最小p的流（8）。然后，选定的流以推测性数据包的形式发送数据包（9）。如果目的地没有拥塞，将返回ACK数据包（10）。发送方继续发送推测性分组（11）。但是，如果端点在某个时刻过载，则推测包将被丢弃，路由器将生成NACK包并将其返回给发送方（12）。在接收到NACK之后，发送方将不会调度该流以发送保留数据包，而是选择具有最小p的另一个流并继续发送推测性数据包（13）。当预留流达到授予时间时，BFRP从SPECb状态进入正常状态，并且调度程序调度发送队列以发送普通数据包(14)(15)。在所有剩余的数据包都已发送后，BFRP从正常状态进入SPECa状态。所有传输将重复此过程。应当强调的是，为了最小化由控制操作引起的开销，所有预留分组，ACK，NACK和授权分组都是小的并且在单独的高优先级信道上发送。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>BFRP</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Endpoint Congestion Control for Fine-Grained Communication</title>
    <url>/yunruowuBlog/2020/07/29/Network-Endpoint-Congestion-Control-for-Fine-Grained-Communication/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>需要快速的响应时间和较低的开销</p>
<h4 id="Small-Message-Speculative-Reservation-Protocol">Small-Message Speculative Reservation Protocol</h4>
<p>SMSRP基于以下观察结果：如果端点没有拥塞，则无需为每个消息进行预留握手。与SRP协议会在每次消息传输之前急于启动保留的协议不同，SMSRP仅在通过推测性消息的丢弃在端点检测到拥塞之后才发布保留。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200730071219006.png" alt="image-20200730071219006"></p>
<p>图详细显示了SMSRP的操作。在此示例中，网络源正在将两个小消息M1和M2发送到可能拥塞的端点。每个消息足够小以适合单个网络数据包。消息准备好后，源将以推测模式立即将其发送。与SRP中的推测模式相似，推测消息使用低优先级VC，并且在发生拥塞时可以被网络丢弃。如果推测传输成功，例如在M1的肯定确认A1指示的情况下，则不需要保留。结果，当端点没有拥塞时，SMSRP几乎不会在网络中产生任何开销。</p>
<p>如果网络端点拥塞，则经过一段时间的排队延迟后，网络将丢弃推测性消息，就像消息M2一样。网络交换机将相应的NACK发送回源。当消息源收到NACK时，它将启动到目的地的预留Res2，以获取消息的重传时间。在从目的地接收到授权Gnt $t_2$之后，源将等待直到分配的传输时间$t_2$为止，然后再以非推测性模式重新传输M2。保证非推测性消息是无损的，并使用单独的更高优先级的VC来确保它们不会在推测性消息之后被阻塞。</p>
<p>除了在无拥塞的网络条件下具有较低的开销外，SMSRP的主要吸引力在于，它可以添加到已经实施SRP的网络中，而硬件改动很小。  SMSRP的投机丢弃策略和预约握手与SRP相同。唯一需要做的更改发生在源网络接口上：更改预约握手和推测性传输的顺序。</p>
<h3 id="Last-Hop-Reservation-Protocol">Last-Hop Reservation Protocol</h3>
<p>在网络不拥塞的情况下，以推测方式急切传输小消息可减少SMSRP的控制开销。但是，SMSRP的缺点是，当需要预约来解决拥塞时，控制消息必须到达端点处的预约调度程序。结果，预留握手消息与数据分组竞争弹出信道带宽。对于小消息，控制数据包消耗的一部分弹出带宽会极大地导致目标的额外超额预订，并可能导致更多的推测性消息丢失。直观上，弹出通道带宽是关键资源，仅应为数据包保留</p>
<p>LHRP通过将预留调度程序从端点移动到端点上游的最后一跳交换机来避免导致端点超额预订。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200730071945735.png" alt="image-20200730071945735"></p>
<p>LHRP的详细操作如图所示。像上一节中的示例一样，网络源正在向可能超额订阅的端点发送两个小消息。这两个消息都由源以推测方式立即发送。如果推测传输成功（如M1的情况），则不需要保留，并且协议不会产生额外的开销。</p>
<p>LHRP通过将预留调度程序从端点移动到端点上游的最后一跳交换机来避免导致端点超额预订。通过允许在交换机为连接到该交换机的端点的服务保留请求提供服务时，我们消除了弹出通道的控制开销。在最后一跳交换机处处理预留也打开了其他优化机会。对于小消息，可以在数据消息本身以及与任何丢弃关联的NACK上piggy带保留和授权信息，而不是发送用于保留握手的单独控制包。此保留搭载优化对于SMSRP没有用，因为到达端点处的保留调度程序的数据包不再需要保留。</p>
<p>如果端点被超额预订，则拥塞将首先在最后一跳交换机处发生。就像M2一样，推测消息可能会在最后一跳交换机上遇到较大的排队延迟。与SRP和SMSRP不同，LHRP推测性数据包仅在最后一跳交换机处合格。我们修改了网络交换机，以跟踪与交换机相连的每个端点排队的数据包数量。当端点的排队级别超过阈值时，交换机将开始丢弃发往该端点的推测消息。排队阈值的目的是动态地维持推测丢弃率，以使拥塞的推测消息不会备份到相邻的交换机中，从而在网络的其余部分中造成树饱和。</p>
<p>当最后一跳交换机丢弃推测消息时，预留调度程序还为该消息分配了重传时间，该重传时间随NACK ，N2t2返回。当源节点接收到NACK时，它也接收到重发时间t2。然后，源节点以保证无损传输的非推测性模式在时间t2重新传输M2。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>SMSRP</tag>
        <tag>LHRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Congestion Avoidance Through Speculative Reservation</title>
    <url>/yunruowuBlog/2020/07/29/Network-Congestion-Avoidance-Through-Speculative-Reservation/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><span id="more"></span>
<p>SRP，Speculative Reservation Protocol，投机预约协议。</p>
<p>协议通过以下方式提高了拥塞控制的最新水平：</p>
<ul>
<li>
<p>SRP防止拥塞的形成，而不是在拥塞发生后对其进行反应。</p>
</li>
<li>
<p>SRP具有非常快速的瞬态响应，与易发生拥塞的流量的发生几乎立即做出反应，相比之下，像ECN这样的数据包标记协议需要数百微秒的响应时间。</p>
</li>
<li>
<p>SRP的开销很低，可以与网络媲美，而不会对良性流量进行拥塞控制。</p>
</li>
<li>
<p>SRP提高了争夺网络热点的来源之间的公平性。</p>
<p>阻塞案例：拥塞的扩散影响。</p>
</li>
</ul>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729205521681.png" alt="image-20200729205521681"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729205638729.png" alt="image-20200729205638729"></p>
<p>解决拥塞的办法：</p>
<ol>
<li>
<p>ECN</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729205721994.png" alt="image-20200729205721994"></p>
</li>
</ol>
<p>启用ECN的路由器通过监视其输入或输出缓冲区的占用来检测拥塞。当缓冲区的占用率超过某个阈值时，路由器会标记通过缓冲区的数据包的ECN字段（在某些系统中，标记操作仅在标识为拥塞根源的端口上进行）。当标记的数据包到达其目的地时，ECN字段将使用拥塞通知数据包返回到数据包的源。发送方收到消息后会减缓发送速率，来缓解拥塞。在没有拥塞通知的情况下，发送方将逐渐提高其注入速率，以充分利用未拥塞网络的带宽。</p>
<ol start="2">
<li>
<p>Speculative Reservation Protocol</p>
<p>预防拥塞。</p>
<p>传输信息，需要一个预约许可的握手</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729210250143.png" alt="image-20200729210250143"></p>
</li>
</ol>
<p>a)是正常运行的时序图，在这种情况下，网络中不存在热点。发送方S通过首先发出预留数据包R来启动到目的地D的通信。此预留数据包很小，具有较高的网络优先级，并且在单独的控制虚拟通道（VC）[8]上传输以保证快速传递。预留中携带预留大小n，它指示源打算发送的数据包数量。选择大小以分摊多个数据包之间的SRP开销，同时提供对多个流的公平性和响应性。</p>
<p>发出预约后，S开始以投机地方式将数据包P1和P2发送至D。这些推测数据包在低优先级VC上传输，并且等待时间（TTW）有限。如果投机性数据包在网络内部的总累积排队时间大于其TTW，则路由器会将其丢弃。我们通过在到达路由器输入端口时对数据包打上时间戳，然后在数据包位于输入缓冲区的开头时对此时间戳执行检查来实现TTW跟踪。由于投机数据包的性质不可靠，因此需要ack以通知源是否已成功传送或丢弃了它们。</p>
<p>一旦预约数据包到达 <em>D</em>，目的地将根据其当前预约时间表返回一个携带发送起始时间的小型授权数据包 <em>G</em>($T_s$)（Grant）。另外，<em>D</em> 更新其预约时间表，它给下一个源的发送起始时间不会早于 <em>$T_s$</em> + <em>n</em>(1 + <em>ϵ</em>)$τ_p$。其中，常数 $τ_p$ 是目的地接收单个数据包的时间，<em>ϵ</em> 表示控制数据包（如 reservation、grant、ACK 等）的带宽开销。所有发送源都必须通过如此预约的方式想目的地进行预约并获得开始发送时间。</p>
<p>当 <em>S</em> 收到授权数据包时，它停止向 <em>D</em> 发送投机数据包。到达时间 $T_s$ 之后，<em>S</em> 以非投机数据包的模式（即正常数据包）恢复向 <em>D</em> 的传输，从图2.1（a）中的示例 <em>P</em>3 开始。正常数据包不能被丢弃，并且不需要 ACK。在 <em>S</em> 成功发送完所有<em>n</em> 个数据包之后，未来 <em>S</em> 和 <em>D</em> 之间的任何传输都将重复此预约过程。</p>
<p>图b显示了一个时序图，说明了在拥挤的网络中且节点 <em>D</em> 处有热点时的 SRP 执行过程。最初，<em>S</em> 发送预约数据包和投机数据包的过程与上述示例相同，具有较高网络优先级的预约数据包很快到达 <em>D</em>。但是，投机数据包在 <em>D</em> 附近遇到了较大的排队延迟。当排队延迟超过其 TTW 时，投机数据包被路由器丢弃，并且路由器返回 NACK 数据包给 <em>S</em>。当 <em>S</em> 收到 NACK 数据包时，它将停止向目标传输投机数据包，而后以正常数据包的模式在$T_s$处恢复数据包传输，从之前被丢弃的的数据包开始。</p>
<p>由于丢弃协议，每个预约内乱序包的到达都是可能的。在图b的情况下，如果NACK数据包在ts之后返回，则重新发送的数据包将以乱序到达D。这个可以通过牺牲带宽来避免这个问题。方法是通过修改协议，使得在达到ts之后，S重新传输所有未完成的推测性数据包。这样可以确保有序的数据包到达，但要以可能的重复数据包到达D为代价。</p>
<p>SRP 可以减少延迟和带宽开销。发送投机数据包可以减少 SRP 的等待时间开销。在中低网络负载下，大多数投机数据包能够到达目的地，并使得 SRP 的延迟与基准网络的延迟相同。为了防止超短流预约开销过大和长流长时间垄断热点目标，SRP 设置了两个阈值：<em>$n_{min}$</em> 和 $n_{max}$。当流长度 n &lt; $n_{min}$，绕过 SRP协议直接发送；当流长度 n &gt; $n_{max}$ 时，则将长流按照$n_{max}$进行分段，分为多个长度为的$n_{max}$流，SRP 将他们视为不同的流，分别进行预约。</p>
<p>在高网络负载下，由于增加的排队延迟，推测性数据包被更频繁地丢弃。丢弃推测性数据包会浪费网络带宽，并且是高负载时开销的主要来源。但是，推测性数据包永远不会减少可用于非推测性数据包的带宽，因为它们是在单独的较低优先级虚拟通道上发送的。可以通过调整推测的TTW和预留粒度来控制推测的丢弃开销。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>SRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch7</title>
    <url>/yunruowuBlog/2020/07/29/Interconnection-Networks-ch7/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="CHAPTER-7-Slicing-and-Dicing">CHAPTER 7 Slicing and Dicing</h2>
<p>我们首先看concentrators and distributors。集中器将多个终端节点的流量组合到单个网络通道上。当来自任何终端的流量很小以充分利用网络通道时，可以使用它们。它们还可以有效地组合来自许多突发性终端的流量。当峰值流量与平均流量之比较大时，使用集中器可降低序列化延迟，并降低网络成本。</p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch6</title>
    <url>/yunruowuBlog/2020/07/28/Interconnection-Networks-ch6/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Non-Blocking-Networks">Non-Blocking Networks</h2>
<span id="more"></span>
<p>如果网络可以处理输入和输出排列的所有电路请求，则称该网络为非阻塞网络。即，可以形成从每个输入到其选择的输出的专用路径，而没有任何冲突（共享通道）。相反，如果网络无法处理所有此类电路请求而没有冲突，则它就是阻塞网络.</p>
<p>两种类型的非阻塞网络。strictly non-blocking, rearrangeably non-blocking</p>
<p>首先，如果可以每次一个电路递增地设置任何排列，而无需重新路由（或重新排列）任何已设置的电路，则网络严格不阻塞。如果可以将任何未使用的输入连接到任何未使用的输出，而无需更改任何其他流量所采用的路径，则说明网络完全是无阻塞的。</p>
<p>相反，如果网络可以路由电路进行任意排列，则网络可重新排列为非阻塞（或简单地可重新排列），但是排列的渐进式构造可能需要重新布置一些早期电路，以允许以后建立电路。可重新排列的网络可以将任何未连接的输入连接到任何未连接的输出，但是可能需要重新路由一些不相关的流量才能建立连接。</p>
<h3 id="6-1-Non-Blocking-vs-Non-Interfering-Networks">6.1 Non-Blocking vs. Non-Interfering Networks</h3>
<p>分组交换网络中，资源分配好之后就不会互相影响。</p>
<p>实际上无阻塞的网络就是为了实现无干扰的网络。</p>
<h3 id="6-2-Crossbar-Networks">6.2 Crossbar Networks</h3>
<p>一个n×m交叉开关或交叉点开关将n个输入直接连接到m个输出，没有中间级。</p>
<p>m=n,square</p>
<p>m&gt;n||m&lt;n,rectangular</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728123737611.png" alt="image-20200728123737611"></p>
<p>在输入线与输出线交叉的每个点（即，在每个交叉点），开关都可以选择将输入线连接到输出线。为了正确操作，每个输出最多必须连接到一个输入。但是，输入可以连接到多个输出.</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728124036608.png" alt="image-20200728124036608"></p>
<p>今天，大多数交叉开关都是使用数字逻辑实现的，其结构如图所示。 n条输入线中的每条连接到m  n：1多路复用器的一个输入。多路复用器的输出驱动m个输出端口。多路复用器可以通过驱动输出线的三态门或线或门实现。</p>
<p>简化图：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728124207488.png" alt="image-20200728124207488"></p>
<p>纵横开关显然对于单播和多播流量都严格不阻塞。可以通过开关不同开关门。</p>
<p>建造其他无阻塞网络，原因是成本和可伸缩性。</p>
<p>成本都是$N^2$的。</p>
<p>下图显示了如何使用2×2的n×n交叉开关阵列构造2n×2n交叉开关，从小型交叉开关构建大型交叉开关的成本也是二次方。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728125956171.png" alt="image-20200728125956171"></p>
<h3 id="6-3-Clos-Networks">6.3 Clos Networks</h3>
<h4 id="6-3-1-Structure-and-Properties-of-Clos-Networks">6.3.1 Structure and Properties of Clos Networks</h4>
<p>Clos网络是一个三阶段网络，其中每个阶段都由许多纵横开关组成。对称Clos的特征是三元组（m，n，r），其中m是中级开关的数量，n是每个输入（输出）开关上的输入（输出）端口的数量，r是输入和输出开关的数量。此处输入和输出都一样为r和n.对于不一样的网络可以设为$(m,n_0,n_1,r_0,r_1)$</p>
<p>中级交换机，到每个输入和输出交换机都有相应的链路。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728132321853.png" alt="image-20200728132321853"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728132403217.png" alt="image-20200728132403217"></p>
<p>在引用Clos网络的输入和输出端口时，我们将交换机s的端口p表示为s.p。</p>
<h4 id="6-3-2-Unicast-Routing-on-Strictly-Non-Blocking-Clos-Networks">6.3.2 Unicast Routing on Strictly Non-Blocking Clos Networks</h4>
<p>定理：A Clos network is strictly non-blocking for unicast traffic iff m ≥ 2n − 1.</p>
<p>要将单播呼叫从a.i路由到b.j，可通过将a不使用的交换机列表与b不使用的交换机列表相交来找到中间级交换机。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729082144535.png" alt="image-20200729082144535"></p>
<p>如下图，电路从输入1.1（1）路由到输出3.3（9）。其中虚线为已经本占用的线路。最终选择为加粗的线。一个完整的排列{5、7、11、6、12、1、8、10、3、2、9、4}。也就是说，输入1（1.1）路由到输出5（2.2），输入2（1.2）路由到输出7（3.1），依此类推。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729081302659.png" alt="image-20200729081302659"></p>
<p>假设按{9,6,7,8,3,12,10,5,1,11,2,4}的顺序应用呼叫。</p>
<p>显示了在（5,3,4）Clos网络上路由此呼叫集的过程。该表的每一行对应于路由过程中的一个步骤。该表的每一行对应于路由过程中的一个步骤。前三列显示呼叫来自的输入交换机（进入），呼叫去向的输出交换机（离开）和分配给呼叫的中间交换机（中间）。其余八列给出位向量，显示哪些中间交换机不受每个输入和输出开关的影响。</p>
<p>第一个呼叫为9（3，3），查排列集合，输入交换机为3，输出应该为3，交换机为输出switch1。并且由于第一个调用没有阻塞的路径，因此将其分配给中间交换机1.所以将输入交换机的路径3到中间交换机1忙（输入空闲3 = 01111），从中间交换机1到输出交换机1的路径忙（输出空闲1 = 01111）。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729083340014.png" alt="image-20200729083340014"></p>
<h4 id="6-3-3-Unicast-Routing-on-Rearrangeable-Clos-Networks">6.3.3 Unicast Routing on Rearrangeable Clos Networks</h4>
<p>定理：A Clos network with m ≥ n is rearrangeable.</p>
<p>显示了一种在可重排的非阻塞网络上路由一组呼叫的算法。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729093630509.png" alt="image-20200729093630509"></p>
<p>定理：使用循环算法建立单个呼叫需要最多重新安排2r-2个其他呼叫。</p>
<h4 id="6-3-4-Routing-Clos-Networks-Using-Matrix-Decomposition">6.3.4 Routing Clos Networks Using Matrix Decomposition</h4>
<p>利用矩阵来路由网络。</p>
<p>矩阵R，每一个元素$X_{ij}$表示从输入交换机i到输出交换机j的呼叫次数。</p>
<p>例子：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729094145622.png" alt="image-20200729094145622">该矩阵可以分解为一组m个正矩阵的总和，其中每一行和每一列的总和最多为1。该组中的每个矩阵对应于中间级开关的设置。<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729094247379.png" alt="image-20200729094247379"></p>
<p>矩阵分解可用于路由单播或多播流量，并可应用于可重排和严格无阻塞的Clos网络。</p>
<h4 id="6-3-5-Multicast-Routing-on-Clos-Networks">6.3.5 Multicast Routing on Clos Networks</h4>
<p>定义：多播呼叫集合$C={c_1,c_2,……,C_n}$，其中每个多播呼叫$c_i=(a_i,、{b_{i1},b_{i2}……,b_{if}})$，输入端口$a_i$，$f$个输出端口$b_{i1},b_{i2}……,b_{if}$，$f$为扇出。</p>
<p>例子：考虑多播调用集（只考虑交换机号）：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729095529689.png" alt=""></p>
<p>向量表示：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729095559587.png" alt="image-20200729095559587"></p>
<p>如果$c_i \bigwedge c_j=0$ ,$c_i,c_j$可以映射到相同的中间阶段。</p>
<p>上图实例不能实现，所以需要扇出。</p>
<p>通过在输入开关中执行扇出，可以将输出集分配到多个中间阶段。</p>
<p>k-way输入扇出，就是将$c_i={a,B}$分成k个呼叫，分别为：</p>
<p>$c_{i1}=(a,B_1),…,c_{ik}=(a,B_k),\bigcup_{j=1}^kB_j=B$</p>
<p>将上面的集合分解如下：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729102606396.png" alt="image-20200729102606396"></p>
<p>中间交换机的使用：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103143490.png" alt="image-20200729103143490"></p>
<p>最终的路由线路：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729102709756.png" alt="image-20200729102709756"></p>
<p>知道中间交换机的数理，扇出的限制：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103305798.png" alt="image-20200729103305798"></p>
<p>知道了扇出，中间交换机的要求：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103331640.png" alt="image-20200729103331640"></p>
<p>算法流程：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103048886.png" alt="image-20200729103048886"></p>
<h3 id="6-4-Beneˇ-s-Networks">6.4 Beneˇ s Networks</h3>
<p>由2×2交换机构成的Clos网络也称为Beneˇ网络</p>
<h3 id="6-5-Sorting-Networks">6.5 Sorting Networks</h3>
<p>N输入分类网络在其N个输入端子上接受一组用唯一分类键标记的N条记录，并在其N个输出端子上按键顺序输出这些记录。</p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch5-1</title>
    <url>/yunruowuBlog/2020/07/20/Interconnection-Networks-ch5-1/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Torus-Network-more">Torus Network<span id="more"></span></h2>
<h3 id="5-3-Building-Mesh-and-T-orus-Networks">5.3 Building Mesh and T orus Networks</h3>
<p>将网络的抽象节点映射到物理空间中的实际位置，不同的封装技术可以实现一维的，二维的等映射。</p>
<ul>
<li>
<p>最简单的方式就是$p_i=a_i$，物理位置和逻辑地址相同，每个节点之间距离相同。</p>
</li>
<li>
<p>但是这将导致$p_k和p_0$之间距离过大，如此长的信道可能导致过多的等待时间或需要较慢的信令速率。所以提出折叠的环形网络来解决问题。一种环形网络的折叠入下：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727131524647.png" alt="image-20200727131524647"></p>
<p>消灭了 最长的网络，但是牺牲了以相邻节点距离短的优点。</p>
</li>
</ul>
<p>最终的物理放置图对比：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727131557787.png" alt="image-20200727131557787"></p>
<p>通常，通过以折叠顺序组合k个折叠的k-ary n-1cube来构造折叠的k-ary n-cube</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727131614133.png" alt="image-20200727131614133"></p>
<p>当逻辑维数超过物理维数时，必须将几个逻辑维映射到每个物理维中。如果物理维数为q，则直接映射是将逻辑维的q折叠为每个物理维。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727132711914.png" alt="image-20200727132711914"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727132749954.png" alt="image-20200727132749954"></p>
<h3 id="Express-Cubes">Express Cubes</h3>
<p>原因：环状网络通道短，$t_c$时间通常由$t_r$决定，与直径小的网络相比，导致更多的$T_H$。可以增加维度减小直径。但是会导致$T_s$增大。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728114113438.png" alt="image-20200728114113438"></p>
<p>所以Express sube出现了。就是添加了几个快速通道。通过路由必须在快速通道上的某个维度上经过较长距离的数据包，报头等待时间可以减少到接近信道等待时间限制。因为可以控制快速通道的数量以匹配网络的二等分宽度，所以可以在不增加序列化延迟的情况下实现报头延迟的减少。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728114625185.png" alt="image-20200728114625185"></p>
<p>每个维度，每隔i个节点设置一个express channel。</p>
<p>普通网络中，在j维度有$H_j$跳，那么在快速立方体中，跳数为：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728115227480.png" alt="image-20200728115227480"></p>
<p>对于长的维度，选择$i = \frac{t_r}{t_c}$,来平衡式中的两项，短的维度，选择$i=\sqrt{H_min}$</p>
<p>分层的快速cube:</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728120044122.png" alt="image-20200728120044122"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728120023536.png" alt="image-20200728120023536"></p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-10</title>
    <url>/yunruowuBlog/2020/07/20/Interconnection-Networks-ch5/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="CH4-Torus-Networks-more">CH4 Torus Networks<span id="more"></span></h2>
<p>圆环和网状网络（ k-ary n-cubes）在规则的n维网格中打包$N=k^n$个节点，每个维中都有k个节点，并且最近邻之间有通道。</p>
<p>优点：</p>
<ul>
<li>这种规则的物理布置与包装约束非常匹配。</li>
<li>具有良好的路径分集，即使在排列流量上也可以具有良好的负载平衡。</li>
<li>通道是双向的,可以利用双向信令，从而更有效地利用引脚和电线。</li>
</ul>
<p>缺点：</p>
<ul>
<li>它们的跳数比对数网络大；</li>
<li>增加了网络的引脚成本。</li>
</ul>
<h3 id="4-1The-Structure-of-T-orus-Networks">4.1The Structure of T orus Networks</h3>
<ul>
<li>$N=k^n$个节点</li>
<li>每个维中都有k个节点</li>
<li>每个节点同时充当网络的输入端，输出端和交换节点</li>
<li>每个节点被分配一个n-digit radix-k地址{an−1,…,a0}</li>
<li>通过一对通道（每个方向一个）连接到地址相差±1（mod k）的所有节点。只需一个地址位。</li>
<li>每个节点每个维度需要2个通道，总共2nN个通道。</li>
</ul>
<p>规则的（所有节点的度数相同），并且也是边缘对称的。<br>
网状网络和环状网络的区别：</p>
<ol>
<li>网状网络 在每个方向上都省略了从地址ak−1到地址a0的连接</li>
<li>网状网络具有相同的节点度，但是对等通道的数目是具有相同基数和尺寸的圆环的一半</li>
<li>放弃了圆环的边缘对称性，对中央通道的需求可能会大大高于对边缘通道的需求</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200720140511291.png" alt="image-20200720140511291"></p>
<p>环面网络的每个维度都可以具有不同的基数。例如，下图说明了一个2,3,4-ary 3-mesh，其y方向的基数为2<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200720141524634.png" alt="image-20200720141524634"></p>
<h3 id="5-2-performance">5.2 performance</h3>
<p>throughput, latency, and path diversity.</p>
<h4 id="5-2-1-Throughput">5.2.1 Throughput</h4>
<p>在两层封装模型中，吞吐量受引脚带宽或二等分带宽限制。我们首先考虑对分限制并计算网络的信道对分为:</p>
<p>k为偶数</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161336861.png" alt="image-20200722161336861"></p>
<p>由于<strong>圆环</strong>既是节点对称的，又是边缘对称的，从平分信道负载中确定均匀流量下的信道负载。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161423232.png" alt="image-20200722161423232"></p>
<p>由于<strong>圆环</strong>的边缘对称性：</p>
<p>​					<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161456946.png" alt="image-20200722161456946"></p>
<p>由于网格是不对称的，由于上面用于圆环的跳数，它无法达到下限。相反，在统一流量下<strong>网格</strong>的信道负载为<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161558619.png" alt="image-20200722161558619"></p>
<p>对于最坏情况的流量，所有流量都会越过平分线，并且通道负载会加倍。</p>
<p>​							<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161807795.png" alt="image-20200722161807795"></p>
<p>每个节点四个信道：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161854710.png" alt="image-20200722161854710"></p>
<p><strong>圆环</strong>的最大通道宽度<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161920581.png" alt="image-20200722161920581"></p>
<p><strong>网格</strong>的：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161938362.png" alt="image-20200722161938362"></p>
<p>计算均匀负载下的吞吐量：</p>
<p>​	<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161959797.png" alt="image-20200722161959797"></p>
<h4 id="5-2-2-Latency">5.2.2 Latency</h4>
<p><strong>环形</strong>网络的延迟在很大程度上取决于尺寸。在低维度上，延迟是由高跳数决定的。在维度的极端情况下，串行延迟由于通道宽度w的狭窄而占主导地位。最佳等待时间通常发生在较低的中间维度。</p>
<p><strong>环型</strong>网络的串行化等待时间</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722162116800.png" alt="image-20200722162116800"></p>
<p><strong>网格</strong>网络</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722162144750.png" alt="image-20200722162144750"></p>
<p><strong>圆环</strong>网络中的平均最小跳数是通过对所有节点对上的最短距离求平均来确定的，从而得出<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722162239212.png" alt="image-20200722162239212"></p>
<p><strong>网格网络</strong>：在均匀的流量和偶数基数的情况下，数据包平均在n个维度中的每个维度上四分之一地传播，即$\frac{k}{4}$跳。因此偶数k，跳数为$\frac{nk}{4}$,对于奇数k，平均距离包括一个小的附加系数。</p>
<p>​	<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722163218184.png" alt="image-20200722163218184"></p>
<h4 id="5-2-3-Path-Diversity">5.2.3 Path Diversity</h4>
<p>路径数量，我们只考虑最短路径，并且所有路径在每个维度（单向路线）都采用相同的方向。</p>
<ul>
<li>
<p>一维网络，只有一个路径</p>
</li>
<li>
<p>二维网络，考虑节点a，b，如果在x方向，二者被$\Delta x$跳分割，y方向上，$\Delta y$跳，那么路径数量为：</p>
<p>$$<br>
\begin{vmatrix}<br>
R_{ab}<br>
\end{vmatrix}=\binom{\Delta_x+\Delta_y}{\Delta_x}<br>
$$</p>
</li>
<li>
<p>三维网络，增加z的维度</p>
</li>
</ul>
<p>$$<br>
\begin{vmatrix}<br>
R_{ab}<br>
\end{vmatrix}=\binom{\Delta_x+\Delta_y+\Delta_z}{\Delta_x}\binom{\Delta_y+\Delta_y}{\Delta_y}=\frac{(\Delta_x+\Delta_y+\Delta_z)!}{\Delta_x!\Delta_y!\Delta_z!}<br>
$$</p>
<ul>
<li>n维：从a到b的最小单向路线的总数为<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722181511667.png" alt="image-20200722181511667"></li>
</ul>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch4.md</title>
    <url>/yunruowuBlog/2020/07/19/Interconnection-Networks-ch3/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Butterfly-Networks">Butterfly Networks</h2>
<p>俩个主要的拓扑家族</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719101415173.png" alt="image-20200719101415173"></p>
<p>蝶形网络是最基本的间接网络。</p>
<p>对于交换机度数为$\delta = 2k, H = \log_kN +1$的N个节点的网络，BN拥有最小的直径。</p>
<p>缺点：</p>
<ol>
<li>no path diversity: there is exactly one route from each source node to each destination node.</li>
<li>the butterfly cannot be realized without long wires that must traverse at least half the diameter of the machine.</li>
</ol>
<h3 id="4-1The-Structure-of-Butterfly-Networks">4.1The Structure of Butterfly Networks</h3>
<p>k-ary n-fly</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719114542950.png" alt="image-20200719114542950"></p>
<p>2-ary 4-fly</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719114551161.png" alt="image-20200719114551161"></p>
<p>​	k-ary n-fly网络由$k^n$个源终端节点，n个阶段, 每个阶段$k^{n-1}$ k×k crossbar switch节点以及最后$k^n$目的地终端节点组成。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719115531276.png" alt="image-20200719115531276"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719144626828.png" alt="	"></p>
<p>​	关于网络中报文的走向问题。</p>
<p>根据每一个发出报文的终端编号可以决定不同路由路径。我们使用 n-digit radix-k number, ${d_{n−1},d_{n−2},…,d_0}$. 来表示每一条路径。</p>
<p>对于k-ary n-fly网络。每一级有$k^{n-1}$个路由器，所以需要有n-1比特来进行选择。前n−1个数字${d_{n−1},d_{n−2},…,d_1}$.标识交换机，最后一个数字$d_0$标识交换机上的终端也就是决定了最终出口的选择。具体的使用如下：</p>
<ol>
<li>​	从输入节点开始，比如9这个输入节点，对应的二进制为1001；前三位为100，那么第0级交换机选择为4号。</li>
<li>此时，d_0可以随机选择为0或者1，这是再将d_0和d_3进行交换，可以得到前三位000或者100，这样第1级交换机可以选择为1，0或者1，4.</li>
<li>依次类推，最好已经决定输出的终端。</li>
</ol>
<p>具体来说：第一级设置dn−1，第二级设置dn−2，依此类推，最后一级设置d0已处于正确位置，</p>
<h3 id="4-2-Isomorphic-Butterflies（同构）">4.2 Isomorphic Butterflies（同构）</h3>
<p>网络K，其节点和信道集定义：$K=(N^*，C)$。</p>
<p>如果$K_1=(N_1,C_1),K_2=(N_2,C_2)$是同构的 ：</p>
<p>​		 顶点中存在一个置换$\pi$，对于边${u,v}\ \in C_1$存在${\pi(u),\pi(v)} \in C_2$</p>
<h3 id="4-3-Performance-and-Packaging-Cost">4.3 Performance and Packaging Cost</h3>
<p>​	对于k-ary,n-fly网络：</p>
<p>​	交换节点的度$\delta _{fly}= 2k$</p>
<p>​	信道二等分(N是偶数)$B_{C,fly } = \frac{N}{2}$</p>
<p>​										<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719160533316.png" alt="image-20200719160533316"></p>
<p>​	信道负载</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719160543008.png" alt="信道负载"></p>
<p>计算出两层包装层次结构下蝶形网络的通道宽度：	<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719172821869.png" alt="image-20200719172821869"></p>
<p>在均匀负载且γ= 1的情况下，理想吞吐量：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719173001335.png" alt="image-20200719173001335"></p>
<p>蝶形网络的目标：</p>
<p>​	目标是首先获得最大的吞吐量，其次是最大程度地减少消息延迟。</p>
<p>为此选择最大的K</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719173225620.png" alt="image-20200719173225620"></p>
<p>这个k值给出了最小的直径，这使得延迟的H部分最小化，同时使信道带宽最大化。这也最大限度地提高了理想的吞吐量并最小化了序列化延迟。任何小于此值的k都不会提高吞吐量，只会由于额外的跃点计数而增加延迟.</p>
<h3 id="4-4-Path-Diversity-and-Extra-Stages">4.4 Path Diversity and Extra Stages</h3>
<p><img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200720071823533.png" alt="image-20200720071823533">没有路径多样性</p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection_Networks-ch2</title>
    <url>/yunruowuBlog/2020/07/09/Interconnection-Networks-ch2/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="CH2-A-Simple-Interconnection-Network">CH2 A Simple Interconnection Network</h2>
<h3 id="2-1网络规范和限制">2.1网络规范和限制</h3>
<p>​	有关网络设备的规范和约束，规范比如端口数量，传输速率。约束有关带宽，消耗。</p>
<h3 id="2-2拓扑">2.2拓扑</h3>
<p>​	蝶形网络拓扑</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200713072010.png" alt="image-20200709110727663"></p>
<p>​	speedup 加速比 网络总输入带宽与网络理想容量的比值。也被称为蝶形基数。</p>
<h3 id="2-5路由器">2.5路由器</h3>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200713072031.png" alt="image-20200713071446699"></p>
<p>路由器的数据路径包括四个18位输入寄存器，四个18位4：1多路复用器，四个移位器（用于移位标头phits的路由字段）和四个18位输出寄存器。数据路径由144位寄存器和大约650个门（等效于2个输入NAND）组成。</p>
<h4 id="Allocator">Allocator</h4>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200713072037.png" alt="image-20200713071629935"></p>
<p>分配器由四个几乎相同的位片组成，每个位片分为三个部分：解码，仲裁和保持。</p>
<p>在解码部分中，对每个输入phit的高四位进行解码。每个解码器生成两个信号。如果输入i是一个head phit并且路由字段的高两位与输出端口号匹配，则信号i请求为true。此信号指示输入phit请求使用此头phit开始使用输出端口路由数据包。如果输入i上的点是有效载荷点，则解码器还会生成信号有效载荷i。分配器的保持逻辑使用此信号在数据包持续时间内保持信道（只要有效载荷位在所选输入端口上）</p>
<h3 id="性能分析">性能分析</h3>
<p>通过三种方法来判断互连网络：成本，延迟和吞吐量。延迟和吞吐量都是性能指标：延迟是数据包穿越网络所花费的时间，吞吐量是网络可以从输入传输到输出的每秒位数。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715163552820.png" alt="image-20200715163552820"></p>
<p>对加权延迟求和，我们将平均延迟计算为</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715164709817.png" alt="image-20200715164709817"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715164655766.png" alt="image-20200715164655766"></p>
<p>延迟和吞吐率的曲线</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715165107829.png" alt="image-20200715165107829"></p>
<p>相对延迟是简单网络的所提供流量（注入速率）的函数。实线显示了本文中介绍的简单模型，而虚线则包含了额外的排队延迟。</p>
<h2 id="CH3-T-opology-Basics">CH3 T opology Basics</h2>
<ol>
<li>重要性</li>
</ol>
<ul>
<li>是设计第一步，决定了策略路由和流控制方法；</li>
<li>拓扑不仅指定网络的类型（例如，蝶形），还指定详细信息，例如交换机的基数，级数以及宽度和比特率每个频道</li>
</ul>
<ol start="2">
<li>考虑的东西</li>
</ol>
<ul>
<li>端口数量以及每个端口的带宽和占空比的驱动</li>
<li>每个芯片和板可用的引脚，线密度，可用的信号速率以及驱动器的驱动</li>
<li>成本和性能。性能包括带宽和延迟，由拓扑以外的因素决定，例如，流量控制，路由策略和流量模式。</li>
</ul>
<ol start="3">
<li>评价</li>
</ol>
<ul>
<li>二等分带宽，信道负载和路径延迟之类的措施，这些措施反映了拓扑对性能的影响。</li>
</ul>
<ol start="4">
<li>设计的陷阱</li>
</ol>
<p>​	尝试使网络的拓扑结构与当前问题的数据通信相匹配。</p>
<p>​	原因：专用网络通常不是好主意，问题中的动态负载不平衡，或者问题大小与计算机大小之间不匹配，因此此类网络上的负载通常平衡不佳。如果重新分配数据和线程以平衡负载，则问题和网络之间的匹配将丢失。特定问题的网络通常无法很好地映射到可用的封装技术，需要较长的导线或较高的节点度。最后，这样的网络是不灵活的。如果算法更改为使用其他通信模式，则无法轻松更改网络。</p>
<ol start="5">
<li>拓扑案例</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715175324694.png" alt="image-20200715175324694"></p>
<h3 id="3-1-Nomenclature（命名法）">3.1 Nomenclature（命名法）</h3>
<h4 id="3-1-1-Channels-and-Nodes">3.1.1 Channels and Nodes</h4>
<p>​	互连网络的拓扑结构由一组节点N *指定，该节点N *通过一组通道C连接。消息在一组终端节点N（其中N≥N *）中发起和终止。</p>
<p>​	拓扑有向图</p>
<p>channel c = (x, y) ∈ C。x是源节点$sc$，y是目的节点$dc$</p>
<p>信道特征：</p>
<ul>
<li>width($w_c$,$w_{xy}$)   包含的并行信号数</li>
<li>frequency, $f_c$or $f_{xy}$	每个信号上的比特传输速率</li>
<li>latency, $t_c$or$ t_{xy}$	从x到y所需的时间。与传播速度和信道的物理长度直接相关$l_c = v<em>t_c$.信道带宽$b_c=w_c</em>f_c$</li>
</ul>
<h4 id="3-1-2-Direct-and-Indirect-Networks">3.1.2 Direct and Indirect Networks</h4>
<h4 id="3-1-3-Cuts-and-Bisections">3.1.3 Cuts and Bisections</h4>
<p>​	网络切割点$C(N_1,N_2)$是一组通道，它将所有节点N *的集合划分为两个不相交的集合$N_1$和$N_2$</p>
<p>$C(N_1,N_2)$每个元素都是一个通道，其源位于N1，目标位于N2，反之亦然。cut的带宽：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716092425525.png" alt="image-20200716092425525"></p>
<p>​	Bisection二等分，就网络几乎分为一半的cut满足$N_2\le N_1 \le N_2+1$</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093016194.png" alt="image-20200716093016194"></p>
<p>​	有最小信道数</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093153743.png" alt="image-20200716093153743"></p>
<h4 id="3-1-4-Paths">3.1.4 Paths</h4>
<p>信道的有序集合<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093402879.png" alt="image-20200716093402879">$d_{c_i} = s_{c_{i+1}}$</p>
<p>minimal path 节点x到节点y的跳数最小的路径</p>
<p>$R_{xy}$所有x到y的最小路径的集合</p>
<p>$H(x,y)$是最小路径的节点跳数</p>
<p>网络的直径。所有节点对中$R_{xy}$	的最大值</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093858198.png" alt="image-20200716093858198"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716094313632.png" alt="image-20200716094313632"></p>
<p>平均最小跳数</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716094621734.png" alt="image-20200716094621734"></p>
<h4 id="3-1-5-对称性">3.1.5 对称性</h4>
<p>​	节点对称，边对称</p>
<h3 id="3-2-交通模式">3.2 交通模式</h3>
<p>​	考虑互连网络中消息的空间分布是很有用的。利用流量矩阵$\wedge$. 每个矩阵元素$\lambda_{s,d}$给出从节点s发送到节点d的流量份额</p>
<p>​	评估互连网络的常见静态流量模式	<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716100035143.png" alt="image-20200716100035143"></p>
<p>​	随机流量：网络评估中最常用的流量模式是随机流量，其中每个源均可能发送到每个目的地。随机流量非常有益，因为通过使流量均匀分布，即使是通常负载平衡非常差的拓扑和路由算法，它也可以平衡负载。仅使用随机流量进行评估时，某些非常差的拓扑和路由算法看起来非常好。</p>
<p>​	permutation（置换流量）：为了强调拓扑或路由算法，我们通常使用置换流量，其中每个源s将其所有流量发送到单个目标d  =π（s）。用于排列的流量矩阵是一个排列矩阵（其中每一行和每一列包含一个条目，所有其他条目均为零。由于它们将负载集中在单独的源－目的地对上，因此排列会强调拓扑和路由算法的负载平衡。</p>
<h3 id="3-3performance">3.3performance</h3>
<h4 id="3-3-1Throughput-and-Maximum-Channel-Load">3.3.1Throughput and Maximum Channel Load</h4>
<p>​	网络的吞吐量是网络每个输入端口接受的数据速率（以比特/秒为单位）。吞吐量是整个网络的属性，并且取决于路由和流量控制（如我们在第2章中所看到的）以及拓扑。</p>
<p>​	信道负载：$\gamma_c$定义为通道c所需带宽与输入端口带宽之比。等效地，该比率是如果每个输入根据给定的流量模式注入一个流量单位，则必须穿越通道c的流量数量。因为是比率，所以通道负载是无量纲的量。</p>
<p>​	maximum channel load $\gamma_{max}=max_{c \in C}\gamma_c$ 当提供的流量达到网络的吞吐量时，此瓶颈通道上的负载将等于通道带宽b。定义理想吞吐量$\Theta_{ideal} = b/\gamma_{max}$</p>
<p>​	负载下限：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716204550252.png" alt="image-20200716204550252"></p>
<p>​	负载上限：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716204900596.png" alt="image-20200716204900596"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716205205552.png" alt="image-20200716205205552"></p>
<h4 id="3-3-2-Latency">3.3.2 Latency</h4>
<p>网络的等待时间是指从数据包的头部到达输入端口的时间到数据包的尾部离开输出端口的时间</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716212441662.png" alt="image-20200716212441662"></p>
<p>$T_h$头等待时间。报文的头部头经过网络所需的时间</p>
<p>$T_s$序列化等待时间，尾部追赶所需的时间，即长度为L的数据包穿过带宽为b的信道的时间。</p>
<p>$T_0$表示零负载下没有竞争发生的延迟</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716213005459.png" alt="image-20200716213005459"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200717193238297.png" alt="image-20200717193238297">s</p>
<p>​	$t_r$路由延迟</p>
<p>​	$t_{xy}$链路延迟</p>
<h4 id="3-3-3-Path-Diversity">3.3.3 Path Diversity</h4>
<p>​	节点不相交路径</p>
<p>​	边不相交路径</p>
<h3 id="3-4-Packaging-Cost">3.4 Packaging Cost</h3>
<ol>
<li>通道宽度w受每个节点的引脚数和全局布线总量的限制。</li>
</ol>
<p>​	基于典型的两层封装层次结构</p>
<p>​	第一层，各个路由器通过本地布线连接。</p>
<p>​	第二层，通过全局布线连接本地节点组。</p>
<p>​	对于最大引脚数为$W_n$的节点，通道宽度w受以下条件约束：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200718190946225.png" alt="image-20200718190946225"></p>
<p>​	在此级别上，可用的全局导线数$W_s$限制了各个通道的宽度。</p>
<p>​	为了估计特定拓扑所需的全局通道数，我们使用拓扑的最小通道二等分$B_c$</p>
<p>​		优点：</p>
<p>​			平均划分网络，又减少了导线的数量。有利于本地打包。</p>
<p>​		缺点：</p>
<p>​			许多网络必须划分为两个以上的本地组才能满足打包技术的约束，无法实现</p>
<p>​		带宽约束：	<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200718193846863.png" alt="image-20200718193846863"></p>
<p>综上：	<strong>$ \omega \leq min(\frac{W_n}{\delta}, \frac{W_s}{B_C})$.</strong></p>
<p>​	利用带宽来表示，而不是使用信道宽度.</p>
<p>​	节点的最大带宽为$B_n = fW_n$，系统二等分的最大带宽为$B_s = fW_s$。</p>
<p>​	则：每个通道的最大带宽为 $b \leq min(\frac{B_n}{\delta}, \frac{B_s}{B_C})$</p>
<ol start="2">
<li>
<p>布线长度</p>
<p>网络通道的长度必须保持较短，因为在临界长度以上，信号频率会随着导线长度呈二次方下降：<br>
$$<br>
f = min(f_0,f_0(\frac{l_w}{l_c})^{-2})<br>
$$<br>
$l_c$:导线的临界长度</p>
<p>$f_0$:导线的标称信号传输率</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>书生</title>
    <url>/yunruowuBlog/2020/07/04/%E4%B9%A6%E7%94%9F/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>书生不可以没有，但空谈误国！</p>
<p>不可以空谈，但是要有向往！！！</p>
<p>少年中国有希望！</p>
]]></content>
      <categories>
        <category>我团</category>
      </categories>
      <tags>
        <tag>生活的感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划一点收获</title>
    <url>/yunruowuBlog/2020/06/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E7%82%B9%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="动态规划——收获">动态规划——收获</h2>
<p>​	<a href="https://yunruowu.github.io/2020/06/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%88%91%E6%9D%A5%E5%BA%B7%E5%BA%B7/">动态规划第一篇</a></p>
<p>​	之前说了最近要学习动态规划算法，然后自己也刷了十几道题目。下面说一下自己的看法。</p>
<p>​	首先动态规划的效率确实比很多暴力解法要好很多。但是同时必须要付出空间上的开销。一般都是一个dp数组。从我做的题目来看，动态规划就是求解N处的某个问题的解f(n)的最优解。同时f(n)又与f(n-1),f(n-2)等有关。最重要的就是如何求解这些关系。暴力方法可以使用递归直接去求解，但是如果用树形图画出求解过程，就会发现有很多f(k)会被多次计算，这就是开销最大的地方。那么我们自然而然的想法就是减少f(k)的计算次数，怎么做？一种是带一个备忘录，这个方法也不是最优的。最优的是自底向上的来计算f(i)并且进行记录，这样可以减少子问题的计算次数，也就提升了计算效率。有时间再取一些例子进行分享。</p>
<p>​	😪</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>20.6.25一点杂念</title>
    <url>/yunruowuBlog/2020/06/25/20-6-25%E4%B8%80%E7%82%B9%E6%9D%82%E5%BF%B5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="740df74adac3774db458b73d9a18cb376a849155b006bc96448f23886635dc18">0ad2aeb4bf0a00f059acc3e8525b3e6cb106efc4505031f5133a53c0b4e0174665eebee68e25e89607eb626750d6dba25734f678c767615f1b8429686ac188b1e19bca2ac6bd4e972caca7ab22d12ce7e546302a7fbacde5c5961093717a8103ed2632440d7e2ee97389825a5dced7741839ee6287f50f5f72649a639659c7867860d2f92ebc0f68920b853e2be0e64783be455733a04c321442f678a9c0ae5f7c1564d0ab6a0b8387ee708d216721024a1203acac8f7597ae6d5db6bc07ba8ebb9c2a434d28a376a09159f61068f81e6d38491e97cb9db9721388e738bae431b00585cdac23d8b46fa6ac9b9a22be79bb8c4756e17891bf9de9b845739e640643f38b99e22350f80fd21a540c1570069c5f6a7e91ec9abd67bab121ae64cfd5bcdc8355b139d2ad4da7a3501c4cc8beffcd1e98090b42da57b3859e07fa98110f4dccba8543c663e61034bc7c8f15125103d4064e95870bceabe3d7146085c5fd0897cf37d09b90fb31ee50ab51e6e79d36704391acc7bdce816b68199e520d6915f61897eb412e7ccce40dd59fc36a678b6bf95334468ad20dea559bb1061a06521eec6c2b6ab49a63ba34f49a3aaa4fbee67be8cdd0fa7834fea167d487561585b93876a1c228b89c63857a043640a8b6ba03b4b91899b0342ecb6e0b504e7443e6574a462ac24bd0185950b6e0271e929db977eed1c6c2cd9160588529bd336ac87253358b44ff6244deb09f5f79dbf96a82a3162b148f97d0df01a0a7ad21fd804aafd0fde5cfc5eba6ff2ef9d64079f783178d74a90fd7e1e6ef510a0d07f6e7d5aa333093aa061b26cd5e7ae3b09ae9f527906fef81ad3c2a83c9fe205180a5127bede3caf2ef757be87745718b468f1a45d2db9ddb6ee7ecb7a438c94dcc80ea7bcc860f4f34eb00d5c9dc2bc60786ca1751885509a94af01790ca09b7f51d43dd50a8c9aa3e668d1f723dd6cec1f33d5f2bdb594d1f542afe2bcef69b54d03799671086cadcb50b579ef0470a7717277027d5bc4f9677fac72d3f5cda1b2292146b6e0c6f3b4337a31fd2f7d2870694eeb388ef564c73ad9a48bce066bd8e458c0556f21c0090c0a0b3537bb54928f72b3b9f829c12cb464c91d489c798cb6f1a8f68966894379fd652ec9554a476638eac78b1c4e9dcf6954b9c597ac97f7a4f0d48389033ad10c28be7d2d5700cd241213bb95ce57a36cec626b9d56453bc16e4ec1efe9916cffa549affb01c5a796964ef943b74fb59e4f023bf810d478285be1f3a50c272d9321b5b6c267c619be8eed7333ffa67459ac49c57a4eaedc22e3940c21afb718bf5cd83fc469302a6ffef45d13dd8013a1ea011537f07e2033ed5e4f58da74c9c1f5b52ae80eca5638873f25a6dcad76a7e3a0765173f8bbfda4b535d7bbbeaa6f11eb4c530aef1555d4131c0c88e47021b29e08b8647399e5154bac32983896d588873b6c70093442b666feb843ce340271187b65658101d379b3f66788297f7c7bc7a6ea6f1cb745916f8b81f65f1c8fac7b75ef4b42551af84cb8f998543f457b02a9e85b86320b5455ab7912f2ba70b7482ac3210d24822d12b2c2aba40a836ec4af212b2e53814031fb404a62eac93289b55350eee271da7fc0627f00264f96045eee7eceb7ae9bbf86da943e9d296a793619146d8fb01f3e37f37bbaa58fe4d437b2bbd1ebbd74ec318ddc4dfc4a795bb4e41b52267db44c7a326c38344aad3bb702080bac421c45a2b924d223956e7073f9353aa9915d04dce292f9e30b69625ee27b7a8c03838658c130c89741c6c9e3eff8316e8d732efd4919a0a312feabab510e8082cf5ee0d66a12d03537ee4fdc754debd98582b749ed907d7838e5d0fd8dd08d9e2b59cf82e2ef4c9dfaa22110793e8c1e9e89aa2a4ac38b5c7b4afa5467e7d8efc8eee780b13efdbe830a17f3d4aadb7e43f765b4a549bffed316751a5639406ced997ccd7e756a72d796926a3c651f3c048258a9f48f3430438b16d9af2af05b0b198c8f379c5c1217e44feea10ac6d7d0a1e0be8f0b0a92bf67f35ba540e73721f3e1af48ed3e597141b6be9b7600383ae90bc2f92a8d6d75e7608a7d9206609f98f0fd35af207c64f52b22d5126a85df5714508dc420f5ce162b5d8503a9531fae5f2aa626319025a17032c2d71283e4a605e92f35b52fbe130d72615017b505e93f80e38686dbcb4f4ea61e34a71a12cacd9b9b4a42a8e04e58d6e9805f738b78105175bdabfb7886c50d8bd71d6588dd6c3e362336b53128ad980187bf728e53144d766c5fc103e49ffe208aa1b519924a11e5accfe3e67ff2e89e22564bded6db502b26b0aeca94b6880d86fc9d348951682d24a81ced91ba0000ed877b0639aa02742b19b86b1a148397bb3a1628d5ff8bab4bd3fc3779b0ff173ed0c36e466780a4a12e1231b5cad0468497d5a9c3f864cffc0be78d9770db568c5f9391ba607c74bcc4ba69980c361c60b360d5b2b3796f0394f383b83a3a0e1bfa416970c520a1c604c79c9da89321cfa433758fde836c208c865e43a8ae259f2441f256ba457bdcad1c4102ca180ea09d795ab13422fabaa3b82ec3e09f1962c3913e45eeecd95d3e1168ac930790a3a273294def993337a6a59823550399a3840f2799eb92c0ec5c987980bdb1d8246b10cae1ae9ce727bb6360a3bdb7d8429eb18447b10a256c204852b8063db48f5afd9c57693f0dff858b46b45a192a0b98a9a08798e0e23b717401979e0682b89eb91578b5e5b4a61d63bf08c7d89d22521b7b85e98b6ac2d4ac19ad79663809e4e05d60c9cc207c2ea964c3a0ce2b17546fb04190320f82292122cc479a75f5c942c4bc35b855a309cdc447296ba803a557b76e80503e81994038993c94bf06e5b480724c249c4dfbe44a4bae7b736addf63dc11e5c44489a535e319f029b5df4361d570c9abab7c2c91d4b6ef5b4114b41eae0bc864bb0f22c3f092ec32151bb7be777292ecd191bfab22f80f48f9ffd0c3990e1180863a46e52b9f03bab12767d2edd2bd60c944aa4ef6f566b4e25790ed286e26a102241cfbf3ef09508d5a6e2a420da60c070068aeefce56ffece9afc0fb4c7521e5734bc41282ba71039ad4f6bac6dc301efc8ab7f813e9797e25dd82839ae75a38a57bb2bd217c75d244c872f278f0d2b156793d7dd67e5a4b11ff1c0d7f4041423b1b791212320b3ab922b5a3a82bac8c1c5a7109e3039ee7e850c52a5138b435d85c64f21f98704d79abaff84573f0b5aa1fb656fcbbaf6033c34fcda40097b9005ef28c392d0ae39cef20458cdf00e8601970ad4e61da0f77bc689f8c4538f1719722036a97c7db88765c1f41140ff5e838ca4e1bae58f8ff9027a9d03765dbeaedb06adaed6a7e03c6056bb10076464dddf2c0ba299ffef43d6f5da036cdc6efe9ee39af4ff550a7cce84da423fa8e31a064b7d2e4b1c081f422e2711721db71a963dd58ff241a0541a82528ccf33d17bc4b9eefb1d4fcfedb933c33febf719e710dafdd8afa32fae5fdc9ba7be2fe5237eedff0a41c0c28bbc3eed097de243c1888d800cfce385784f044681ff85fe5aa810ffa9fe91c0a4a068a93fbfc89517d92f0653a0ee820c7c38a9ca583c1c9e129e437657bce9da0c133a96d682fc9a5e8bf1832db20496bec98ebb764e60c618063adcee901745e04cab23e7d5b0496bcdbba53fc7b3c574ef05ba6d2a46ce07df20a8acfa3f1ab5142a3e6632452520c9293005096e386c40f14fd6ce6d810131ede2427122a59385af3c138080672c8b741846d3a165b9858cf84af1c3876fbc40a683cf799f2e36c48809b57c6ed39a914688c62de5fe9ba62b9748dd632089b41d7a3a5b19e8e368ed393c00f3f3592d8febcccb0bf524d3c4e49f81a09381924bd3b9aabdb8b1550cf11ce9115b443f58b100b8144ef11b014e141760f137ba8352ee772c2afa3949bc9018af9e2bdc9e745f6abdc7fbb4eee6c4b6618ed124dd7a6bd4221a218732ae666cdc3d50c83ab5c23e6ec9917be39c3f779c0aa595ac8496949e1184d1bde92ae5c5740d574acfa9bb87fdb2f428c967bcc8eceba821de90857e13d952724e2e69820615b3e3310fc5280e848593ff2ecdd0234aecf7c67e3587fd0da8b252ad07c757cde38d94984944252428986de59e17379b47e56bfb518fa078a1a1dda1f337e35281731d682276ca8c8dde34154663f465b83d1e8a9cf9e45acd3ee55bc272b663df4cd753d0c6e27131c77cb46fd011a7e521b616701ec86d25346262cc6753101f5825bb5a31ebaadd7f6f62f1a7c7afcfcee02c550a59a250b2a7341eb9f45c9e9e0c4a9171235024d661cd977a78aefb82f3633770687cc5aa37420d4f4cff76c2fcf77c96d858eee945a55cc35e3a5fce7fa57e24e3474c65474e5ce0f3504b4e422d7dcf3a5d6ad691f01210ed402cb649c0b38a7f0777461563a7f66ba64bf65bf38c60826549f92a97612fa13caed1bdd5cf4464773498cdf19bbba4f884c530f0a4b3fe65000af8ec67d54818374cf089ef01dfe9e0637b9fc2b807d6fec0753acc2737f3b4a0670d232a58d977c7e520acbd3f142c77e96d4c34b439b1f32ec6843ca4e2a4d501810a36284c13d9194</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>思想的火花</category>
      </categories>
      <tags>
        <tag>悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection_Networks-1</title>
    <url>/yunruowuBlog/2020/06/24/Interconnection-Networks-ch1/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="第一章-互连网络简介">第一章 互连网络简介</h2>
<ol>
<li>
<p>什么是互联网络？</p>
<p>互连网络是在终端之间传输数据的可编程系统。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200624161515545.png" alt="image-20200624161515545"></p>
</li>
</ol>
<p>从网络在不同时间可以建立不同链接的角度来看，该网络是可编程的。</p>
<p>本书研究小型的网络，从芯片级别到系统级别的。</p>
<ol start="2">
<li>
<p>Where do you find interconnection networks?</p>
<p>组件间只要存在通信就有内联网络</p>
</li>
<li>
<p>Why are interconnection networks important?</p>
<p>成为提升系统性能的限制。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令积累</title>
    <url>/yunruowuBlog/2020/06/24/Linux%E5%91%BD%E4%BB%A4%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="Linux命令积累">Linux命令积累</h2>
<ol>
<li>
<p>移动、复制命令：</p>
<p><code>mv 源地址 目的地址</code></p>
<p><code>cp 源地址 目的地址</code></p>
</li>
<li>
<p>添加路径到PATH</p>
<p><code>export PATH=&quot;$HOME/bin:$PATH&quot;</code> 临时的</p>
<p>~/.bashrc 打开这个文件，在后面添加上述命令即可完成永久的修改</p>
<p>source ~/.bashrc  source 命令保存文件并将新文件中的 $PATH 加载到当前 shell 会话中：</p>
</li>
<li>
<p>创建目录</p>
<p><code>mkdir 文件名</code></p>
<p><code>mkdir -p /temp/dir1/dir2</code>创建文件树</p>
</li>
<li>
<p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apt<span class="literal">-get</span> install package_name 安装/更新一个 deb 包 </span><br><span class="line">apt<span class="literal">-cdrom</span> install package_name 从光盘安装/更新一个 deb 包 </span><br><span class="line">apt<span class="literal">-get</span> update 升级列表中的软件包 </span><br><span class="line">apt<span class="literal">-get</span> upgrade 升级所有已安装的软件 </span><br><span class="line">apt<span class="literal">-get</span> remove package_name 从系统删除一个deb包 </span><br><span class="line">apt<span class="literal">-get</span> check 确认依赖的软件仓库正确 </span><br><span class="line">apt<span class="literal">-get</span> clean 从下载的软件包中清理缓存 </span><br><span class="line">apt<span class="literal">-cache</span> search searched<span class="literal">-package</span> 返回包含所要搜索字符串的软件包名称 </span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>一次Ubuntu的安装记录</title>
    <url>/yunruowuBlog/2020/06/23/%E4%B8%80%E6%AC%A1Ubuntu%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="一次Ubuntu的安装记录">一次Ubuntu的安装记录</h2>
<p>​	最近要在Linux上做一点东西，但是自己不太理解要做啥，本来是想用WSL的，结果发现有点困难😂。只能转到虚拟机里面来工作了。找了一个Ubuntu的iso安装文件，安装，很快。</p>
<p>​	由于是新系统肯定需要下载软件，更新软件，确实花费了一定的时间。最难的是安装中文输入法，搞了我好久。现在还有一个bug，中文输入在terminal中无法显示光标。</p>
<p>​	后面我还行去WSL里面试试，不折腾会死就是我本人了。</p>
<p>​	一些小的启发：发现问题时多去百度，谷歌，收益很多。然后就是多试试，自己总能解决问题。</p>
<p>​	还有Linux不要随意删除自带的python，很坑。记住！</p>
]]></content>
      <categories>
        <category>软件安装</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划我来康康</title>
    <url>/yunruowuBlog/2020/06/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%88%91%E6%9D%A5%E5%BA%B7%E5%BA%B7/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="动态规划的-span-style-color-87CEFA-云-span-看法">动态规划的  <span style = "color :#87CEFA">云</span>  看法</h2>
<p>​	个人而言，时而觉得动态规划比较神秘困难，时而觉得简单。主要还是没有完全掌握方法和技巧，所以最近准备重新全面的了解一下这个算法，同时在LeetCode中进行刷题。</p>
<p>​	现在我知道了递归的一般思路：递归解法-&gt;带备忘录的递归解法-&gt;动态规划的解法。</p>
<p>​	其中还有求解最优子问题。</p>
<p>​	动态规划问题最困难的就是写出状态转移方程。</p>
<p>​	下面就安装上面的思路去刷题，看看自己能得到什么🏃‍♂️🏃‍♂️🏃‍♂️</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>一点点小想法</title>
    <url>/yunruowuBlog/2020/06/17/%E4%B8%80%E7%82%B9%E7%82%B9%E5%B0%8F%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="99d39c494d5d5619bf1b7cd3e633f63b40d820a8703508fb31c16ba6600f5a8a">7598fd0d447fa3eaa88cce180daf64da117399b2248901ef3260a647dc941e97974e14725fa9a634e684808f09f0a287df05ed339ac208fff9b43edfa3e0b1ef24f9d9be2374e14a76ee49fc7204e60da4a2c6ad7eceb3e8d60bd8382270622860c41172e424a0f307c6696254060d0f8bb5a351e8c212e525109ce936f4c89a271093c738d0f6b5a3c21991fe880e9dada317e09ce61fb86d144aa536b442795dc15d270dbf64c9b8d5379e957d8a72bd73a66bf035658f13fb71c13c52d65a36d798f19a1aea7059766ac92d095047bdcd567b00d0edd3856c9191489b408623547bce2a815b3933d388919acfda6e2e2ab229c51f03619cef50bdb9f936740ad1967c8106ce06623c9c29817f3ee7478fc475e762cd10b1dc069e979462509a353767483934c5cc096d25879386a9f47017161e3b40cc4739174da6c729f717c0366077f4c64701b6895ab55225fa604e492305ccd764fde2649aef92ecd43e6ac0db10a32cac3e029f064b47f4123c9ae4112b83fae4e27fbe07b937990abfa8f046a2b156703cc40edbb5ef9c801fa5bd47441b0bd8875f9c1b2af5b8e28520cef0ef0964c53e19031eb64e2f5e04446d865d7aa520d417fc3146f253b51804a1949f136b335a772db46a500376192cea2f7eba758ccbf2b47d59c919cb8ca1709c23409b71850932dc2b7e1354c2c14644faa4a7b844c12744a33a82eb6ae242ebe08b4559028fdc810daaa00c63ebaef95d5746c7fa3cae98573af208b7a976f63d6bd934d7b6b2d8e403e36fe280b2afda7473010501ec5a4ed4fe65c4211185c78f1d1063f42e5373d5ebf9113eaa68e408c5740933fd7584773cd53dcfcfe011e3cbae7a5b06a78d08fb1f2639008833343f21b501c9fe851eddb859b7122cf9d0d5169ba6383ce52934c75a3920426fc3c395d3cd581ffe053deb3859d2c69e417ecf1d000e10228a6e6bb5abc8b6cfa0efcbe0c4fa7e371c07a500d1dc9b3c2fbdaa561f629356ade73439f2f962330a43dee6a31cfee7726dd2b617bb6393ca4e8d99c166b4dd768559ae4be9f0afef4ef50d55fc854bb84fcd0a6a7f64d0f0f2b8ab09139f799c91be5472ae85b98ec76eee4e7eb1d290df30bf0379e7f43aedc5bb7d7f1893eadaef75adac972a5b6e5ac1f9c823b289d07abd6a7f6132d8bf79e1e72c0c13a21b9c2fd0c45c6e71c6b56e297201364fa656d5310c617da4f10efb577b15e75dfdde162184fdefe3aef3cb4fddb1b5fd6409eb3d3263d0dc7b10db882140d1d3bb2b33205fb6d08959e830ee911b1679aae6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>内省</category>
      </categories>
      <tags>
        <tag>悟与梦</tag>
        <tag>内省</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11</title>
    <url>/yunruowuBlog/2020/06/17/LeetCode-11/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="题目描述">题目描述</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/description/">187.重复的DNA序列</a></li>
<li><a href="https://leetcode-cn.com/problems/single-number-ii/description/">137.只出现一次的数字 II </a></li>
</ol>
<p>两个题目都是关于位运算的。不得不承认自己不会💔，确实没有这方面的练习，完全没有想法。这个还是需要自己多去尝试，多学习学习。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-10</title>
    <url>/yunruowuBlog/2020/06/16/LeetCode-10/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="题目">题目</h2>
<p>这次题目没啥。难度不大</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105.从前序与中序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106.从中序与后序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/description/">114.二叉树展开为链表</a></li>
</ol>
<h2 id="解题思路">解题思路</h2>
<p>前两题简单。直接第三题<br>
要求就是把树变成链表，如下：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/2.png" alt="2"></p>
<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/33.png" alt="33" style="zoom: 80%;" />
<p>具体算法是：</p>
<ol>
<li>将右节点放到左节点的最右边的节点下面。</li>
<li>将左节点放到右节点的位置，左节点为空；</li>
<li>遍历一下即可。</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>win10汇编学习的环境配置</title>
    <url>/yunruowuBlog/2020/06/13/win10%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>​	想学习汇编语言的，首先最重要的装环境。学语言躲不掉的，而且头疼的步骤😂</p>
<p>​	最开始肯定是想在win10下面运行的。网上一查装，感觉有点麻烦。然后就放弃了准备转战linux。之前把WSL删除了，又要重新弄，之前操作过，难度不大。之后就是安装汇编语言环境，这里也是坑，最后成功了，发现虚拟机DOSbox运行的时候很不正常。运行结果如下，我个人觉得是因为wsl不支持弹出程序界面。具体的我也不知道。就这样吧，win10我来了。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200613215435.png" alt="image-20200613215432641"></p>
<h2 id="win10汇编学习的环境配置">win10汇编学习的环境配置</h2>
<p>下面的都是自己在百度上找的，有的已经忘记了网址，只能提供下面几个了。</p>
<p><a href="https://www.cnblogs.com/liuzeyu12a/p/10285384.html">下载教程</a></p>
<h3 id="需要的工具">需要的工具</h3>
<ol>
<li>dosBox模拟器。</li>
<li>masm 5.0</li>
<li>debug程序</li>
</ol>
<h4 id="一、dosBox模拟器">一、dosBox模拟器</h4>
<ul>
<li>
<p>下载地址：直接到官网下载即可。</p>
</li>
<li>
<p>百度的简介：DOSBox是一个软件。它是当前在 <a href="https://baike.baidu.com/item/Windows/165458">Windows</a> 系统运行 <a href="https://baike.baidu.com/item/DOS/32025">DOS</a> 游戏的较为完美的解决方案，该软件不仅能支持相当多的游戏实现正常运行，而且能将声音完美表现出来。</p>
<p>说实话我也不是很清楚这是干啥的，大概就是一个模拟器，或者是虚拟环境，包含8086汇编环境的，正好适合我的学习。</p>
</li>
<li>
<p>安装：安装包下载下来直接next,记得选择自己的安装目录就可以。</p>
</li>
<li>
<p>配置：这要是挂载目录。命令<code>mount c: c:\</code>前一个c盘是模拟器里面的，后面的是win10主机的目录。这样在模拟器里面需要每次输入一次。解决办法，修改配置文件DOSBox 0.74 Options.bat。</p>
</li>
<li>
<p>修改结果如下：</p>
<p>配置环境变量主要是在后面使用其他工具时不需四处调整目录，简化操作。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200613221849.png" alt="image-20200613221849549"></p>
</li>
<li>
<p>难度：❤🧡💛</p>
</li>
</ul>
<h4 id="二、masm5-0">二、masm5.0</h4>
<ul>
<li>
<p>安装：</p>
<p>这个只要是为后面编译，链接程序，debug配置的</p>
<p>主要程序如下：</p>
</li>
</ul>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200613222317.png" alt="image-20200613222317896"></p>
<p>​		之前以为挺难的，后面发现只要下载了即可。我太高估了。💔</p>
<ul>
<li>难度：❤🧡</li>
</ul>
<h4 id="三、debug">三、debug</h4>
<p>这个是单独装的，最后我移动到masm文件夹里面一样可以使用</p>
<ul>
<li>安装地址：github<a href="https://github.com/Microsoft/MS-DOS">网址</a></li>
<li>使用：<a href="https://yunruowu.github.io/2020/06/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%ADDebug%E7%9A%84%E4%BD%BF%E7%94%A8/">debug使用</a></li>
<li>难度：🤍</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言中Debug的使用</title>
    <url>/yunruowuBlog/2020/06/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%ADDebug%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="汇编语言中Debug的使用">汇编语言中Debug的使用</h2>
<p>​	学习汇编语言肯定需要工具来帮助解决问题,比如调试等.所以学习debug的使用也是比然的.下面介绍一些debug的常用命令.Debug是DOS、windows提供得实模式（8086方式）程序得调试工具。可以查看cpu各种寄存器的内容、内存使用情况和机器码级跟踪程序的运行</p>
<p>​	(汇编中应该是不区分大小写的~)</p>
<h3 id="命令汇总">命令汇总</h3>
<ol>
<li><a href="#%E4%B8%80%E3%80%81R%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8">R命令</a>：查看、改变寄存器</li>
<li><a href="#%E4%BA%8C%E3%80%81D%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8">D命令</a>：查看内存内容</li>
<li><a href="#%E4%B8%89%E3%80%81E%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8">E命令</a>：改写内存</li>
<li><a href="#%E5%9B%9B%E3%80%81U%E5%91%BD%E4%BB%A4">U命令</a>：机器指令翻译成汇编指令</li>
<li><a href="#%E4%BA%94%E3%80%81T%E5%91%BD%E4%BB%A4">T命令</a>：执行一条机器指令</li>
<li><a href="#%E5%85%AD%E3%80%81A%E5%91%BD%E4%BB%A4">A命令</a>：以汇编指令的格式在内存写入一条机器指令</li>
</ol>
<h4 id="一、R命令的使用">一、R命令的使用</h4>
<ul>
<li>
<p>功能：查看改变CPU寄存器的内容</p>
</li>
<li>
<p>命令格式：</p>
<ol>
<li>
<p><code>r </code> 可以查看所有寄存器的内容；</p>
<p>​	<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200614100127.png" alt="image-20200614100127586"></p>
</li>
<li>
<p><code>r ax</code> ax为寄存器的名称，修改某个寄存器的内容；按下ENTER键之后，会出现‘：’作为输入提示符，后面输入数字，再按下ENRTER,即完成了对AX的修改。</p>
<p>​	<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614100432318.png" alt="image-20200614100432318"></p>
</li>
</ol>
</li>
</ul>
<h4 id="二、D命令的使用">二、D命令的使用</h4>
<p>​	功能：D命令是查看内存单元的命令。<br>
​	命令格式:</p>
<ol>
<li>
<p><code>d</code>直接查看预设地址的内容。</p>
</li>
<li>
<p><code>d 段地址:偏移地址</code>：查看内存某处的内容。</p>
<p>eg: 查看内存10000H处的内容，</p>
<div align="center">
    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614101142785.png"/>
</div>
<p>Debug将列出从指定位置开始的128个内存单元的内容。<br>
D命令会输出三个内容：</p>
<ul>
<li>
<p>左边是每行的起始地址；</p>
</li>
<li>
<p>中间是内存单元的内容，每行的输出从16的整数倍地址开始</p>
</li>
<li>
<p>右边是内存单元中数据对应的可显示的ASCII码字符，没有对应的字符则用”.“替代。<br>
eg: 查看1000:9处的内容</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614103307054.png" alt="image-20200614103307054"></p>
<p>还是从当前地址开始显示，但是前面1000:0H到1000:8H的不在显示</p>
</li>
<li>
<p>使用上面的命令后，继续使用D命令可以列处后面的内容。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614103559342.png" alt="image-20200614103559342"></p>
</li>
</ul>
</li>
</ol>
<p>3.<code>d 段地址:起始偏移地址 结尾偏移地址</code> 查看指定范围的内容</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614104157817.png" alt="image-20200614104157817"></p>
<h4 id="三、E命令的使用">三、E命令的使用</h4>
<ul>
<li>功能：改写内存的内容</li>
<li>命令格式：
<ol>
<li>
<p><code>e 起始地址 数据 数据 数据 数据 ……</code><br>
eg:      <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614104602641.png" alt="image-20200614104602641"></p>
</li>
<li>
<p>采用提问的方式改写</p>
<ul>
<li>
<p>输入地址e 1000:0 按下ENTER;</p>
</li>
<li>
<p>显示当前位置，和内容加一个‘:’</p>
</li>
<li>
<p>输入内容，可修改</p>
</li>
<li>
<p>输入空格，下一个地址，输入ENTER结束</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614104915485.png" alt="image-20200614104915485"></p>
</li>
</ul>
</li>
<li>
<p>E命令可以写入字符和字符串</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614105202142.png" alt="image-20200614105202142"></p>
</li>
<li>
<p>也可以直接写入机器码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b80100  mov ax,0001</span><br><span class="line">b90200  mov cx,0003</span><br><span class="line">01c8    add ax,cx</span><br></pre></td></tr></table></figure>
<p><img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614121158381.png" alt="image-20200614121158381"></p>
</li>
</ol>
</li>
</ul>
<h4 id="四、U命令">四、U命令</h4>
<ul>
<li>
<p>功能：查看机器码对应的汇编指令</p>
</li>
<li>
<p>命令格式：<code>U 起始地址</code></p>
<p>eg:</p>
<p><img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614121300693.png" alt="image-20200614121300693"></p>
</li>
</ul>
<h4 id="五、T命令">五、T命令</h4>
<pre><code>* 功能：执行一条或多条指令，执行CS:IP指向的指令。  
* 命令格式：`t`
* 注意，首先利用r将CS:IP指向要运行的地址
</code></pre>
<p><img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614121825077.png" alt="image-20200614121825077"></p>
<ul>
<li>
<p>执行<code>t</code>.</p>
<p><img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614121910203.png" alt="image-20200614121910203"></p>
<p>执行完成自动显示寄存器状态，CS：IP指向下一条指令，输入t继续执行指令</p>
</li>
</ul>
<h4 id="六、A命令">六、A命令</h4>
<ul>
<li>
<p>功能：以汇编指令的形式写入机器指令</p>
</li>
<li>
<p>命令格式：<code>A 地址</code>。</p>
<p>eg:</p>
</li>
</ul>
<p><img src="C:%5CUsers%5Cmcdxw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614122319851.png" alt="image-20200614122319851"></p>
<h3 id="总结">总结</h3>
<p>​	已经开始入门了，除了debug,还需要学会文件的编译和链接。继续加油！！！💤</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu命令行更换软件源</title>
    <url>/yunruowuBlog/2020/06/11/Ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9B%B4%E6%8D%A2%E8%BD%AF%E4%BB%B6%E6%BA%90/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd判圈算法（龟兔赛跑算法）</title>
    <url>/yunruowuBlog/2020/06/11/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%EF%BC%88%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>​	Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明，但这一算法并没有出现在罗伯特·弗洛伊德公开发表的著作中。</p>
<h3 id="问题：">问题：</h3>
<p>​	如何检测一个链表是否有环，如果有，那么如何确定环的起点.</p>
<h3 id="要求：">要求：</h3>
<p>​	 空间复杂度为O(1), 时间复杂度为O(n).</p>
<p>对于一个有环的链表，利用Floyd算法可以做到下面三件事：</p>
<ol>
<li>判断是否有环</li>
<li>计算环的长度</li>
<li>寻找环的起点</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200611083405.png" alt="image-20200611083243900"></p>
<h4 id="1-判断是否有环">1.判断是否有环</h4>
<p>​	使用两个指针slow和fast。两个指针都从链表的起始处S开始。slow每次向后移动一步，fast每次向后移动两步。若在fast到达链表尾部前slow与fast相遇了，就说明链表有环。<br>
这里可以简单的证明一下：反证法，假如没有环，那么slow永远追不上fast，那么在fast到达链表尾部前slow不会fast相遇了。若相遇了，链表就有环。</p>
<h4 id="2-求环的长度">2.求环的长度</h4>
<p>​	当slow和fast相遇时，slow和fast必定在环上，所以只要让一者不动，另一者走一圈直到相遇，走过的节点数就是环的长度。</p>
<h4 id="3-求环的起点">3.求环的起点</h4>
<p>如图所示，设AB=n, SA=m。设环的长度为L。<br>
假设slow走过的节点数为i，那么有：<br>
i = m + n + a<em>L        a为slow绕过的环的圈数。<br>
因为fast速度为slow的两倍，所以相同时间走过的节点数为slow的两倍，所以有：<br>
2</em>i = m + n + b*L    b为fast绕过的环的圈数。<br>
两者做差有 : i = (b-a)*L。<br>
所以可知，fast和slow走过的距离是环的整数倍。<br>
所以有m+n=(b-2a)L。<br>
所以此时让slow回到起点S，，fast仍然在B。<br>
让两个指针以每次一步的速度往前走。<br>
当走了m步时，可发现slow和fast正好都在A处，即是环的起点。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>c_plus_plus的小知识1</title>
    <url>/yunruowuBlog/2020/06/07/c-plus-plus%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%861/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>厚积薄发！！！</p>
<h2 id="遇到的小知识">遇到的小知识</h2>
<ol>
<li>内部函数命名。__fun(),函数前面加上前导符。</li>
<li>c++STL“前开后闭”的思想</li>
<li>c++插入是指“插入在……之前”，也就是在指定迭代器i的插入x即<code>insert(iterstor,x)</code>，插入之后i这个迭代器在x之后。</li>
<li>vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。</li>
<li>adapter(配接器) ：修改某物接口，形成另一种风貌.</li>
<li>inline 关键字。解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。<a href="https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html">inline</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>我的团长我的团—1</title>
    <url>/yunruowuBlog/2020/06/07/%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E2%80%941/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="扎心">扎心</h2>
<p>今天看到小太爷走出小醉家门，那段旁白。艹！脑子有问题的孟烦了。这是头疼，可爱不可得。真惋惜，气死！</p>
]]></content>
      <categories>
        <category>我团</category>
      </categories>
      <tags>
        <tag>生活的感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-9</title>
    <url>/yunruowuBlog/2020/06/06/LeetCode-9/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="题目">题目</h2>
<p>今天就一个题目，有些不好意思🙈</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a></li>
</ol>
<p>具体点，就是求解数组中的极大值，并且假设相邻的不会相等，同时nums[-1],nums[n+1]为负无穷。</p>
<h2 id="解题思路">解题思路</h2>
<p>​	看着题目很简单，一遍遍历即可，但是复杂的是O(n)的。题目要求$O(log(n))$。所以还需改进。</p>
<p>​	我是看了一眼解答提到的边界值，想到解法的。</p>
<p>​	思路就是比较中值mid和两段的中间值l_mid,r_mid。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid]&lt;nums[l_mid])&#123;<span class="comment">//在左边</span></span><br><span class="line">        right = mid;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&lt;nums[r_mid])&#123;<span class="comment">//在右边</span></span><br><span class="line">        left = mid;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//在中间</span></span><br><span class="line">        left = l_mid;</span><br><span class="line">        right = r_mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是代码解释的快。嘎嘎嘎！</p>
<p>还有一些边界值，这些比较简单，数组数目1，2可以单独考虑。再一个，最先比较边界的是否为极值也是一个简化的过程。</p>
<p>最终还是完成，花费的时间比较久，主要是没有安心，而且没有认真理解题目。继续🐱‍🏍。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Binary_Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora上传图片</title>
    <url>/yunruowuBlog/2020/06/05/Typora%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="背景">背景</h2>
<p>​	从开始用markdown写文章，自己只会写文字，现在有了多元的需求。比如图片，代码等。这些东西利用原生的代码可以完成，但是人总是偷懒的，没有人愿意先上传图片，再复制链接，最后写在文章中，这样存在很多无用功，所以需要偷懒。😀😉！</p>
<h2 id="我的历程">我的历程</h2>
<ol>
<li>手写链接+本地保存。垃圾+蠢</li>
<li>利用SMMS图床，用了几次感觉没啥意义，立马放弃。</li>
<li>picGo+github图床。使用起来比较好用，但是国内访问github比较麻烦，上传问题不大，主要是本地显示问题。有点麻烦，于今天弃坑。</li>
<li>picGo+gitee图床，这里必须表扬gitee，访问快，无阻碍。❤</li>
</ol>
<h2 id="配置流程">配置流程</h2>
<p>现在说来只有一句，搞这个玩意，我花了4-5个小时，还不加之前配置picGo+github图床的时间，心累💢！。</p>
<ol>
<li>
<p>gitee创建仓库，生成令牌，这个比较简单，gitee全中文的界面没有障碍。</p>
</li>
<li>
<p>下载picGo插件picgo-plugin-gitee-uploader。不知道picGo怎么回事，反正我装了好久才成功，还使用了``npm install picgo-plugin-gitee-uploader -g`下载，最终是怎么成功的，我自己也不知道了😅。</p>
</li>
<li>
<p>配置插件。</p>
<p>​     <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200605164924.png" alt="image-20200605164924047"></p>
</li>
<li>
<p>配置Typora</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200605165122.png" alt="image-20200605165122064"></p>
<p>细节性的就不细说，看看就可以理解了。</p>
</li>
<li>
<p>最后验证一些即可。好用的不行。</p>
</li>
</ol>
<h2 id="报错的排除">报错的排除</h2>
<p>在上传的时候主要有两个错误</p>
<ol>
<li>
<p>“failed to fetch” 这个是picGo的端口设置错误，改成<strong>36677端口</strong>。</p>
</li>
<li>
<p>{“success”,false}，出错，基本上是配置（可能是重名）错了，现在运行起来基本不会出现。</p>
</li>
</ol>
<h2 id="结语">结语</h2>
<p>在找解决办法的过程中，真的好无奈，啥也不敢确定，只能不断地测试，最终成功后：</p>
<p><strong>拨开云雾见青天！</strong></p>
<p>人的心情都好了😉😉😉！</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora绘图</title>
    <url>/yunruowuBlog/2020/06/05/Typora%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>在学习的过程中不可避免地要绘制流程图，树状图，这些图画起来比较简单，但是要达到美观就比较麻烦了。所以在网上找了一些绘图的工具，首先是Typora的自带绘图工具。</p>
<h2 id="Typora的绘图代码">Typora的绘图代码</h2>
<h3 id="mermaid绘图">mermaid绘图</h3>
<p>首先是成品：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line"></span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure>
<p>下面是代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line"></span><br><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=<span class="number">1</span>| D[结果<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=<span class="number">2</span>| E[结果<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    F[横向流程图]</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>接受一下算法：</p>
<ol>
<li>{}表示的是条件判断，[]是方形的边框，（）是圆形的。</li>
<li>–&gt;表示的线，A,B,C是标号。||是条件，括号内的是节点名称。</li>
<li>LR表示横向， TD是竖向</li>
</ol>
<h3 id="标准流程图flow">标准流程图flow</h3>
<p>成品：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```flow</span><br><span class="line"></span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```flow</span><br><span class="line"></span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>到此也就结束了，还有UML等的绘制，但是目前我用不到，再此就不进行记录了。</p>
<h3 id="工具绘图Graphviz">工具绘图Graphviz</h3>
<p>Graphviz 是一个开源的图可视化工具，非常适合绘制结构化的图标和网络。Graphviz 使用一种叫 DOT 的语言来表示图形。</p>
<p><strong>DOT 语言</strong></p>
<p>DOT 语言是一种图形描述语言。能够以简单的方式描述图形，并且为人和计算机所理解。</p>
<p>有关代码：</p>
<h4 id="无向图">无向图</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">graph graphname &#123;</span><br><span class="line">   a -- b -- c;</span><br><span class="line">   b -- d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有向图">有向图</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph graphname &#123;</span><br><span class="line">    a -&gt; b -&gt; c;</span><br><span class="line">    b -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置属性">设置属性</h4>
<p>属性可以设置在节点和边上，用一对 <em>[]</em> 表示，多个属性可以用空格或者 <em>,</em> 隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strict graph &#123;</span><br><span class="line">  // 设置节点属性</span><br><span class="line">  b [shape=box];</span><br><span class="line">  c [shape=triangle];</span><br><span class="line"></span><br><span class="line">  // 设置边属性</span><br><span class="line">  a -- b [color=blue];</span><br><span class="line">  a -- c [style=dotted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的属性列表可以参考 <a href="https://link.zhihu.com/?target=http%3A//www.graphviz.org/content/attrs">attrs | Graphviz - Graph Visualization Software</a></p>
<h4 id="子图">子图</h4>
<p>subgraph 的作用主要有 3 个：</p>
<ol>
<li>表示图的结构，对节点和边进行分组</li>
<li>提供一个单独的上下位文设置属性</li>
<li>针对特定引擎使用特殊的布局。比如下面的例子，如果 subgraph 的名字以 cluster 开头，所有属于这个子图的节点会用一个矩形和其他节点分开。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph graphname&#123; </span><br><span class="line">    a -&gt; &#123;b c&#125;;</span><br><span class="line">    c -&gt; e;</span><br><span class="line">    b -&gt; d;</span><br><span class="line"></span><br><span class="line">    subgraph cluster_bc &#123;</span><br><span class="line">        bgcolor=red;</span><br><span class="line">        b;</span><br><span class="line">        c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subgraph cluster_de &#123;</span><br><span class="line">        label=&quot;Block&quot;</span><br><span class="line">        d;</span><br><span class="line">        e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="布局">布局</h4>
<p>默认情况下图是从上到下布局的，通过设置 rankdir=“LR” 可以让图从左到右布局。</p>
<p>现在够用了。</p>
<h4 id="基本命令">基本命令</h4>
<p>使用dot -T输出的格式 dot文本 -o *.输出格式 命令，可以生成相应格式的图片。比如要根据上面的脚本生成一个svg图片，可以执行命令：dot -Tsvg eg.dot -o eg.svg</p>
<p>生成图片</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dot test.dot -T png -o test.png</span><br></pre></td></tr></table></figure>
<p>由一个节点指向多个节点时，可以将它们用大括号包上，当子节点含有空格时可用引号将其包含。可以对脚本代码加上注释，其风格与C++的注释风格一样，可以用/* */包括注释内容，也可以用//将后面到下一行为止全当作注释。</p>
<h4 id="节点描述中包含空格导致被拆分成两个节点">节点描述中包含空格导致被拆分成两个节点</h4>
<p>​	解决方案一，使用 label</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">graph pic1 &#123;</span><br><span class="line">        google [label=<span class="string">&quot;Google 搜索&quot;</span>];</span><br><span class="line">        百度搜索 <span class="comment">-- 大象笔记</span></span><br><span class="line">        google <span class="comment">-- 大象笔记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案二，加双引号</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">graph pic1 &#123;</span><br><span class="line">        百度搜索 <span class="comment">-- 大象笔记</span></span><br><span class="line">        <span class="string">&quot;Google 搜索&quot;</span> <span class="comment">-- 大象笔记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一些基本图形">一些基本图形</h4>
<p>节点形状</p>
<p><a href="https://graphviz.gitlab.io/_pages/doc/info/shapes.html">https://graphviz.gitlab.io/_pages/doc/info/shapes.html</a></p>
<p><img src="https://cdn.sunzhongwei.com/sunzhongwei_5badb625d6a88?imageView2/2/w/800/format/jpg/interlace/1/q/97%7Cimageslim" alt="画流程图工具 Graphviz，简介及基础教程"></p>
<p>箭头的形状也有很大的选择空间</p>
<p><a href="https://graphviz.gitlab.io/_pages/doc/info/arrows.html">https://graphviz.gitlab.io/_pages/doc/info/arrows.html</a></p>
<p><img src="https://cdn.sunzhongwei.com/sunzhongwei_5badb62eaf68f?imageView2/2/w/800/format/jpg/interlace/1/q/97%7Cimageslim" alt="画流程图工具 Graphviz，简介及基础教程"></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法题目</title>
    <url>/yunruowuBlog/2020/06/05/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="算法描述"><a href="https://leetcode-cn.com/tag/backtracking/">算法描述</a></h2>
<p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<h2 id="算法使用方法">算法使用方法</h2>
<p>我觉得在使用回溯算法的时候，需要使用树形的结构来帮助算法的运行。我在使用回溯的时候都是理由深度优先搜索算法和剪枝来解决问题的。</p>
<p>整个深度搜索算法的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 最终能达到的树的深度</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans; <span class="comment">//如果要求不重复，可以声明为set或者在算法中排除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, vector&lt;<span class="keyword">int</span>&gt;tags, vector&lt;<span class="keyword">int</span>&gt; ins)</span><span class="comment">//cur表示当前到达的树的层次，tag表示一种约束，比如只能元素只能用一次等。ins 表示当前整个路径上的节点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n)&#123;<span class="comment">//可能还有其他限制条件，这里只是深度满足要求。</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(ins);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>()&#123;<span class="comment">//遍历可以遍历的</span></span><br><span class="line">        <span class="comment">// 处理tags和ins</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur+<span class="number">1</span>, tags,ins);</span><br><span class="line">        <span class="comment">//恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用树形图来解释一下算法：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200605162618.png" alt="二叉树"></p>
<p>首先就从空节点a开始，每次添加一个节点，从可选的节点中选择，继续到下一层，同时可以存在剪枝，在每个节点开始时，判断是否达到最终条件或者超过最终条件，这样可以将该节点及其以下的节点删除，不用遍历。在遍历子节点完成后，会回到当前节点的上一个状态，这样就是回溯。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/yunruowuBlog/2020/06/01/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>今天在刷题的过程中，遇到了有关并查集的问题，之前有学过，但是一直没有使用过。所以没啥映像。现在好好学习一下。</p>
<h2 id="并查集">并查集</h2>
<p>首先这里都是自己看人家写的。还处于学习的阶段。</p>
<p>​	并查集（Union-find Sets）是一种非常精巧而实用的数据结构，它主要用于处理一些<em>不相交集合</em>的合并问题。一些常见的用途有求连通子图、求最小生成树的 Kruskal 算法和求最近公共祖先（Least Common Ancestors, LCA）等。</p>
<p>​	使用并查集时，首先会存在一组不相交的动态集合$S = {S_1, S_2 … S_k}$，一般都会使用一个整数表示集合中的一个元素。每个集合可能包含一个或多个元素，并选出集合中的某个元素作为<strong>代表</strong>。每个集合中具体包含了哪些元素是不关心的，具体选择哪个元素作为代表一般也是不关心的。我们关心的是，对于给定的元素，可以很快的找到这个元素所在的集合（的代表），以及合并两个元素所在的集合，而且这些操作的时间复杂度都是<strong>常数级</strong>的。</p>
<p>​	并查集的操作有三个：</p>
<ol>
<li>makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。</li>
<li>unionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。</li>
<li>find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span>&#123;</span></span><br><span class="line">    <span class="comment">//集合</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">	<span class="comment">//创建n个集合，其中每个元素都是一个单元素集合，即父节点是其自身：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        data.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) data[i] = i;</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = i;</span><br><span class="line">        <span class="keyword">while</span> ( data[root] != root)&#123;</span><br><span class="line">            root = data[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">//合并集合i，j.合并操作 unionSet，并查集的合并也非常简单，</span></span><br><span class="line">    <span class="comment">//就是将一个集合的树根指向另一个集合的树根</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="built_in">parent</span>(i);</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="built_in">parent</span>(j);</span><br><span class="line">        <span class="keyword">if</span> ( p1 != p2 )&#123;</span><br><span class="line">            data[p1] = p2;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> p1 != p2;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>感觉自己还不是很理解，需要一些练习。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-8</title>
    <url>/yunruowuBlog/2020/06/01/LeetCode-8/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="题目">题目</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/description/">二叉树的堂兄弟节点</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-islands/description/">200.岛屿数量</a></li>
<li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/">201.数字范围按位与</a></li>
</ol>
<h2 id="题解">题解</h2>
<h3 id="二叉树的堂兄弟节点">二叉树的堂兄弟节点</h3>
<p>​	利用结构体，一个属性为父节点，一个为节点深度。</p>
<h3 id="岛屿数量">岛屿数量</h3>
<p>​	两种方法。</p>
<p>​	法一：深度遍历，遍历完将岛屿清零；</p>
<p>​	法二：并查集。</p>
<h3 id="数字范围按位与">数字范围按位与</h3>
<p>​	主要思想：不太理解。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-7</title>
    <url>/yunruowuBlog/2020/05/30/LeetCode-7/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="LeetCode-7">LeetCode_7</h2>
<h3 id="题目">题目</h3>
<ol>
<li><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976.三角形最大周长</a></li>
<li><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977.有序数组的平方</a></li>
<li><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/description/">989.数组形式的整数加法</a></li>
</ol>
<h3 id="思路">思路</h3>
<h4 id="三角形最大周长">三角形最大周长</h4>
<p>​	先排序，后面就三个一起往后移动。比如此时$a&gt;=b&gt;=c&gt;d$。如果$a,b,c$能组成三角形，那么其是最大的。如果不能，那么应该$a&gt;b+c$，那么$a&gt;b+d$也显然成立。所以直接比较$b,c,d$是否满足要求即可。</p>
<h4 id="有序数组的平方">有序数组的平方</h4>
<p>​	最简单的方法，直接计算，然后排序。</p>
<p>​	稍微好一点的做法，双指针做法</p>
<h4 id="数组形式的整数加法">数组形式的整数加法</h4>
<p>​	直接将最后一位与K进行相加，然后进位继续求和。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C艹_创建无重复元素的Vector</title>
    <url>/yunruowuBlog/2020/05/29/C%E8%89%B9-%E5%88%9B%E5%BB%BA%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84Vector/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="c-创建无重复元素的Vector">c++创建无重复元素的Vector</h2>
<p>​	我们知道，在刷题的时候，总是会遇到让我们创建无重复元素的问题。主要方法，在插入的时候进行处理。这里不选择这个。我们先使用SET容器，这样可以把元素无重复的插入。最后将Set的值赋给Vector。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ans.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>十分简单。学到了。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-6</title>
    <url>/yunruowuBlog/2020/05/29/LeetCode-6/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h1>LeetCode-6</h1>
<h3 id="题目：">题目：</h3>
<hr>
<ol>
<li>953.<a href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary/description/">验证外星语词典</a></li>
<li>961.<a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/description/">重复n次的元素</a></li>
<li>965.<a href="https://leetcode-cn.com/problems/univalued-binary-tree/description/">单值二叉树</a></li>
<li>970.<a href="https://leetcode-cn.com/problems/univalued-binary-tree/description/">强整数</a></li>
</ol>
<h3 id="思路：">思路：</h3>
<h4 id="验证外星语词典">验证外星语词典</h4>
<p>​	这题目就是一个字典排序题。不过字典序是题目指定的，所以需要一个转换。然后遍历即可，难度不高。</p>
<h4 id="重复n次的元素">重复n次的元素</h4>
<p>​	一共2n个元素，n+1个不同的，其中n个重复。最简单的就是遍历。另一个解法是：长度为4的子序列中一定会有重复元素。只需要比较所有距离为 1，2 或者 3 的邻居元素即可。</p>
<h4 id="单值二叉树">单值二叉树</h4>
<p>​	这个就比较简单了，只需要遍历即可。</p>
<h4 id="强整数">强整数</h4>
<p>​	最开始遍历范围，然后计算是否成立，后面是先计算成立的，再计算是否符合范围。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>5.28最近的一些计划</title>
    <url>/yunruowuBlog/2020/05/28/5-28%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="计划">计划</h2>
<ol>
<li>
<p>hexo</p>
<p>工欲善其事，必先利其器。这句话还是很对的，以后要用hexo写博客，之前修改过hexo的主题，但是还有有一些不和谐的地方，在阅读别人博客的时候，确实存在好看的主题和效果，这些都是值得我去学习，借鉴的。所以我要修改一下我的博客，目前主要还是修改功能性的问题，按钮点击没有出现404，每个页面都要设置好，还好页面的显示要合理，不是很丑的那种。之后就是更多的美化这些东西，让他们的“颜值” 不断提升。</p>
</li>
<li>
<p>读书🛴提升自己</p>
<p>之前买的两本专业书，也可以带着看看了，不然又浪费了金钱。</p>
<p>然后有机会还是要多看看其他方面的书籍，提升一下整个人的内在。</p>
</li>
<li>
<p>目前的学业和工作任务</p>
<ol>
<li>毕业设计，还要修改，降重；</li>
<li>简历。</li>
</ol>
</li>
<li>
<p>我的团长我的团，最近又在看了多想想一些自己身上有的不好的地方。</p>
<p>最后，每件事都很容易，难得坚持下去，坚持下去会有不一样得收获。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>任务</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>复试出成绩的一天</title>
    <url>/yunruowuBlog/2020/05/22/%E5%A4%8D%E8%AF%95%E5%87%BA%E6%88%90%E7%BB%A9%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5b63c0a105f2a55b12ae703eba861755dab1d3005ee26ccb4c798f1a6762f42c">165d50f05814027fb7fe5e4ae8a088d86787c748b405550d35a33d270865828af0e723dde51bc85b7a01fcf562f051f99ace83b56e471196fc2ce027ed35af0d7f6b416deab04ce8deff2de8bd5aecdecae31691341133f288e3e83a9b4d5bf5e93085568a28ab5e2cbd3bcdc0a4cb31e19211bdd1cfa97b597f6fd9885df47676cb9667eaebf52d018790e009d280dc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>强烈推荐Typora</title>
    <url>/yunruowuBlog/2020/05/17/%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90Typora/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3973319abd346a2735ece437b5d7ae451688c6f4b352ae8f8eb69af6d4a29603">165d50f05814027fb7fe5e4ae8a088d86787c748b405550d35a33d270865828af0e723dde51bc85b7a01fcf562f051f99ace83b56e471196fc2ce027ed35af0d7f6b416deab04ce8deff2de8bd5aecde3b88efe004bcd536e8bad23c8fea8a5e82538512876d5248b9017eab577ea015c467c90c00e0054bec0d927a63392f046eba1d545eff356542d139c3c7e63789ba2c25a2fa555c79460f4df870cd4c201ff3e74600665768cbb2770114ef30b828d0192eda3937dd4926de30af13bfbaf411e8ac31968f363a4fea2f3696fc8ee2384ea3ff6accfc062c059b9093b82ea6327ea0da438b0fe46b8668008cf956ceba0f8d232d232373354aa5a96ba236ce22d70b20bac8ce514c35aaf14d32437f42263ffeb6f60b6bdde6cdede2d119cc06155c5d03b357179134e48f33cf668c06968a98fab2b1543c7225f13c7b6f221d2f2f348c19fd5ba7b6af0db23a17406fcbb4854ef7c6d3c2398304b1b05ca0e1a633d9149c9d9e321ac9556828ba9ae74079b4ee19379d09052b0bd7ce09cf975918375bbc4170da55e6c67a1441d8cdd2f9e47c92cc447c0bd43d93ad412bb094c1a12469ad8fd5c008b05197c8e07f471c5e7845cf8764d19ddcd4bc939b879198617bd072c4642dc27f620347ebef5c53706742da882cea80e5bb226a72b9c511ae8e8f067bc50a21a8a1aede2bc3fd7a12dd2d9d6f7b40529c4b52bc9b25d3590198067607eff0beb6382e90ff236cf73b7192b124d3defdaa5ab4f00c53258c32d5f21b811c848e15a41e923bf57b8f60b2a40ef3e2acaae20fe028e8b186ede74ead2f024fb9fb730118817080797e6ca1d1fd4cd7945a7c8f3148c0cf442226be7b4358d783638667e7fec64f4d601a236ce1d373072d349495b1576055aed88b7c8bbd236488e3dd7ade</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>准备复试的某一天</title>
    <url>/yunruowuBlog/2020/05/17/%E5%87%86%E5%A4%87%E5%A4%8D%E8%AF%95%E7%9A%84%E6%9F%90%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b3a426530719eac88b60cd5ed2ee44b041c735aebc013ecf95da7a14dfe63705">9c18114bfffb75bea463c3ab069bee10c5800e1c8aabf839ed15f237ba683a127037ae9bfcebd1aca84606f58f0457498d5811c056e65e90e784d413dd98cd3a80b41a03606f99fcde27a77dc9c66b0e77091cf36577c6536350684af8f58e8dfdcac1947078de6acfa50b2397c54e523bbf3ec46a2f55b02584bed2f6637e641b90d378f4ccb525c7c7881ddba9c757b008688ab3822925232f86c05d1007f83eba839d83772a71d23c55a7220f4038fd4cdbd2311e401f05e24733d08f4fa049ca32b94da24552161e486b1c4226184e8252e6c6b11f5e398fe87131e95a610d78c05d0afbb2ac0fa413e5535e79edf7b05b1c4525b0764b2f47db954ac05d49a8598b3898eaf421a8aa528fac467d098a855da6721ae647b29f99e54fc11358b5bdc86e67bbba0c432bd2e879c3a6fb92fb4de50462765b7ddac9a92b874bba6e71c9d33181996d65f32178930cbe3616587b9b154120107c00eef70ef07b4bd667defaff2186e195fee7d1892e30428d9a3d96923762e341d6b47cce90a484e04cb4b1d5b0a369e33ef5497a05cd3ed1be037390e52534944c7a35c3c8d8d56527c4967bb2f32281b8ee4d4da4c1ad65666a9218b7e5ec2d0a9e7c9fb5b6f07510eacbee2dc1b815759ec8b55c6d09eed53aae18fe83e44f7e418f0fd07e903c584187b34d2c54be7645afd849841b6958383ba694fd31d7d56e063970efaf60c84d12db37c2cb51db51debac922b7b20e3c4a0ec5135f1164a888618019caf2fa5e436a80e5c07e6727fd4e445a795e78ecd4d459cb51c7039b54320082e265f39c6758566c6e94ad1af9e08fc599201e369511aa60d9ed28e2d2162d70623e03f5b9448b68ea3a103ff89888145e82bf2fb607cc41857a46cad3c23a9f30b00b50a9bc03060359b22e4e22b35db8b0279cf821e7a5de3892a2a14cf763e816813a0dc3e5514693891d3d6b05b3ac1d924421dac58715c17f724eced034a10c82b5089d9bbfb39031692f14272892830661dca1a6763528dcc216834d1220a53dc7ea2d846b4244c8285197a8c93a2f025c4a82df3b96314ed2d97fe2be6fa5d9c6f3b356aac2cc690ef903935bd86bfbdbf14a7560c597684b34c83add3d5f4df7f334924abd4a0a7ec40b928a879189f772bcfe0984725e41f0052cd3c903487b9b87f9f3c2a5626b49633403c95470d1ed1037c40fd9e8f30e713c75d1ef7528c1978d8d859002fbfd3467a648a9443f1868e53e0e20935cc4dba27f0f86d496a3b603bf6923fa37f9b74c3ae4ede9950f1688fb2b8cc16b1cb576109d0266f11cc32bb476cd18bf11918ddda20b63fd5c9e76f3e5e705b74ffe8ce3034e8eef13cc40c5c5cbf1468c011d4fe374094cd8bdc85b90a04ed4c176c1e6a58783566c04e8fe5933685c7891624de296b88bd14510331bb2c05e3f844d23696bdca42e045694092df89ad95d2f8eec6202688590ea1959135e9858e2d48aa1b9e5ac4db80a298c2eb8725a68e8ea8042117e446456c8cb6f829872f8e77bbb3964e805fcaab9d23281de6217233c6159670c826d4bbe8ac007dc72b4bbe05ec6b2af8ed2fe065406cda9803bba4edff83ccfd0335b9c07cef681b2fa267a9bf9fa91cdfe3bbfb2e9caf7aa0bb4e4fd20c7164862b9d54ec8906729f378ec098c60211945cca0f10ad691daa4efa88f85a93ac0665134f216ddd58248084c55cd3b1341150ca495756a867be323782cee1f6f91e62bb86849bcb4bda2f9b5bd887b093cda67a975ac1030f4a20abfc6552303578782a3936658ef20c594248a2c6375b34fd86cca85693c178bfb751ccc84201391c14c639ffefb94128b17fb4e1bf85a62537f9d13d4883a026c79b3bd409d2aaaef84ab2a0feb7b239cce77603171cb534b0290c34d55e350a2decacd6705ad7bb79d8493ab00445eee0bc61e2d08152c0a947de765ec78cf0022295da1acdaf00f66fd77104ed2456f76cce531ce766633f9e645c8c84b4ebf0e77125bab7383016b24fc5a49cdca76cee4c45233462abde8886546ba7aa773cc92940c239bf63c898581fb45df56204eb466f9cb52e97fb099728a35988a415b91d9788a8ae7d79590de1a98e751f6d15c76c734a9d52a600375c29a32d8a5e66fb0b9c93cc3282d5ae58fe73f81e96d799e02d6d416580c450f93c1f521b50983e639d2543b7ff9ea30b2849304fc324c58bd6f7b1ddc1a8589b7d8cfaa483d363c5a3a82333193445b663c5304e1dbe9517c5b1166ae4fa00fa6f3306f644e8596839ab86ae967352d442085c714d881284647c7cadc938fa1a7ad58ee544e63345d790a9dc24d6ee7442cc853db99e7bd65d01899fcb96cf8b6535888a15bf7602458d522d56f0c25bfac4021f4648521608139f4203982223d7bebbb169353ff580a80ece1ec672f078001696866120f9dbaf353d276a3fa1a3d3466da463d3a970ae72c5e81164de0367549325a178c2aa7b23f46db529deee4c3bda589c1e36bde1969a036b30d8fb4d3644eb59e7161a896b59fd496f4dfd609e3973b3322f17a4e25c72f71a6ad9baf95541ee6dcb4576ca254d9edee266f0576b366fb78085d2034cee07ce52ce58d462fb10cda8771f26dd58201fb64490f05914d9a8bbdd92645bfc78e8b6ea747c1aa37c3a795c3afc216cb04e0417556f12f7786cc4c0f507695c1c78d8fb728bc21764118e8c59294a12d1acb28c508174b9b4a75d304e1f669d7e2f33b41edd6b05aa0092d653b1ba74728da5c6365003d43e8c1219dbf7e23545beb966d8e7a6ec582dd27411577fca8b43d1e9f3b4d4c7962328cb4cd6ecdb887f1183ede60496ecfa55a3bdb375b71dc48f9ccfef95ea04e86f5eee75a030444c0dbaba0a257707652b98e103feff034fd5da80f83bc3d5664d6672aa3526d3d8932ee9157521fd6f37ec37e8dfdf4434b97f6d19d51adf5f1ecf189604d6f9a1a3953b43e0d9dfb67f7123f05dd25ce48efb7d98a52f167a3ef6f5247d65417c942de8428c011</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/yunruowuBlog/lib/hbe.js"></script><link href="/yunruowuBlog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>思想的火花</category>
      </categories>
      <tags>
        <tag>日常，悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年五四的一些感想</title>
    <url>/yunruowuBlog/2020/05/05/2020%E5%B9%B4%E4%BA%94%E5%9B%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="五四，青年的日子">五四，青年的日子</h2>
<p>这里我只想应用鲁迅先生的一句话：</p>
<blockquote>
<p>愿中国的青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热、发一分光。就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p>
</blockquote>
<p>诚然，我所处的时代，不是一个黑暗的时代，但是我们的时代仍然有不公，依旧需要我们的努力。青年一代的我，作为这个社会的支撑，必须要拿出自己的担当。去面对未知于黑暗，去创造可能与光明。奉献自己的萤火，照亮这世间的黑。</p>
]]></content>
      <categories>
        <category>思想的火花</category>
      </categories>
      <tags>
        <tag>悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>python中plt画图出现警告</title>
    <url>/yunruowuBlog/2020/04/29/python%E4%B8%ADplt%E7%94%BB%E5%9B%BE%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="警告">警告</h2>
<p>最近做毕设的时候，需要画图来查看算法优化性能。之前都是利用截图来保存的，今天网上找到了可以自动保存图片的方法，在使用的过程中出现警告：<code>libpng warning: iCCP: known incorrect sRGB profile</code>。在查阅资料后发现是因为使用了QQ输入法，这个错误也太搞笑了，记录一下。顺便记录保存图片代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">t = np.arange(<span class="number">0</span>, <span class="number">69</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, t, <span class="string">&#x27;r&#x27;</span>, t, t**<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">label = [<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;t**2&#x27;</span>]</span><br><span class="line">plt.yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.legend(label, loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;./test&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">plt.pause(<span class="number">1.5</span>)</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中：：的使用</title>
    <url>/yunruowuBlog/2020/04/17/C-%E4%B8%AD%EF%BC%9A%EF%BC%9A%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="c-中-的用法">c++中::的用法</h2>
<p>::是运算符中等级最高的，它分为三种:</p>
<ol>
<li>global scope(全局作用域符)，用法(::name)</li>
<li>class scope(类作用域符)，用法(class::name)</li>
<li>namespace scope(命名空间作用域符)，用法(namespace::name)<br>
他们都是左关联(left-associativity)<br>
他们的作用都是为了更明确的调用你想要的变量，如在程序中的某一处你想调用全局变量a，那么就写成::a，如果想调用class A中的成员变量a，那么就写成A::a,另外一个如果想调用namespace std中的cout成员，你就写成std::cout(相当于using namespace std; cout)意思是在这里我想用cout对象是命名空间std中的cout(即就是标准库里边的cout)</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>本地git连接GitHub</title>
    <url>/yunruowuBlog/2020/04/16/%E6%9C%AC%E5%9C%B0git%E8%BF%9E%E6%8E%A5GitHub/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><ol>
<li>
<p>进入要操作的文件夹</p>
</li>
<li>
<p>命令行操作</p>
<ul>
<li>
<p><strong>第一步</strong>： 进入要所要上传文件的目录输入命令 <code>git init</code></p>
</li>
<li>
<p><strong>第二步</strong>： 创建一个本地仓库origin，使用命令 <code>git remote add origin git@github.com:yourName/yourRepo.git</code> youname是你的GitHub的用户名，yourRepo是你要上传到GitHub的仓库，这是你再GitHub上添加的仓库。</p>
</li>
<li>
<p><strong>第三步</strong>： 比如你要添加一个文件xxx到本地仓库，使用命令 <code>git add xxx</code>，可以使用<code>git add .</code>自动判断添加哪些文件</p>
</li>
<li>
<p><strong>然后</strong>把这个添加提交到本地的仓库，使用命令 <code>git commit -m</code>说明这次的提交</p>
</li>
<li>
<p><strong>最后</strong>把本地仓库origin提交到远程的GitHub仓库，使用命令 <code>git push origin master</code></p>
</li>
</ul>
</li>
<li>
<p>出现问题时候的操做</p>
<ol>
<li>
<p>先拉下来，会自动合并的（不用操心）<br>
git pull origin master</p>
</li>
<li>
<p>再上传<br>
<code>git push -u origin master</code></p>
</li>
</ol>
</li>
<li>
<p>出现错误：<br>
fatal: remote origin already exists.<br>
先删除Git<br>
<code>Git remote rm origin</code></p>
</li>
<li>
<p>注意事项<br>
一般来说，我都是新建项目之间进行关联，所以使用GitHub创建仓库时，不要生成readme.md就可以避免出现错误，因为生成之后两个文件就不一样了。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>git，小技巧</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5</title>
    <url>/yunruowuBlog/2020/04/15/LeetCode-5/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="题目">题目</h2>
<pre><code>82. 删除排序链表中的重复元素-II
86. 分割链表
87. 解码方法
</code></pre>
<h2 id="想法">想法</h2>
<ul>
<li>删除排序链表中的重复元素-II
<ul>
<li>这题我的想法是我们可以先找到第一个不重复的元素，再找剩下的元素，重复就把他们删掉。</li>
</ul>
</li>
<li>分割链表
<ul>
<li>首先将头部调整成正确的，然后找到正确顺序下头部后面的节点，进行调整，依次完成。</li>
</ul>
</li>
<li>解码方法
<ul>
<li>这个我使用递归的，<span style="color:Tomato;">超时</span></li>
<li>使用动态规划，找个时间学习一下动态规划。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-4</title>
    <url>/yunruowuBlog/2020/04/12/LeetCode-4/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p><em><div align="right">—命都不要，就爱，就爱安逸。</div></em></p>
<div align="right" size="2">《我的团长我的团》</div>
<h2 id="题目">题目</h2>
<pre><code>73. 矩阵置零
74. 搜索二维矩阵
75. 颜色分类
</code></pre>
<h2 id="想法">想法</h2>
<ol>
<li>
<p>矩阵置零<br>
由于题目有时间的限制，我的想法不好，就从网上参考了一下，主要的想法如下：<br>
首先利用两个bool来表示第一行，第一列时候存在0。然后在搜索其它的位置，遇到了0就将相应的位置的第一行和第一列置零。然后再遍历第一行和第一列，利用它们来设置其他位置是否为0。最后利用bool来确定第一行和第一列的值。</p>
</li>
<li>
<p>搜索二维矩阵<br>
首先我的思路是利用了二次的二分查找，本来我以为效率挺高的了，结果看到了其他大神的解法直接是O（M+N）。说实话，思路确实很巧妙。思路是比较对角线的数字，从右上到左下。核心代码如下：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(row&lt;=M &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col]==target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col]&gt;target)&#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>颜色分块</p>
<ol>
<li>思路<br>
这个比较常见，属于三色棋问题。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>一点感悟2020.4.11</title>
    <url>/yunruowuBlog/2020/04/11/%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F2020-4-11/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><span id="more"></span>
<p>    今天在赶中期检查的时候，感觉自己有点茫然，不知道自己在干啥。最近基本上处于一种有事情来了我就看着做，做的了就慢慢做，做不了更是慢慢做，没有动力。不知道自己要啥，自己在干啥。很无力，做什么都是。人呀，没有了追求，做起事情来就是这样的没有根。失去了力量的源泉。在尘世间飘啊飘的，有风了就飘的高一些，远一点，快一些；没有风了，就靠着惯性，在飘一飘；等到惯性也没了，人就开始下坠了，往下沉，沉下去的速度很快，很快，快到你没有力气再飞起来，就算你用尽了全力，你也飞不起来了。你只能勉强的撑着。到这里，你的人生还没有结束，不过，它的轨迹，你的未来，也没有了希望。</p>
<p>    你的一生，本不该如此。一个特别喜欢的励志视频:<a href="https://v.qq.com/x/page/h0797gtaozg.html">Are you have a Dream !</a></p>
<blockquote>
<p>苏格拉底说：人类的幸福和欢乐在于奋斗，而最有价值的是为理想而奋斗。</p>
</blockquote>
<p>我有理想吗？<br>
我的理想是什么？<br>
我为了什么而奋斗？<br>
我该怎么奋斗？<br>
我的未来在哪里呀！！！！</p>
]]></content>
      <tags>
        <tag>悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>powershell和cmd一次执行多个命令</title>
    <url>/yunruowuBlog/2020/04/10/powershell%E5%92%8Ccmd%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>之前遇到很多需要依次输入的命令，有的命令需要等待时间。今天找到了如何一次输入多条命令的方法👍</p>
<ol>
<li>Powershell<br>
在powershell中命令后面加上‘|’<br>
eg:<br>
<code>hexo clean | hexo g | hexo d</code>此命令可以一步实现博客的部署。</li>
<li>cmd<br>
在cmd中将‘|’改为‘&amp;&amp;’即可。</li>
</ol>
]]></content>
      <tags>
        <tag>命令行</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-3</title>
    <url>/yunruowuBlog/2020/04/10/LeetCode-3/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="题目">题目</h2>
<pre><code>79.单词搜索
今天就一题，最近再忙中期检查
</code></pre>
<h2 id="想法">想法</h2>
<span id="more"></span>
<p>第一想法就是回溯，也就这么做了，四个方向分别探索，知道成功。时间空间效率极低😢.看来其他人的答案，主要是在判断上，我的是分开判断，人家的是||或了一下，这里有不同。再一个在确定是否探索过的问题上，我利用了一个tags二维数组，可以直接通过修改原数组来实现。这点我没有做导致空间不够。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2</title>
    <url>/yunruowuBlog/2020/04/09/LeetCode-2/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><div align="right">---命都不要，就爱，就爱安逸。</div>
<div align="right" size="2">《我的团长我的团》</div>
<hr>
<h2 id="题目">题目</h2>
<pre><code>54.螺旋矩阵
55.跳跃游戏
</code></pre>
<h2 id="想法">想法</h2>
<ol>
<li>螺旋矩阵</li>
</ol>
<ul>
<li>思路：旋转矩阵就是绕着转，我的想法是按照每个循环左，下，右，上。一方面要考虑边界，一方面考虑是否被访问过，这里可以利用一个边界的标志，我采用了一个相同大小的tag矩阵来标志是否访问过。</li>
</ul>
<ol start="2">
<li>跳跃游戏</li>
</ol>
<ul>
<li>
<p>思路：我自己的思路是利用递归，每次往前前进一次，不断递归，最终没有满足时间的要求。</p>
</li>
<li>
<p>网上的解决办法<br>
这里只要理解可以到达k处，那么k之前的位置都可以到达。所以一次遍历就满足要求了，而且时空效率都很高。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    k = <span class="built_in">max</span>(k, i+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1</title>
    <url>/yunruowuBlog/2020/04/08/LeetCode-1/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="题目">题目</h2>
<pre><code>33.搜索旋转数组
46.全排列
49.字母异位词分组
</code></pre>
<h2 id="想法">想法</h2>
<span id="more"></span>
<ul>
<li>搜索旋转数组<br>
主要是二分法。一半有序的数组，一半无序的数组。然后一次进行下去。</li>
<li>全排列<br>
方法是回溯法，可以想成一个树状图，不断搜索，然后到叶子节点停止。</li>
<li>字母异位词分组<br>
方法就是hash,自己先写的没有通过时间的限制。后面利用了网上的题解。思路就是使用unordered_map来存储，利用排序后的string作为关键字存贮，这样一次遍历就可以完成。</li>
</ul>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>开始我的博客之旅</title>
    <url>/yunruowuBlog/2020/04/02/%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><h2 id="为什么开始">为什么开始</h2>
<p>怎么写自己的博客，我还没有想好，也还没有想到写哪些内容。我觉得这应该是一篇技术型的博客，所以在这里我将记录一些我的学习过程，比如我现在正在写的leetcode的题解，在看的《STL的源码剖析》。我也希望可<br>
以在这里审视自己的能力和不足，如若可以，提升自己的书面表达能力也是一种收获。</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>test_my_site</title>
    <url>/yunruowuBlog/2020/04/02/test-my-site/</url>
    <content><![CDATA[<script src="\yunruowuBlog\assets\js\APlayer.min.js"> </script><p>dasd</p>
<p>d ad as</p>
<p>das d</p>
]]></content>
  </entry>
</search>
