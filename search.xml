<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>new</title>
    <url>/2021/05/31/new/</url>
    <content><![CDATA[<p>d的似的是的</p>
<p>菜市场</p>
]]></content>
  </entry>
  <entry>
    <title>testy</title>
    <url>/2021/03/07/testy/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>glex</title>
    <url>/2020/11/05/glex/</url>
    <content><![CDATA[<h2 id="Send"><a href="#Send" class="headerlink" title="Send"></a>Send</h2><ol>
<li>posix_memalign()分配内存大小</li>
<li>glex_open() 建立连接<ol>
<li>init_ipc()   <em>open the MPI and DMA socket</em> </li>
<li>init_tcp()</li>
<li>init_shmem()</li>
<li>init_ipc_shmem()</li>
</ol>
</li>
<li>glex_num_of_device()获取设备数量<ol>
<li><strong>glex_acc_sim()</strong><ol>
<li>sned()</li>
<li>wait_ack()</li>
</ol>
</li>
</ol>
</li>
<li>glex_open_device(dev_id, &amp;dev)，把设备地址和设备id进行匹配。</li>
<li>glex_create_ep()<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_get_ep_addr()获取ep的地址<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_register_mem()<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
<li>glex_send_imm_mp() 发送mp消息<ol>
<li>pack_sock_imm_mp_req()</li>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_receive_mp()接受数据<ol>
<li>glex_acc_sim()</li>
</ol>
</li>
<li>glex_rdma()<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
</ol>
<h2 id="Receive"><a href="#Receive" class="headerlink" title="Receive"></a>Receive</h2><ol>
<li>posix_memalign()分配内存大小</li>
<li>glex_open() 建立连接<ol>
<li>init_ipc()   <em>open the MPI and DMA socket</em> </li>
<li>init_tcp()</li>
<li>init_shmem()</li>
<li>init_ipc_shmem()</li>
</ol>
</li>
<li>glex_num_of_device()获取设备数量<ol>
<li><strong>glex_acc_sim()</strong><ol>
<li>sned()</li>
<li>wait_ack()</li>
</ol>
</li>
</ol>
</li>
<li>glex_open_device(dev_id, &amp;dev)，把设备地址和设备id进行匹配。</li>
<li>glex_create_ep()<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_get_ep_addr()获取ep的地址<ol>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_register_mem()<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
<li>glex_receive_mp()接受数据<ol>
<li>glex_acc_sim()</li>
</ol>
</li>
<li>glex_send_imm_mp() 发送mp消息<ol>
<li>pack_sock_imm_mp_req()</li>
<li><strong>glex_acc_sim()</strong></li>
</ol>
</li>
<li>glex_rdma()<ol>
<li><strong>glex_acc_sim</strong></li>
</ol>
</li>
</ol>
<p>本地发送，本地接收。</p>
<p>一个节点，同时运行两个程序。</p>
]]></content>
  </entry>
  <entry>
    <title>Evaluation of an InfiniBand Switch:Choose Latency or Bandwidth, but Not Both</title>
    <url>/2020/10/25/Evaluation-of-an-InfiniBand-Switch-Choose-Latency-or-Bandwidth-but-Not-Both-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>中国计算机学会推荐会议</title>
    <url>/2020/10/21/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="关于网络的"><a href="#关于网络的" class="headerlink" title="关于网络的"></a>关于网络的</h2><p>顶会</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021175201851.png" alt="image-20201021175201851"></p>
<p>B类</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021175246058.png" alt="image-20201021175246058"></p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021180139218.png" alt="image-20201021180139218"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201021180324206.png" alt="image-20201021180324206"></p>
]]></content>
      <categories>
        <category>HiNA</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/10/17/test/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="64e89d16ca4b3ada6343ad689775e9fb6ecc9b2a51c3c157893e5d4f39c5f0fd">1b693c4938223286468132b2f7068bf692ed5dee0c3935214f29f490dcf6c777909dd75670c1cc0da6df3d9d5cc0edbffb557370a0e8d3f127b030974749db9a0f8a927b5ff4052e2b065b01b3916af1db33c6cea39a944bc89e0f4eb0b8c7f11cb1b0a20d32ec8d2cc1aa20617daa3f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>python打包为.exe程序</title>
    <url>/2020/10/16/python%E6%89%93%E5%8C%85%E4%B8%BA-exe%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="Python导出exe打包"><a href="#Python导出exe打包" class="headerlink" title="Python导出exe打包"></a>Python导出exe打包</h2><p>最近做项目，看见可以把.py直接打包成.exe，在此学习一下。</p>
<p>工具：pyinstaller</p>
<p>下载：conda install pyinstaller </p>
<p>普通命令： pyinstaller -F -w  [.py]</p>
<p>pyinstaller [options] script [script …] | specfile</p>
<p>详解命令</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/5890308-fb1ad502516d7bc1.webp" alt="参数列表"></p>
<p>​            pyinstaller.exe后面如果加上-F就是打包为一个exe文件（文件会比较大），如果不加就会有很多库文件；加上-w就是打包为没有cmd窗口的exe,不加运行时就会出现cmd窗口。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Traffic Engineering with Forward Fault Correction</title>
    <url>/2020/10/09/Traffic-Engineering-with-Forward-Fault-Correction/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h3 id="1-Question"><a href="#1-Question" class="headerlink" title="1. Question?"></a>1. Question?</h3><p>网络存在故障，已有的解决办法都是在拥塞出现后，采取行动，是一种后手的行为，加上大型网络传播的延迟，故障的恢复需要大量时间。</p>
<p>作者提出了积极的故障处理办法，尤其是，TE应该在网络中传播流量，以便只要故障总数最多为k（可配置范围），就不会发生拥塞。此保证应适用于任意组合的故障。方法称为前向故障校正（FFC）</p>
<h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method?"></a>2. Method?</h3><p>FFC</p>
<p>两个挑战：最小化吞吐量损失和计算可伸缩性</p>
<h4 id="FFC-Overview-and-Challenge"><a href="#FFC-Overview-and-Challenge" class="headerlink" title="FFC Overview and Challenge"></a>FFC Overview and Challenge</h4><ol>
<li><p>FFC for control plane faults</p>
<p> 控制平面FFC保证只要发生配置故障的交换机数量最多为k，就不会发生拥塞。</p>
<p> 正常情况下，网络会因为配置失败产生拥塞</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009153846174.png" alt="image-20201009153846174"></p>
<p> 讲配置修改为：这样第一个网络可以容忍k=2,第二个网络k=1.</p>
<p> a）的网络缺点是网络吞吐量低于没有故障和FFC时的吞吐量。但是，如果没有流量需求（或网络拓扑）的进一步变化，此吞吐量开销将是暂时的，比如可以在s2和s3配置好之后，将s1到s4的流量提高到10。即使是暂时的吞吐量降低，也是FFC提供的鲁棒性的开销。</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009153952523.png" alt="image-20201009153952523"></p>
</li>
<li><p>FFC for data plane faults</p>
<p> 数据平面FFC保证了多达k条链路或交换机发生故障时，重新缩放后不会发生拥塞。</p>
<p> 考虑下面的情况：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009154532269.png" alt="image-20201009154532269"></p>
<p> 上图出现链路失败时，重新分配后，会导致网络的拥塞。</p>
<p> 但是按照下图的分配方法，任意一条链路失败后，不会发送网络拥塞</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009154541378.png" alt="image-20201009154541378"></p>
<p> 缺点：</p>
<p> ​    像控制平面FFC一样，数据平面FFC也会降低吞吐量。但是，控制平面的FFC仅在更新网络时承担开销，但数据平面FFC的开销却是持久的。两种情况的区别在于，当链路或交换机发生故障时，网络容量会减少。为了避免发生故障后发生拥塞，我们必须保留备用容量来吸收发生故障的元素所承载的流量。</p>
</li>
<li><p>Applying FFC</p>
<p> 不同的需要对应不同的网络配置，k的选择，需要进去取舍。</p>
</li>
<li><p>Challenges and overview of techniques</p>
<p> 第一， The first is the scalability with which robust traffic distributions can be computed.</p>
<p> ​                可伸缩性，可用来计算可靠的流量分布。</p>
<p> 第二，We must meet the computational challenge while meeting the second challenge of minimizing the loss in network throughput.</p>
<p> ​        满足计算挑战，同时还要满足使网络吞吐量损失最小化的第二个挑战。</p>
<p> 解决办法：</p>
<ul>
<li>交通量和传播条件作为线性约束条件（公式时精确的，但是又很多限制）</li>
<li>将约束转换为所谓的“bounded M-sum”问题。此类问题中的所有约束都可以减少为对最大（或最小）M个变量的单个约束。</li>
<li>最后，借助排序网络，我们使用有效的线性表达式对这些变量进行编码。</li>
<li><p>结果是具有O（kn）约束的FFC公式。</p>
<p>两个设置：</p>
</li>
</ul>
<ol>
<li>故障的影响易于建模。如果交换机配置失败，它将保留其旧配置；如果链路失败，则入口交换机将确定性地重新调整流量。这种简单性使我们能够使用有效的线性约束来捕获FFC施加的条件。</li>
<li>虽然故障很常见，但故障率（即发生故障的元件比例）很低。因此，足以防止少量故障（k）。解决k的高值将需要大量计算并且会产生高吞吐量开销</li>
</ol>
</li>
</ol>
<h3 id="3-Answer"><a href="#3-Answer" class="headerlink" title="3. Answer?"></a>3. Answer?</h3><h4 id="3-1-Basic-FFC-Formulation"><a href="#3-1-Basic-FFC-Formulation" class="headerlink" title="3.1 Basic FFC Formulation"></a>3.1 Basic FFC Formulation</h4><h5 id="3-1-1-Basic-TE-without-FFC"><a href="#3-1-1-Basic-TE-without-FFC" class="headerlink" title="3.1.1 Basic TE (without FFC)"></a>3.1.1 Basic TE (without FFC)</h5><p>​    输入是图G =（V，E），其中V和E是交换机集以及交换机之间的有向链接。 </p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009181529820.png" alt="image-20201009181529820"></p>
<p>​    The TE problem can be solved based on path-constrained multicommodity flow problem ：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201010083835104.png" alt="image-20201010083835104"></p>
<p>等式2表示没有链接应该过载，等式3指出，流在其所有隧道中的分配总和不应小于其分配速率。等式4指出分配给流的速率不应超过需求，并且所有变量均为非负数。</p>
<h5 id="3-1-2-Modeling-control-plane-faults"><a href="#3-1-2-Modeling-control-plane-faults" class="headerlink" title="3.1.2 Modeling control plane faults"></a>3.1.2 Modeling control plane faults</h5><ol>
<li><p>控制面板错误：</p>
<p> FFC的目标是计算新配置$( { b<em>f},{a</em>{f,t}} )$以便只要$k<em>c$或者更少的交换机无法更新他们的旧配置$( { b_f^{‘}},{a</em>{f,t}^{‘}} )$就不会发生拥塞。</p>
<p> 令$λ<em>v=  1$表示至少有一个以v作为入口开关的流配置失败；$ λ_v= 0$表示从v开始的所有流都配置成功。网络中控制平面故障的个别情况可以用表示每个开关状态的向量$λ= [λ_v| v∈V]$表示。因此FFC对于$k_c$个失败是具有鲁棒性的就要求网络在情况合集$Λ</em>{kc}= {λ|\sum_{v∈V}\ {λ_v}≤ k_c}$下没有过载的链路。可以被捕获为：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163513463.png" alt="123"></p>
<p> $\hat{a}_{v,e} $表示是在没有配置错误的情况下可以从v开始的流到达链路e的总流量也就是：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163648041.png" alt="image-20201011163648041"></p>
<p> S[t,v]表示隧道t的源交换机是否为v。</p>
<p> $\hat{\beta}_{v,e} $表示是发生故障（λv= 1）时链路e中从v开始的流（flow)的流量(trafic)上限。即：</p>
<p> <img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20201011163706163.png" alt="image-20201011163706163"></p>
<p> $\beta<em>{f,t}$，当$f$发生故障时，$f$流在隧道t上的流量的上限，由于我们假设速率限制器的更新成功，因此可以将$\beta</em>{f,t}$建模为：</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163721701.png" alt="1231"></p>
<p>$w’_{f，t}$表示流f在旧配置下隧道t的分配权重（已知）</p>
<p>但是上式约束很多，解决几乎不可能。</p>
<h5 id="3-1-3-Modeling-data-plane-faults"><a href="#3-1-3-Modeling-data-plane-faults" class="headerlink" title="3.1.3 Modeling data plane faults"></a>3.1.3 Modeling data plane faults</h5><p>​    对于数据平面故障，FFC的目标是计算流量分配，以便即使在最多$k_e$链路失败和最多$k_v$交换机失败后也不会发生拥塞。</p>
<p>需要保证，发生的故障的链路不是连接在发生故障的交换机上。</p>
<p><strong>建模：</strong></p>
<ol>
<li><p>$\mu_e=1$代表链路e发送了错误    $\eta_v=1$代表交换机v发送了错误</p>
</li>
<li><p>数据平面故障的情况可以表示为${\mu,\eta}$ ，其中向量$\mu=[\mu<em>e|e \in E],\eta=[\eta_v|v \in V]$.那么对于最多$k_e$链路失败和最多$k_v$交换机失败后也具有鲁棒性的TE要求在下面的硬件条件：$U</em>{k_e,k_v}= { (\mu,\eta)|\sum_e \mu_e\leq k_e,\sum_v \eta_v \leq k_v }$。</p>
</li>
<li><p>数据错误，入口交换机重新调整流量时，它们会改变网络上的流量分布，即将流量从受影响的隧道移到剩余的隧道中。给定故障情况${\mu,\eta}$，我们知道每个流$f$的剩余隧道$T^{\mu, \eta}_f$，这些隧道不穿越任何故障的链路或交换机。FFC要求f的剩余隧道能够保持其分配的速率。即满足：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011163919417.png" alt="image-20201011163919417"></p>
<p> 这个表明，当流$f$的$T^{\mu, \eta}_f = \phi$时，$b_f=0$</p>
<p> 上式保证了没有链路会过载。</p>
<p> LEMMA 1: 满足约束公式2–4,9在故障情况（µ，η）的TE配置$（{a_{f，t}，b_f }）$在所有入口交换机重新缩放后不会导致链路过载。</p>
<p> 证明：</p>
<p> 当发生数据平面故障情况（µ，η）时，流$f$在剩余隧道$t\in T^{\mu,\eta}_f$上的业务负载为：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011164411420.png" alt="image-20201011164411420"></p>
<p> 在链路$e$上的总流量负载为：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011164542058.png" alt="image-20201011164542058"></p>
<p> 得证。</p>
<p> <strong>Robust tunnel layout</strong> </p>
<h5 id="3-1-3-Efficiently-solving-FFC-constraints"><a href="#3-1-3-Efficiently-solving-FFC-constraints" class="headerlink" title="3.1.3 Efficiently solving FFC constraints"></a>3.1.3 Efficiently solving FFC constraints</h5><p> 为了轻松解决大量FFC约束，我们将它们转换为“有界M-sum”问题，然后使用分类网络对转换后的问题进行编码。</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201011165405226.png" alt="image-20201011165405226"></p>
<ol>
<li>Transformation to bounded M-sum</li>
<li>Encoding for largest (or smallest) M variables</li>
<li><p>Throughput and computational overhead</p>
<h5 id="3-1-4-Encoding-for-largest-or-smallest-M-variables"><a href="#3-1-4-Encoding-for-largest-or-smallest-M-variables" class="headerlink" title="3.1.4 Encoding for largest (or smallest) M variables"></a>3.1.4 Encoding for largest (or smallest) M variables</h5></li>
</ol>
</li>
</ol>
<p>最终的结果，效果很明显：</p>
<ol>
<li>ffc的开销可以忽略不记</li>
<li>数据丢失减少了7-300倍</li>
<li>对于不同优先级的网络，可以在保证网络总吞吐量损失忽略不计的情况下，可以保护高优先级流量免受几乎所有损失。</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-为什么研究这个课题"><a href="#1-为什么研究这个课题" class="headerlink" title="1.为什么研究这个课题?"></a>1.为什么研究这个课题?</h3><h3 id="2-目前这个课题研究到了哪个阶段"><a href="#2-目前这个课题研究到了哪个阶段" class="headerlink" title="2.目前这个课题研究到了哪个阶段?"></a>2.目前这个课题研究到了哪个阶段?</h3><h3 id="3-作者的理论基于哪些假设"><a href="#3-作者的理论基于哪些假设" class="headerlink" title="3.作者的理论基于哪些假设?"></a>3.作者的理论基于哪些假设?</h3><ol>
<li><p>具有TE的网络，假设基于隧道的转发。一个或多个隧道（tunnel）在每个入口-出口交换机对之间传输流量。我们称此流量(traffic)为流量(flow)。在入口交换机上配置的相对权重决定了如何在隧道之间分配流量。</p>
</li>
<li><p>Impact of data plane faults</p>
<p> 当链路或者交换机失效时，会影响所以通过它的通道，检测到之后，入口交换机会根据配置的权重将流量重新缩放到其余隧道。设一个流有3条权重为（0.5,0.3,0.2）的隧道。当第三条隧道发生故障时，权重（0.5 0.8,0.3 0.8,0）用于拆分流量。</p>
<p> ​    举例子：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009124937857.png" alt="image-20201009124937857"></p>
<p> 实际网络中的测试：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009130211633.png" alt="image-20201009130211633"></p>
</li>
<li><p>Impact of control plane faults</p>
<p> 说明在配置交换机的过程的延迟或失败是如何导致拥塞的。</p>
<p> 举例说明：</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009125758340.png" alt="image-20201009125758340"></p>
<p> 实际网络</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201009130222759.png" alt="image-20201009130222759"></p>
<p> 所以网络的流量控制改变需要按照步骤进行，上图中，步骤为：</p>
<p> ​    1）更新s2和s3处的流量分配比率；  2）如果成功，则更新流率s1→s4。这样，如果s2（或s3）更新失败，将不会发生拥塞。但是，配置失败将使网络更新停止，因为在步骤1结束之前，步骤2无法继续进行。它们还会降低吞吐量，因为如果步骤1失败，则流s1→s4无法启动。 </p>
</li>
<li><p>Slow reaction to faults</p>
</li>
</ol>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h3 id="1-文章的缺陷"><a href="#1-文章的缺陷" class="headerlink" title="1.文章的缺陷"></a>1.文章的缺陷</h3><h3 id="2-关于该课题，作者的构思"><a href="#2-关于该课题，作者的构思" class="headerlink" title="2.关于该课题，作者的构思?"></a>2.关于该课题，作者的构思?</h3>]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
      </categories>
  </entry>
  <entry>
    <title>PCF: Provably Resilient Flexible Routing</title>
    <url>/2020/09/28/PCF-Provably-Resilient-Flexible-Routing/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h3 id="1-Question"><a href="#1-Question" class="headerlink" title="1. Question?"></a>1. Question?</h3><p>现有的无拥塞机制（尤其是FFC）所达到的性能远远低于网络的固有能力。</p>
<h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method?"></a>2. Method?</h3><p>提出PCF,一套新颖的无拥塞机制来弥合这一差距。 PCF通过更好地建模网络结构，并通过谨慎地增强网络响应的灵活性，同时确保可以对故障情况下的性能进行简单建模来实现这些目标。  PCF的所有方案都涉及相对轻量的故障操作，许多方案都可以使用类似于FFC的局部比例路由方案来实现。</p>
<h3 id="3-Answer"><a href="#3-Answer" class="headerlink" title="3. Answer?"></a>3. Answer?</h3><p>通过正式的理论结果和对21种Internet拓扑的经验实验来证明PCF的有效性。</p>
<p>PCF的方案可证明优于FFC，并且在实践中，它们在整个拓扑中的吞吐量可以比FFC高出平均1.11倍至1.5倍，而在某些情况下可以提供2.6倍的收益。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-为什么研究这个课题"><a href="#1-为什么研究这个课题" class="headerlink" title="1.为什么研究这个课题?"></a>1.为什么研究这个课题?</h3><p>ISP和云提供商的wan经常出现故障，但是网络必须满足日益严格的性能需求。</p>
<p>Many recent works have developed flexible ways of routing traffic motivated by the goal of efficiently utilizing network capacity.</p>
<p>但是这些方案会导致网络在故障时出现拥塞。</p>
<h3 id="2-目前这个课题研究到了哪个阶段"><a href="#2-目前这个课题研究到了哪个阶段" class="headerlink" title="2.目前这个课题研究到了哪个阶段?"></a>2.目前这个课题研究到了哪个阶段?</h3><p>现在大家都研究设计流量工程机制（traffic engineering mechanisms），以在典型的故障情况下主动确保网络无拥塞（即，确保没有链路承载的流量超过其容量）</p>
<p>最具有代表性，最先进的技术：FFC,将带宽分配给流，以便在f或更少的链路发生故障时不会发生拥塞。为此，FFC沿着一组预先指定的隧道将流量从每个入口分流到出口。</p>
<h3 id="3-作者的理论基于哪些假设"><a href="#3-作者的理论基于哪些假设" class="headerlink" title="3.作者的理论基于哪些假设?"></a>3.作者的理论基于哪些假设?</h3><p>FFC</p>
<h3 id="4-作者的工作"><a href="#4-作者的工作" class="headerlink" title="4.作者的工作"></a>4.作者的工作</h3><p>证明了FFC的性能和不足</p>
<p>提出了PCF(Provably Congestion-free and resilient Flexible routing)，一个全新的可以确保网络在出现故障时无拥塞的们同时性能接近网络的固有能力。PCF通过更好地建模网络结构并采用更灵活的响应策略来实现这些目标。PCF解决的关键挑战是如何增强网络响应的灵活性，同时确保可以对故障情况下的性能进行精确建模。</p>
<p>开发了作为PCF一部分的多种机制，使架构师可以在可实现的性能保证与部署复杂性之间进行权衡。</p>
<p>首先，提出了一种使用了FFC响应机制的带宽分配的替代方法，该方法</p>
<p>​    <strong>（i）可以提供更好的性能保证；</strong> </p>
<p>​    <strong>（ii）确保分配不会因其他隧道而降低。</strong></p>
<p>其次，提出<strong>了LS(logical sequence )</strong>，基于LS探索了更灵活的网络响应。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h3 id="1-文章的缺陷"><a href="#1-文章的缺陷" class="headerlink" title="1.文章的缺陷"></a>1.文章的缺陷</h3><h3 id="2-关于该课题，作者的构思"><a href="#2-关于该课题，作者的构思" class="headerlink" title="2.关于该课题，作者的构思?"></a>2.关于该课题，作者的构思?</h3><p>tunnel-based routing</p>
<p>导入</p>
<p>目标</p>
<p>前测</p>
<p>互动</p>
<p>后测</p>
<p>总结</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>congestion</tag>
      </tags>
  </entry>
  <entry>
    <title>Tales of the Tail-Hardware, OS, and Application-level Sources of Tail Latency</title>
    <url>/2020/09/06/Tales-of-the-Tail-Hardware-OS-and-Application-level-Sources-of-Tail-Latency/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h3 id="1-Question"><a href="#1-Question" class="headerlink" title="1. Question?"></a>1. Question?</h3><h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method?"></a>2. Method?</h3><h3 id="3-Answer"><a href="#3-Answer" class="headerlink" title="3. Answer?"></a>3. Answer?</h3><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="1-为什么研究这个课题"><a href="#1-为什么研究这个课题" class="headerlink" title="1.为什么研究这个课题?"></a>1.为什么研究这个课题?</h3><h3 id="2-目前这个课题研究到了哪个阶段"><a href="#2-目前这个课题研究到了哪个阶段" class="headerlink" title="2.目前这个课题研究到了哪个阶段?"></a>2.目前这个课题研究到了哪个阶段?</h3><h3 id="3-作者的理论基于哪些假设"><a href="#3-作者的理论基于哪些假设" class="headerlink" title="3.作者的理论基于哪些假设?"></a>3.作者的理论基于哪些假设?</h3><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><h3 id="1-文章的缺陷"><a href="#1-文章的缺陷" class="headerlink" title="1.文章的缺陷"></a>1.文章的缺陷</h3><h3 id="2-关于该课题，作者的构思"><a href="#2-关于该课题，作者的构思" class="headerlink" title="2.关于该课题，作者的构思?"></a>2.关于该课题，作者的构思?</h3>]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>tail</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-12</title>
    <url>/2020/09/03/LeetCode-12/</url>
    <content><![CDATA[<h2 id="消除游戏"><a href="#消除游戏" class="headerlink" title="消除游戏"></a><a href="https://leetcode-cn.com/problems/elimination-game/" target="_blank" rel="noopener">消除游戏</a></h2><p>题目描述：给定一个从1 到 n 排序的整数列表。<br>首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。<br>第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。<br>我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。<br>返回长度为 n 的列表中，最后剩下的数字。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>感觉不是很困难，然后就想着尝试解一下，然后发现自己又不会写代码了。感觉思路好乱，根本把握不住问题的根本，只能想着简单的例子来凑代码，比较难受。</p>
<p>最终的解答还是很容易的，但是要利用数学来求解，自己没有忘这边考虑，走了很差的路子。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n==<span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span>*(n/<span class="number">2</span>+<span class="number">1</span>-lastRemaining(n/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证明：    <a href="https://blog.csdn.net/afei__/article/details/83689502" target="_blank" rel="noopener">证明方法</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Evaluation of an InfiniBand Switch:Choose Latency or Bandwidth, but Not Both</title>
    <url>/2020/08/28/Evaluation-of-an-InfiniBand-Switch-Choose-Latency-or-Bandwidth-but-Not-Both/</url>
    <content><![CDATA[<h2 id="RDMA-背景知识"><a href="#RDMA-背景知识" class="headerlink" title="RDMA 背景知识"></a>RDMA 背景知识</h2><h3 id="A-RDMA-verbs"><a href="#A-RDMA-verbs" class="headerlink" title="A. RDMA verbs"></a>A. RDMA verbs</h3><p>verbs决定了通信操作的类型。RDMA的verbs可以分成两类，双边<strong>two-sided(SEND, RECV)</strong>的和单边的<strong>one-sided(READ, WRITE)</strong>。two的涉及到两个通信端点，这种情况下，远程主机需要提前发布（pre-post）RECV,本地主机需要发布SEND。one-part仅仅涉及一个通信端点（源）。使用WRITE可以直接在远程主机写入数据，使用READ直接从远程主机内存直接读取数据，并且不需要通知远程主机。</p>
<p>RDMA的动词遵循异步I/O模型。数据传输是非阻塞的，因此允许程序在发布的请求完成之前继续执行。通过向完成队列发送CQE信号，告知完成；应用程序轮询队列接收CQE确定完成。</p>
<h3 id="B-RDMA-transport"><a href="#B-RDMA-transport" class="headerlink" title="B. RDMA transport"></a>B. RDMA transport</h3><p>RDMA提供了不可靠（UD）和可靠（RC）传输类型。  UD传输不保证请求的交付。此外，UD仅提供双面动词。对于RC传输，RNIC使用确认（ACK）来保证请求的传递。此外，RC传输支持单侧和双侧动词。</p>
<h3 id="C-RDMA-execution-path"><a href="#C-RDMA-execution-path" class="headerlink" title="C. RDMA execution path"></a>C. RDMA execution path</h3><p>根据动词和传输类型的选择，RDMA事务遵循通信主机之间特定的交互序列。不论什么事务，每次事务开始时，host通过PCIe的MMIO事务向本地RNIC发送请求，RNIC根据请求中的动词类型，决定处理请求的办法：<br>如下图：</p>
<p><strong>RDMA operations execution sequence：</strong></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201026101151798.png" alt="image-20201026101151798"></p>
<ul>
<li>READ： 本地RNIC通过网络结构发送请求。远程RNIC通过从主机的内存层次结构读取的DMA服务请求，并将数据发送回本地RNIC。接收到数据后，本地RNIC发出DMA写操作以将数据存储在本地内存中。之后，本地RNIC执行另一次DMA写操作以发出CQE。</li>
<li>WRITE：首先，本地RNIC通过DMA读取获取有效负载。接下来，通过网络结构发送请求。远程RNIC 执行一个DMA写的操作将数据存储在主机的内存中，然后发送一个ACK.</li>
</ul>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201026102358284.png" alt="image-20201026102358284"></p>
<ul>
<li>SEND：首先，本地RNIC通过DMA读取获取有效负载。然后，该请求通过网络结构发送。远程RNIC收到请求后，会发回ACK（如果使用RC传输），并通过DMA写入将有效负载写入其主机的内存中。根据SEND请求使用的RDMA传输方式的不同，本地RNIC会在网络（fabric）发送请求后立即发出CQE（UD，图c），或者一旦从远程RNIC接收到ACK（RC，图d），则发出 。</li>
</ul>
<h2 id="IB"><a href="#IB" class="headerlink" title="IB"></a>IB</h2><h3 id="I-InfiniBand-QoS-support"><a href="#I-InfiniBand-QoS-support" class="headerlink" title="I. InfiniBand QoS support"></a>I. InfiniBand QoS support</h3><p>为了提供按流的性能差异，IB提供了一组优先级，称为服务级（SL），可以将其分配给流。IB使用SL的抽象来隐藏其两个有助于实现QoS的体系结构组件:</p>
<ol>
<li>Virtual Lane (VL):</li>
<li>Virtual Lane Arbitration (VLArb):</li>
</ol>
<h3 id="II-IB-SWITCH-LATENCY-MEASUREMENT"><a href="#II-IB-SWITCH-LATENCY-MEASUREMENT" class="headerlink" title="II. IB SWITCH LATENCY MEASUREMENT"></a>II. IB SWITCH LATENCY MEASUREMENT</h3><p>IB网络可以达到10微秒内的延迟，导致测量需要很准确，但是如此低的延迟为准确的NIC至NIC延迟测量提出了一些挑战。主要挑战是将交换机的延迟与其他组件（尤其是软件和PCIe）隔离开。</p>
<p>解决办法：</p>
<ol>
<li><p>理想的：直接通过交换机测量单向端口到端口的延迟。</p>
<p> <strong>代价</strong>：需要使用昂贵的数据采集设备</p>
</li>
<li><p>另一种：端点上使用精确的亚微秒时钟同步。</p>
<p> <strong>不足和假设：</strong>基于两个方向上的单向等待时间相同的假设，在拥塞情况下，尤其是在聚合交通模式下，情况并非如此。</p>
</li>
<li><p>ping-pong style test: 获得软件中的往返时间（round-trip time:RTT）</p>
<p> <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201026195810000.png" alt="image-20201026195810000"></p>
<p> 问题：</p>
<ol>
<li>远程：远程端处理的偏差，而且是生成和传输ack所必须的，远程侧处理包括用于生成响应的软件开销以及用于向RNIC传输数据或从RNIC传输数据所需的PCIe事务。但是不会影响真正的网络延迟，所以需要排除在测量中。</li>
<li><p>本地：本地处理延迟，软件捕获到的是请求的发送时间而不是传输时间（transmiting time）。所以会造成测量偏差。</p>
<p>相关工作：</p>
</li>
<li><p>RDMA Bench </p>
</li>
<li>Perftest</li>
<li>QPerf</li>
</ol>
</li>
</ol>
<h3 id="RPERF"><a href="#RPERF" class="headerlink" title="RPERF"></a>RPERF</h3><p>​        细节：RPerf测量本地主机和远程主机之间的RTT，并利用RDMA谓词来准确地测量延迟，而不包括端点延迟。接下来，我们描述RPerf设计的关键方面。</p>
<ol>
<li><p>Excluding remote-side processing：post-poll方法</p>
<ul>
<li>利用RC传输，远程RNIC在其中生成响应而不涉及目标主机，RPerf避免了远程端的软件处理开销。</li>
<li>使用SEND verb ，排除远端PCIe的延迟，SEND使远程RNIC在收到请求后立即生成对源RNIC的响应，而无需等待PCIe事务在远程端完成。</li>
</ul>
</li>
<li>Excluding local-side processing：<ul>
<li>local-side processing overhead：actions at the local host and the RNIC    </li>
<li>解决：发送lookback message，通过本地RNIC从主机发送到自身的消息（over-<br>  the-wire SEND）</li>
</ul>
</li>
<li>RTT calculation:同时发送两个消息，一个是over-the-write，一个是lookback message。</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200829090835329.png" alt="image-20200829090835329"></p>
<script type="math/tex; mode=display">
RTT = (T_W-T_P)-(T_L-T_P)=T_w-T_L</script><p>额外的技巧：为了最小化由软件引起的性能差异，每个RPerf线程都固定到CPU内核，并且为所有必需的缓冲区分配了巨大的页面。为了准确捕获事件的时间戳，RPerf通过rdtsc  x86汇编指令使用时间戳计数器，该指令在用户空间内提供高精度的时间戳测量。 RPerf遵循英特尔关于TSC校准和访问的建议。  RPerf的多个实例可以在不同的服务器上运行，并且用户可以指定流量模式（例如，一对一或多对一）来测量系统的特定方面，例如零负载延迟，峰值带宽或负载延迟。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><ol>
<li>Hardware testbed</li>
<li>Simulator</li>
<li>Traffic pattern</li>
<li>Metrics</li>
</ol>
<h3 id="性能表现"><a href="#性能表现" class="headerlink" title="性能表现"></a>性能表现</h3><h4 id="ONE-TO-ONE-TRAFFIC"><a href="#ONE-TO-ONE-TRAFFIC" class="headerlink" title="ONE-TO-ONE TRAFFIC"></a>ONE-TO-ONE TRAFFIC</h4><p>对照组：有无switch， Perftest and Qperf.</p>
<h5 id="A-Latency-and-bandwidth-without-the-switch-AND-B-Latency-and-bandwidth-with-the-switch"><a href="#A-Latency-and-bandwidth-without-the-switch-AND-B-Latency-and-bandwidth-with-the-switch" class="headerlink" title="A. Latency and bandwidth without the switch AND  B. Latency and bandwidth with the switch"></a>A. Latency and bandwidth without the switch AND  B. Latency and bandwidth with the switch</h5><ol>
<li>RTT</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028203924233.png" alt="image-20201028203924233"></p>
<ol>
<li>Bandwith</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204009514.png" alt="image-20201028204009514"></p>
<h5 id="C-Latency-calculation-by-existing-tools"><a href="#C-Latency-calculation-by-existing-tools" class="headerlink" title="C. Latency calculation by existing tools"></a>C. Latency calculation by existing tools</h5><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204412779.png" alt="image-20201028204412779"></p>
<h4 id="融合流量下的表现"><a href="#融合流量下的表现" class="headerlink" title="融合流量下的表现"></a>融合流量下的表现</h4><p>在这种设置中，数量众多的BSG（从1到5）将带宽密集的流以4096B有效负载的大小发送到一台目标服务器，从而形成一种融合的流量模式。同时，LSG将对延迟敏感的流发送到同一目标服务器。</p>
<h5 id="Latency-of-LSG"><a href="#Latency-of-LSG" class="headerlink" title="Latency of LSG:"></a>Latency of LSG:</h5><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204658627.png" alt="image-20201028204658627"></p>
<h5 id="Bandwidth-of-BSGs"><a href="#Bandwidth-of-BSGs" class="headerlink" title="Bandwidth of BSGs:"></a>Bandwidth of BSGs:</h5><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028204706756.png" alt="image-20201028204706756"></p>
<h4 id="尝试保护延迟敏感的流程"><a href="#尝试保护延迟敏感的流程" class="headerlink" title="尝试保护延迟敏感的流程"></a>尝试保护延迟敏感的流程</h4><h5 id="A-BSGs-with-different-message-sizes"><a href="#A-BSGs-with-different-message-sizes" class="headerlink" title="A. BSGs with different message sizes"></a>A. BSGs with different message sizes</h5><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205112105.png" alt="image-20201028205112105"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205133251.png" alt="image-20201028205133251"></p>
<h5 id="B-Packet-scheduling-policy-at-the-switch"><a href="#B-Packet-scheduling-policy-at-the-switch" class="headerlink" title="B. Packet scheduling policy at the switch"></a>B. Packet scheduling policy at the switch</h5><ol>
<li><p>FCFS policy:</p>
</li>
<li><p>Round-Robin policy:使用RR策略，仲裁器可以在每个回合中选择一个端口，并在该端口的开头选择数据包。在这种情况下，每当LSG数据包到达时，它最多等待活动端口的数量。</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205219090.png" alt="image-20201028205219090"></p>
<ol>
<li><p>Packet scheduling policies in a multi-hop topology</p>
<p> 我们将模拟设置扩展到两跳拓扑，其中一对交换机连接在一起。两个BSG和一个LSG连接到上游交换机，三个BSG连接到下游交换机。目标服务器也连接到下游交换机。所有BSG都将4096B消息发送到目标服务器。</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028205655531.png" alt="image-20201028205655531"></p>
<h5 id="C-InfiniBand-QoS"><a href="#C-InfiniBand-QoS" class="headerlink" title="C. InfiniBand QoS"></a>C. InfiniBand QoS</h5><p>使用专有的SL</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20201028210109093.png" alt="image-20201028210109093"></p>
<p>区分流类型并为每种流类型分配优先级可以有效地保护对延迟敏感的流。</p>
<h6 id="Gaming-the-dedicated-SL-VL-setup"><a href="#Gaming-the-dedicated-SL-VL-setup" class="headerlink" title="Gaming the dedicated SL/VL setup:"></a>Gaming the dedicated SL/VL setup:</h6><p>带宽密集的流假装成短消息</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>IB</category>
      </categories>
      <tags>
        <tag>IB</tag>
      </tags>
  </entry>
  <entry>
    <title>学习MakeFile</title>
    <url>/2020/08/21/%E5%AD%A6%E4%B9%A0MakeFile/</url>
    <content><![CDATA[<h2 id="一、Why"><a href="#一、Why" class="headerlink" title="一、Why?"></a>一、Why?</h2><p>​        最近在学习oMnet++，经常需要用到一些工程，里面有很多Makefile文件，经常会出现报错，尤其是在安装软件的时候，经常遇到，平时遇到的可能都是利用工具自动生成的，问题比较少。</p>
<p><a href="https://blog.csdn.net/weixin_38391755/article/details/80380786" target="_blank" rel="noopener">先放链接</a></p>
<p><a href="https://www.w3cschool.cn/mexvtg/adisqozt.html" target="_blank" rel="noopener">w3school的教程</a></p>
<h2 id="二、-程序的编译和链接"><a href="#二、-程序的编译和链接" class="headerlink" title="二、 程序的编译和链接"></a>二、 程序的编译和链接</h2><p>​        一般来说，无论是C、C++、还是pas，首先要把源文件编译成<strong><em>中间代码文件</em></strong>，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做<strong><em>编译（compile）</em></strong>。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。 </p>
<p>​    <strong>编译时</strong>，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。<br>​    <strong>链接时</strong>，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“<strong><em>\</em>库文件”（Library File)**</strong>，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>
<p>   总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）。</p>
<h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><p>Make命令直接用了这个意思，就是要做出某个文件。make是根据makefile中的规则来构建文件的。</p>
<h3 id="Makefile文件的格式"><a href="#Makefile文件的格式" class="headerlink" title="Makefile文件的格式"></a>Makefile文件的格式</h3><ol>
<li><p>文件格式：</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p> 上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p>
<p> “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p>
<p> 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p>
</li>
<li><p>目标（target)</p>
<p> 一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p>
<ol>
<li><p>伪目标</p>
<p> 除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">      rm *.o</span><br></pre></td></tr></table></figure>
<p> 上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p>
<p> 但是如果目录里存在了clean文件，那么make会认为文件已经存在，没有必要重新构建了，就不会执行指定的rm命令。</p>
<p> 解决办法，指明为目标：</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure>
<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标</p>
</li>
</ol>
</li>
<li><p>前置条件(prerequisites)</p>
<p> 前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p>
</li>
<li><p>命令（commands）</p>
<p> 命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p>
<p> 每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure>
<p> 上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p>
<p> 每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>
<p> 如果需要在一起使用:</p>
<p> ​    一个解决办法是将两行命令写在一行，中间用分号分隔。</p>
<p> ​    另一个解决办法是在换行符前加反斜杠转义。</p>
<p> ​    最后一个方法是文件头部加上<code>.ONESHELL:</code>命令。</p>
</li>
</ol>
<h2 id="三、-Makefile的语法"><a href="#三、-Makefile的语法" class="headerlink" title="三、 Makefile的语法"></a>三、 Makefile的语法</h2><h3 id="3-1注释"><a href="#3-1注释" class="headerlink" title="3.1注释"></a>3.1注释</h3><p>​        井号（#）在Makefile中表示注释。可以单独一行,或者在行尾.</p>
<h3 id="3-2-回声（echoing）"><a href="#3-2-回声（echoing）" class="headerlink" title="3.2 回声（echoing）"></a>3.2 回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>
<p>在命令的前面加上@，就可以关闭回声.</p>
<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p>
<h3 id="3-3-通配符"><a href="#3-3-通配符" class="headerlink" title="3.3 通配符"></a>3.3 通配符</h3><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（<em>）、问号（？）和 […] 。比如，</em> .o 表示所有后缀名为o的文件。</p>
<h3 id="3-4-模式匹配"><a href="#3-4-模式匹配" class="headerlink" title="3.4 模式匹配"></a>3.4 模式匹配</h3><p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br></pre></td></tr></table></figure>
<p>等同于下面的写法。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">f1.o: f1.c</span></span><br><span class="line"><span class="section">f2.o: f2.c</span></span><br></pre></td></tr></table></figure>
<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p>
<h3 id="3-5-变量和赋值符"><a href="#3-5-变量和赋值符" class="headerlink" title="3.5 变量和赋值符"></a>3.5 变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p>
<p>调用时，变量需要放在 $( ) 之中</p>
<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p>
<p>有时，变量的值可能指向另一个变量。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">v1 = <span class="variable">$(v2)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p>
<p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-内置变量（Implicit-Variables）"><a href="#3-6-内置变量（Implicit-Variables）" class="headerlink" title="3.6 内置变量（Implicit Variables）"></a>3.6 内置变量（Implicit Variables）</h3><p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，</p>
<p>$(MAKE) 指向当前使用的Make工具。</p>
<h3 id="3-7-自动变量（Automatic-Variables）"><a href="#3-7-自动变量（Automatic-Variables）" class="headerlink" title="3.7 自动变量（Automatic Variables）"></a>3.7 自动变量（Automatic Variables）</h3><p>Make命令还提供一些自动变量，它们的值与当前规则有关</p>
<ol>
<li><p><strong>$@</strong></p>
<p> $@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 </p>
<p> $@ 就指代foo。</p>
</li>
<li><p><strong>$&lt;</strong></p>
<p> 指代指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。</p>
</li>
<li><p><strong>$?</strong></p>
<p> 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p>
</li>
<li><p><strong>$^</strong></p>
<p> $^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 </p>
<p> $^ 就指代 p1 p2 。</p>
</li>
<li><p>$*</p>
<p> $ *指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，</p>
<p> $* 就表示 f1。</p>
</li>
<li><p><strong>$(@D) 和</strong></p>
<p> <strong> $(@F)</strong></p>
<p> $(@D) 和</p>
<p>  $(@F) 分别指向 </p>
<p> $@ 的目录名和文件名。</p>
<p> 比如，$@是 src/input.c，</p>
<p> 那么$(@D) 的值为 src ，</p>
<p> $(@F) 的值为 input.c。</p>
</li>
</ol>
<h3 id="3-8-判断和循环"><a href="#3-8-判断和循环" class="headerlink" title="3.8 判断和循环"></a>3.8 判断和循环</h3><p>Makefile使用 Bash 语法，完成判断和循环。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">  libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(LIST)</span>; do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">     done</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in one two three; do \</span><br><span class="line">        echo $i; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>
<p>上面代码的运行结果。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>
<h3 id="3-9-函数"><a href="#3-9-函数" class="headerlink" title="3.9 函数"></a>3.9 函数</h3><p>Makefile 还可以使用函数，格式如下。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$&#123;function arguments&#125;</span><br></pre></td></tr></table></figure>
<p>Makefile提供了许多<a href="http://www.gnu.org/software/make/manual/html_node/Functions.html" target="_blank" rel="noopener">内置函数</a>，可供调用。下面是几个常用的内置函数。</p>
<p><strong>（1）shell 函数</strong></p>
<p>shell 函数用来执行 shell 命令</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcfiles := <span class="variable">$(<span class="built_in">shell</span> echo src/&#123;00..99&#125;.txt)</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）wildcard 函数</strong></p>
<p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcfiles := <span class="variable">$(<span class="built_in">wildcard</span> src/*.txt)</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）subst 函数</strong></p>
<p>subst 函数用来文本替换，格式如下。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> from,to,text)</span></span><br></pre></td></tr></table></figure>
<p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure>
<p>下面是一个稍微复杂的例子。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># bar is now `a,b,c'.</span></span><br></pre></td></tr></table></figure>
<p><strong>（4）patsubst函数</strong></p>
<p>patsubst 函数用于模式匹配的替换，格式如下。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br></pre></td></tr></table></figure>
<p>下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>
<p><strong>（5）替换后缀名</strong></p>
<p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">min: $(OUTPUT:.js=.min.js)</span></span><br></pre></td></tr></table></figure>
<p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>送别歌</title>
    <url>/2020/08/20/%E9%80%81%E5%88%AB%E6%AD%8C/</url>
    <content><![CDATA[<a id="more"></a>
<div align = center>
    <h2>送别歌 
    </h2>
    <div>
    李叔同
    </div>
    <div>
        长亭外，古道边，芳草碧连天。</div><div>
    </div>晚风拂柳笛声残，夕阳山外山。<div>
    </div>天之涯，地之角，知交半零落。<div>
        一壶浊酒尽馀欢，今宵别梦寒。
    </div>  
<div>
    长亭外，古道边，芳草碧连天。
    </div>
<div>
    晚风拂柳笛声残，夕阳山外山。
    </div>
<div>
    情千缕，酒一杯，声声离笛催。
    </div>
<div>
    </div>
问君此去几时来，来时莫徘徊。<div>
    </div>
草碧色，水绿波，南浦伤如何？<div>    
    </div>
人生难得是欢聚，惟有别离多。<div>    
    </div>
情千缕，酒一杯，声声离笛催。<div>    
    </div>
问君此去几时来，来时莫徘徊.
    </div>



<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=26090155&auto=0&height=66"></iframe>
]]></content>
      <categories>
        <category>诗</category>
      </categories>
      <tags>
        <tag>歌</tag>
        <tag>李叔同</tag>
      </tags>
  </entry>
  <entry>
    <title>8.14计算机年会</title>
    <url>/2020/08/14/8-14%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B9%B4%E4%BC%9A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a654454a0759ff1ba12772d83a41ef0f3151c2b7640b47a36b43448b6ec2109a">165d50f05814027fb7fe5e4ae8a088d8263bd5e76b5699d69250a6c479a3dd32862a231d53a998d3ca8ffa98ee46df10fadad02dea13077c72a6d534fe46c47fcdda3875248d0c0f8c47851f247b27e84fb3c0cab1e5c34f1db5b73493d18d8c1eebdbac01aa842bf7c8bf20a37c6d54531dd57132ce4b06b915b61df1cccf14b552138ce82f0bf05c6a05aa5070111a9acfdce127b2c28b8c31d792166048eab93cbd1a4b39e92c07b3d33132cc96f878d8144a61ba0bf959bdc1554c9e1d5f65f30ef369e3972f3aa3264af455633c9a312800dc1b13b6fef388970c8ff6f6381e28342261a4a83be79bef1977cc38ea02bc85509d33d244594fc7ba91be519d331c96fa54aebeb14a9fd0cb4b467a2bd29ed3dfe6d463a434ed7658881651b4632dd41c3aacbbb921103a12be991d5ed1b75f0291bd3f24534072c673285f430d5470799129196c263b5e1853d53819d654701ae814fe74b97ada236525e066c455138bc0abf595c55c07b6f3cf8729637bcbbba914fdf854e368e4d342e7dfca8de4c7a9df830e8e8505f8bbc51e31f38dc50612b41ea6556b246d5ac0fb60743880fbc41bb94dacef236e6fab53884fcd4abf1c78c19bc9c10de452c1ac3ea1af6fbb3f2b2b2d0940562feaab19d4d1f73fa0d2d362b56dbcee889aa3d9a2ae6ae039d523cc9584f90881eb014c0b36f25abd377b3c21648d1c9cb9c07b86a74eff35eaa1bd07645c0cf0eb7cd0a2c40179d9355d8fef4e7ea6e463ca5549a7344efa1b7f6da8f53ad7100242ae43a7cc385fc9f3230178a276326375836556499b2dff01a3b5b59797a62cbe1d347d670958999f6c15510f0a28c25f988305506153cefb88582b7f43e124a4d088d9a7e7c37bfe42248118fcdc05614a489c4a9eb410fc8ce0ee8167fed190b618e190209a804936b412759e74ff79796ac41b113cb3b2ea73ad6a3ea3779059f1ec9af5426bf2e7079c65ea2ee5b881bccfcb0b6bbdeada2396d2e04d5724a33044047140d12fbb155e894c2b9b7e255f8bea3423f3c0c93d3e32354941ec081c587fda02891e070b296fff76158df0cb7cd6de66893f6909ca80b9ccb73596fa1d6282dd2c9cf742364627c59ba5be00481ce2285de84d29ea676d0cabc57aac5ac250f551e5d7fb0ef6eebe1b4d9e6e8e599b0553992b5046258f531f88e5beb77fcc795894b3f414adfa75b8c8880e7ee8d9d503b1540f0bd6b1efbfc575022c25d36a6278a0576ec06c4c56703569c670d2ec58d06000e33702f8eb41df31532ab047fb440b7378447d469e7e9f42c9251b947b35734921b882ca1e00c41339dafe33dc4ecd7218c365da03de980944795900e7cb2820e5cf53695d6306e6cb25171e68db7acb367fb972bd7a07fd00cd3b3f71d59f62b30cf350489db4f1cb1684c32198454792d222517db4d8ea46c96dea58617c072acd3033edaa08aefe559f2eb70e391d74cad6aed34320bab0e1f85cc92217825c375056c147b3f111ae945b5085ec570ef66b08b2fbc16216370d1be85e994e73ba17b7db6bdcf3a8c8774fdfbb0f8845d9c079f4fcbf60e3104466d9c62c7a18c00f14b2e3a2467758b7c08f91df25706e3c835d5d9fb543b544ce007567f9e87d6bf328d9b9583889a5201ba8b66ef594c720712e04b63883c71d1157de75f0f85b8f1e49d3d477b87efde279a409f9c3ae314c74101179130a00a6f34ded3012d63c1110a50ca98bd2b28c5f6292fc77f5cc8faad9c3533191092d763f82c9ac21ae1dac15dcfdee4a72ff7ad3dbab706fe08957a75db6e60a46fb7cab6dd68264880ac7b1bea9d3c6cc14c9a2f080e1cf0761b8cc7541204e7dfc35c4a3bb5f3da7dfbdecd0a1aefcd4f5fdcf4a5b23e3ede5f0a9c51f89748697f72c57bb79c50c2f820b361e17efc9301b79077f4ea4ed414632b29e5421a68f6ede69b594c32f3808b9cf11c948b72ca79948efac8c5d20dc43401be7a622e3a90427f743f8453f42dea90cec24fe67b6f2fb9322ddc891ed7c26a7bbe64495fb9c0a4a24f9c96947bb7c2e1dd6d497ac5a01f993d14d6855307e00fa069201a067e84073ae99433d7f9dd6bb67d1d4b0bd1459800d15cbc8c1a09c78b95c271351ba6668ba4a454768ce500be4f03891b7472be298832ed1efbfe8032378c67d1759f55927a70e94850e73d0db6cda8067091baaab5b2d43e16fb376fac885dd1b1bcf8d2e136e7e464a9756ca40fbf59ae842c9aebeffa3b8c4ce420a68198ea668d7afc29d85824de187abc0d91aa79115c889eaa63ce435ada2f3a00cc937f14d10f44b7fa7be37a56e6bd98281f6342677cef689dfb7f5083eeed9ea20b7f23c56ac49a1939a1dd5fd1b3711fc10d4a1cd56c5839656c073bb58e2c4919113de48b9b8562bb3d2aa8da4e9bf6cb53922643ddc3a3d46f8bf446c5c7479f2a67ec338637f66696218bb5bbf9606953a4fbc00d27fdb7962f5e0993ac68bba94647fb6574f683ada8ddb8a00169ecfca6de5d5c2ba2a45fad31dc976477051f026e4c215be4234760b86107b8df6555e69d46e4fe8b78e5a9a25fe367e31c8e3d328db1d25fafea34bec994372c1ee42cf818c6d781fee79213472864d9ea31cf0aed18649b66639feb772d1793fbef8884bf0e04926522d5054a59e0b93a782af6310e187e221553b253c571d8f090ce931029289a26e692628e5b5b5d52640c1f529d6f8c5c42298906f8b7545c24fccbc1e19b3d59407f8b36911b0f04fa2cffca31bbb2135c1c227b74ecb2d37bfad619486040244055b0582cca0eb51c8af65749fbd81a7a0077e15688b49d6e468d41e5560e8c9ce52bc8ca626c17cf0dc58d3b45934a23558ab7563c2560cd11b3e3c72cecf393753ff962743a734b57b7a802dae2e5cea36c38c85f1aa6cb2c3f57ab71ded43e432e9ee6e70145a4d58d35dbe25a9766cd2c347b967de0662d941e6e25c99275447baecfced36f23e2cd14b4350c206e1351382effc7dac3a945354d2139e5a5608946d706c7502acf28586ed894bbaca139357f34179e7006344aa0d0d0d3f315aa24a4bc379cfbfad6cb0217960009caee843f4f90da8a2346edcab71eb87917448aedc547ab9727f606f22780ec48b99ea7a8bb2d658809f22884fcd72e0244f30391266c58b6c32f1f2054d44d3c336ea92abb42665d2b624a4e9a87b9b1be97ee02fc7b9c2241eabdf7785a14bd4aec95a42e1e66a3c0896b94da6c545af371cf108da005f04de5c5505dc77ba0424762a4b8cd70145746d989e28f06c9271140e8837848ef1c0883319cf506d217fbb7763f383c6e0569084f37ac9a298358ce310998c2fd6d35159a0f43faffa3b2cc053b0b3dfcaf2ad104395dd5502abbfd4515cf088071cc748a2abe539c6668ee1597ed3ca5aca07069882c7973ba12df02e3b7359488489ee028cb10ada98cca675e0cbb25dd2beaee2084f373d1c95aeb5879150c386f320b49e174a57fad21060d65fe29223f98e5d7bb4291d35b1a062b9f56ad680fdc2bdb524e9ab43fd876a59e61a8d1a0b06c4a2c8f29e45a3f8d30b393aaadc773ec0184cf8dd3939d22739940e490cb078169865d38edd78ca62f6959b3e295bf37845ea8fe58fe6c7470a37f81099732744a6bd377274759d3b8e97b6816af55aeeafa294e35036ef73d5698b7587ef6af14e663ad82391847b57f1286883e819357841b3f16e85d28c06fe3354e84a7a1abf0b2857e31e048d09f06767f777cbfcbdfb2e3392a9058859e991a53c059d80335477c5b5deab3cd78390c4454ea91d72424bbb1d33a8a99b61bcef8332af396a450f393cf10e0f195c6d55bdda125e6156e8a8bc75415d73339b283a4a5b8816ce7e472d172d914bb8e956f149670754c296d84772814c09b3d955fbc7a197296ba13dabd2725dc70ee01f80d15a31a22c494713de48f193c005d4a1a725df0854f98881c2cdfe88ac6cecfcb5c27f97831ffe4b267eb5836a186be2a346898591e207ac72c87e0204c538599e9083c0e8cea574429a7a25b368c67ec405b4b7eedec0e9dc7a3e9bfffbc151b4beaeb67102b3af90cd738a5964053c4823209af8cbbea39ee12bd145429f92b22dcfa0ebac58eb29cb0941c18d0a87ea75dc6d143536853d28cd7a71dfdcaf2e55e1a4386dd59fa5828d3c54eb8adbbc3bb6a41aecfa795c8665da041baf82272a9949f948ba57a4953628438f3b4b9d671f4f41b2c8856bd4252165f72c1dafd2d616561d97f6c0b721988ad3abd06c2f93f6870dcb55bdac446769a1217055ee612104fafb84dc365c6b2aab93bfe812adb41044a340008c6d97edd0487961417e67877c9cb742bbf761ce5362612a61932a166194c5c15d4f9acf7eb28e5692bb88859f6052fdac5dcff120771b831f9f000fb89a548c41017aab590f0845b487a1869adb649d4bfeb37348df463ecf82b4b06be4a7f48375bd925f1cd27bf776b62502d1c2bb6842c6723d4e0963ee63f9cd2aba650cb934f2e332e2049a65ca4791d6212331c714283c783605ddef8a94ccaf9a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>一次计算机体系结构会议</title>
    <url>/2020/08/13/%E4%B8%80%E6%AC%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BC%9A%E8%AE%AE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c032893c2b8c9c54093468b16261dc36e05fbbab22f74b09ecefa16eed35b3ec">bee165724e9d24650c72d2b35b712e0a848a0a07c06a33b8041a5c710b3a077aed2ed51b4d02e322a513ffc4c868eb3f053c90b3b95b21bae0c60a66a82fcda6b4017070ea82e540f681a2ecd1a75d2f8be2380edb9271eb3e05eaf00e38d880733ecd9e3a1a5fda03799c00404f2ea59c94b71dc38b8bc8cf32d430faf61ca45e34792dd8245370272ed70ac11a6c3469ade01765b273642dc6e997f7bc6c6578df668631200ce67f3afd2cf4ee9fa2dae346f015120247289d0707defd5354d629bf349db050006c226a239d4eccc95cbaef7174ae03a161a798f485f7cc7e32abd5078420958157bfaba58a0d90b22a5ae4fd94bc29b2a2fdc49317ad39a10c1ae2895773f419c1a58789c60b38e3f8d23ed89b62022d19fcedf4963e5a839657388f4e1c18041485f7f758e2041d10a9e53452f1c5f400cf8c61882867b9fc6fb44c5c03311759c2b3c2b5c65047631f6ac41287ef7b24b321e49438a02d8ce2a25a9a3320cb055e92c1031f3808cf39660c398d0ab9a0595915f8e6b8f4871721e18c8b8271219fa53e8ca49eb65a63f8a0c9f59ff714101ddc32304c9fbb11b9320bef1e6c2062f098281a371bc0ecf2f340e78114897fac062fc37b2162133ef4ecfe0dc9e3a69666831beacb33619755c5804736c397e1172e8fd013d8be4aa862633796cbfb6da44aa04bc10caaa2895cf9ef8232965e929471b1035dd783c6e81f5c59809501c9e87262b7f598ccab516dd69c39e77c8aa58d7fad2d8095c260743e0b59e4143c9e6b7a172988aa70e9900b7ab062026788e65c129df526f95912a8b6fe2ce0752012dbf55e7e61f8bfccbb5f7083db0673b7f42753625a42ea66adef8db3302944acd79b50fc7bc95397e530f66885de588dffb361d178886609a5e58a36bc4add9d244dbac3f728e1fbf2dfdacfeefd3c7dca3b4a17f1123c4566c6b42e9dbbd09969ebb03cbd2048a8e4a88a8b5bf58328cc7fa41892602cbe93a9693559c554f7ea9bd9a783e388b434177014ff4ae9eeebf4a64960065244f58f574f61ef6245f41ff634e270644f6492c5bf4ae79f1cdfb11e8be1ffd2b16f71356a38ce2fa372e3c8a9622d9fcc60dadb0d5d814abc520bf4b33206b2432a0ee59cc6084341b62810c8add305a7a5e166ec38cd304fef06b246a3b16371f771f639dc15c713b14cec96fcfcd267904b5476943b62e9b24d573c4803f64764d8e40b13debc2d9733f2d544f3a180b2e976fd7cf3c1ebe41c23407718b9d5ab1717cd9b330f24b6995c1c3eb305b6f707ee1dce332dd2fdba8cb6419136a78360fe96afcc5d72e5d4853b3db75dae88017d97431d128f82357bfca9ca18f0e2066c2dc166d3dc956ead7a3c76cc7b3d820d9771831e7ca598c7be2cffd2ce170ca7906b793b2d43034509a0106a22f4833c8c41f9fbba6c605abbc1b467dbdc214fe4a287f294be33190030a069d20cd8e56d654add245f8ad4f17873edb42e1cee05f6cbbe2cc82ba3fb334d7b9ce3d5a2ef346de1342cdc4780f022d91a6ff43fcbbdd8101a9c9749af32904a6c0daa9f09cb534366a92577bd38cc19314f9665e40e5353637eedc61774460456fbf9c23dc571c4b7fdaa06331f138c621790a6a2b16531bf4178a8f7a9acc1456ccb50e9b56bbaf0470344d169668a0f0440c08e13d87bdf3dca9dbc2705a6a504e78fa233063ce967972a88559f029c82e1ad682b923efaf197e782c31b8b42dca386beb7195e51481e05dc1fdf23626fd382387f256518e8e1e5cf652494f064e78434ebfa4b3b6bc851b2a8a5ad48adac84e70f5f44ad6c14cf77aa0fcc9b70331fcb75c5541939ceb617c1ed35d5718acb1598d808274d198eaabf5fce4b49cd455781a67c4011dd0c8c4538c1875c6ce0b104c5beb74bf69729d134af16bf9772e1329e777d1abc4032293700c6ea8cf294e03dfb0947d1617805dc8005cf6fc4560e2c4cca2963da0f89b9d450e3af2436c3833b8feefaa3f46802ee0573592579802ff100675850a1c09713e255c672f449987e75f32ac0e4f879a1f81cff532c3870a23d60c9ba132de7ed44faf2122f0df9b4f032a139c07855712d4ded65b898f5412f8c7e53c8be11006c26803dd0a5b5892def786c6fcb2d37bb2d74c22a2629ef944e2f71ae94a070bd85307159c6ea0b92ba8056e1b3cb67943b84155d4bd6989e6c63036237c8a961557ce6033489db6a23a70b7b73baa1e9e6a8747058b8b6e2d86aacaa94cb614930821d483578241bdf9cb274972d6ca3a6d642d830723fedf7451648b1ae5c5fdb868e6d401c355683f4cf8a29a625f68a9c7704d760fc31fba64a69fe4a0add8e925b55c3ecf62e9dcd537f4accf1d140a6ad96edf4bdbf7ecba4f803de6227425222141f255394a5624b339a8cac6ef5b6d06057d00e8a0ff017cc1e7d1b578860aba50f9a8bd313df6c11d890c685c190fce3cd3f0a558aed41baf8f3f849b415f82a892e45821540912695bae4ac035d826f2305835707d7531b421b7eae9fc2c4f1a6cbe7da1b1b2e800042f889d89e160ca36980655493c774f80bc755b21967660e585ad90d6079565950cf7507016a19dee51db93cbf37434f6fde10a9460d7f8ff18c2019ffd1ee0fbd8d38ca653e62b595317197b7f5c20d8498525504517faa1e8fe60f46b36bc68becc1704b0e513efb3117cf257ccce794de3a13789a935823ea7ac2f06affea8e6618eb46167abaf3c209d06fbabda9d6026bdb00215cb0ace40223c54cb41b1e6f66c03b29ef7bfcb2765d4dcaf796b07c1340b5a8abe08427e39f72f9e2fd7f4999acf1950ac2a5fb44720211838cc869cd4d27b2b5c42441ea28f448a48ad695b332c583565e82b82f0bd864a2d84ed76f88644d6b099f5505511e43d899d28296f233a135a4d76e491a9d887c2127e0f3902e900427b2f9732a42f9959ac76818d3fe3afede11517e08d4f51103d4a57567ebf16b61f59a490fe3ac7205e2af7fce68887282389d641a89d75eff619f791bc4bf2e24f1fe8a3669396011024a2d05f4fe79ae4ec64a79602582b839e03a9e5c98bbeba3f5cec3facce19040ab8285f346d30c918356af621671d483c2b45f8122222fd691f35fb213e5cb8e6f713513b0c1882a4018413906fca03c185d45c4ea0163b178b6cdaa60122e930f7f1df7b44ef1a464283dbd9bfb3950e54875d3cd0c873d2f6c042e2e2af1831783ef794659456a8419d02eda8368791dcc9429a52271081b5ed8c20e547d71f386e9538c2b074eb75fe22f5acddfd2844b9e88caafc000b905cf0faf0f3d204fd997cc5b2b0f518512902eb85b38908c5487aa2153f1c51358bc937b3393a1ca2e825f052ff6364de4763248d44b34c4d208b8e4e0facdeb139e8a025a219fd07fa87cedd21080e01e82178e3709c5a9c6815c2912e60287a9fde0c056ba1ebc046741e1e479b9bc3d45e2f53488fa2114520b39406ced377215c6b3f9cebb53ae28d0781ea6f7296bb00a34d983a6fe318b16f45e09645b04182f877d7d68e1b336e465906986ed58ca796bacf40a3d220205359036d4268074acd2f6af4b7261110d7794f2b7e4844c0c4fe6671ff860a47020dfaf46ed1bfd75de5456445de7ecb001bfd39e292eef9db56e4736a7a73faa7e7ed34f979b0bc0234df63fb9d52a5b04044045c08f03accec9ee6966b959f51e7d678c278a0ec6be2c5186435a1cae6551214e65bace76aea67c6ce3d631eed073dad3661c9688cb6d9e4d5ba889bcb14ba54c13fdcd1c57a0f7518788410e03e09c461c703e6d1b4601c10e3928be32b36ea5322a67db066657e982c994b2c7c42e8db4cdb0faa1cea946f6eb87878828ea2417de765a5290d99aab8867e6b1b5ed1fd8c360f83bb2f896d6e68c5768f1db261f0d0f46760a81fba00b268e4c9d3e99a171d95db1a7a081487dfed12db9a63db4aaeffb7746158de96dba9ebf732cc2860114e1b49188a2207951ae83e42099ffdf4ff887cb5ae01b5d94aca64f97a1528dc18c802870f8a962408cf85c61446bbc2c323bb29008ee0ccf787ab9fdcd65758be6be599215cfcad1fbb19e7558cba3d8399262486925bdfa53512e2515970564014280d336c96d4e85be5a008c288fafcef702973dc1d45bbd659803ca9786b35e1bc3bb240ad93bedc534bbdb60a707c526a34c0302e8fdf2312ee8e332679bc7aa4647570622d4ea37bd04373fa86226446210762e522c280ed0c87232e7e6731832b11235a46b510ffe889f306d45092a9a9a88633aa48020506d428710866389e84e521d3728e979a2ea47d2140b919c1b6de6fd7cb67a2dea4f5c89d0fb7e83d80ce22948f02afb7e6c60570aa9713f6c8d8d8708b48871de48cc48dee6a91b1a9a64df84818deb45df77a8d4fcad7de17708d30b73679fa45b6d05604c57828d3a12a7b78c027fe8687a70875aafcd054bd60d47c3f86c31ebb7e278562030fca0cc62fd6675f30c515042878b465fc52303e38d37449d4002074c66fc4817063ec7044ef7ed60088b378fc5e534cba878b6b45d86b2614eb547c5d5eaa30f0238a16516d4bf8f8d7b7853032f51bab34729beef1db623f76c7de1665a6c22e66a26ae71335942727fba94344cc5510d7f97569986d885ba442e06d5f3eb095c7044ebd9aa6daa5bd9aedce81ae9300e3fc102e6c92b4ae6b120ce0dcb6c1b5cbb81ac250b257009ab8e56d8e5b66d809a51b7c65537a8ee6efb81983850aaf1ac9a1b2dbca1ac80c13f25a130b7a6b2d84eaa1d7a778662b6e6b8e6d431b6d7ee90218a2fff90c092bedab23b4c88bee8fcf6b20aef4a5c28b3567a264c87ea54541035a00f4c03f84d4c0959d4ad2445664b440b4efe43d9b82ac7f39d067755083bec31ef7074ee542cb0ed14a5bea282e7ed663787f19b6b7b7da4162a0cddebb3192d2c4e861bb083a4905e50d070b333230e79269f91c359dc8d3566ec7052b71241ca80635860f12cd785316d3a6425a87ae9fde4de289ebdc2706d33ba7516d4aeef79aa8b185096efdeb733a148b5869c5b2f13080c82737bc4cf2f41c5178f0c3ff18a2f576f39b88820d0d971c721545f16d61f47abae383181d34b9c972d80b0f568e0f6a25f4545c789446c3b9cb08e7d46531411f071b965aa81c99c267327d51b49d115cfba5230be8dbfb24a2f0f878fe5972cbb971bba355f4a135bbd92e47425446b1a0ffc6f0467c5e168100f32ca1c984f8a418ac4e1f4f0dff7cb7b3f766cab19c13f2adc1e33e8479c2edfcc54f93e7cef0887d506b829fa2d53fb1c7096f83954f84bf827151b6743a969230e2d78e4b7ec008a1a3b07e304970694a33db5aba9f31df625284b68b83e9c879da22a51f92ad214ae6a2b122a2f3040d57e5240690a0a2f356383a3487517eaa7c7bc86b8cb61f62e678892f464b788725a5d300a9213bdb44c09424cae22a9bed3bad61988d0855659da6e0b83b1ed07e3ffb7be97e353205ffa6202cf82419c66de45de9da57293de0a452b676eb4b58300d3a928b4b91ee352d6fe9d0add38b0e2d0b98dcb43cdbc4297fd62c583ec75292292ac6bebf87c6d4f1beb4cc83acef8a7ee2403f9a456a352471f6d5c8edb2ccfe259978a6656b93009c0bfb091e40c5f38fc8574ba786a5e569a049290ffe7b564505c75f998068bf6a903a59efd901e48135b1d6efd6daf6a7218900967815c454ac364265634884ead495c47cde81480dd7b23ff5a9f9510c7841293ccb0a912de78f5cccbcc52cf97ab3949be24ee37023867ad6701c3694bd1eba7aebb8fc5a4941382d26afdcc24f319666a88bb0df233954ae63aeecb022f0f71404c623538f38cbff15404add2ec8129857901bcfa9b6b1f51c8f659a6b79c3d7489c27397f44ac2a17137c6ac16e911133d7c868ef686805ecc931c666a4d095d102bfaca1016f9ddc2785edd646cd88bba54cc5f875d4e9866d35e7bc11e22c6b90adc08fd7fb758f68fa2f28e569641d186e652f50ca1a6d16ccffa940b3f3f2c0a3b5a092bd9e25291494b2e0a8aa4a8d9bb689888b252956700f80f9e38ec997e7fa05c456c4ce3d21930b2c54e900aee51ce25d8fff615f17bfe7ae594234899f8c6d5c6843ba29ca0e0097bde0bbd90a2c90a5818aaad9f03fa053bcaa7145302cb4f020f0c199ca5f51bd6922cb9057b68211ff21ca27c291514a854f0e02946b39d68b76a4c0a17f36a006a40872e97db98325c51210d7b60e0be7ce7612b500471a29bd6bb456f255c99c5c81b0fe90e1066687876c1959ac3535489513d31e0dbbd568e89016dfe73ceb149ab768788217ec2d476504dfb54d2f31112b65a9110ab2e6ec0ad5168753e7c5b0f339894cebfde106edb6b4761ddaf9cc24936f37770963b2fe43cbb11bde9f3e098002317c40c44f71760634ef87095842ddf8a28b54f4df3c7b49330723d424314ea16cc14a18bcd39190806a0fa681af3d153132bb7f4c951a13ce1d0ca3f380b2a637567a1c58975abf7081ced331a475bfb79185ec6c5b754a809fbd195e91418f193f2f7cdbb7893f6ef66e37373f876df453d096c994aafca2e9c29ae86628e0181cc7bf8168099040abdf78d70a1c60e204485e62e9f47b7fe439a21255cad53c607e75983c9e7e0c44c5408308b905811e0f538db685e3793bf85c0df6e6855ddbc02b5364fd1a77b3aa3f046f701b999a1dbd055e00d0fab552f75fc0bc8c79cb1308f27756da50fd4d7346df626f81df31be8df6fecbd4cab99cf5b2e853dedf3894f2ff1ce61a21908b757d5511149dce2dc0e98ccf2ed6adc24ab5f75fc6322ca9b6030c82659f1d9995f17cb313bbf4a73287ac41c95d24b1460efa3854acba4121b8dbb3f4d3a0e2720b37c7721b6b8f05e1bb8e22bd76804293eaf60df1d7cab453a672e51230954a2adc1ff32c419945243d7db6871234e0895591bcf4ec8427b390d4ce75661e727e11269d8f40647574ebbd2b331fc8b499d330825ad1de24ef6449cbded2609b7f0d27365ba2fab23e6d0896e8c94930d856275d18cdaa9e17c0bee6f9e1590a75c027a1254222d9509ddb73152fb9a1fc530c5541188f1bc407da1f1824f4c1a648f0401315968604ef0a89b227a6c20ba2bad74db1cb0dae0c4e6f471b36e07eb9ab4304fb482c7a4945dbf31bf1a8ed819450f7e3074db6c222936f231bd397e51afbebeb32562e119be167641c81b40a517c420eb71cadad6c850d60bf4cda9f978c34e8d78e508380fab006a298c61c599fd9370a2ee367648e9aec951a93b0b3824257f43a91c3b967873f0af2df15583bbced3100db854075dabcfd9180f18004fbf10bc7e5859f74bb9470296315639431b2deddda46f9348140bf8e7b5a252ffab0ae0a4b7bc46f4a8f2f259ab6dd79fa21f61ad6c8f850a787f1ca0c7ab5dd392eb1d7c195081c3d757fcae87631de5f557fe876bd1bcbc521101ffd70fb42bbb05bb136f0c58602e7bfbc2311e92ce43f128b5d0bf5b3e853e4878995c995b5c5b15bc7bdea58e2aef5426842abbe9ca9c969a7d1a8548bafb4a94f12609ad454de12f6e76adb3400208f983b36a06225f8f230673d94348143010900f890a2e9907bb249dbe3a54a14afa58cf2919f1bfef487574dd0b10215e774dbd905b6df63a12861880f2d8b93b19370bae67763b2f80935fd8b42bcc9fb66136a2498a4f7220bd2c6aad9b059a7a5402aa06758e6e118d81693bb3f981663a5eefd42c894fa8db476c34ef4bd67b5df8b4e4d4472bc3afec521ba57178bdb97f6ace6b99fb1cd11817b16ab912cf918841ed0b1e7b9e5466b5e8ea138731b3318e60c853c60729b829a63cb03cd46a7b436c107ef4d0b3367f5df86a9f021e4b3992d343489c4afe31d68029adbef5b60e0e793f01e07b4994dd42397bc5d0c01e92cc3abfcf6838a99b610571638983012a06382862c3e2e81e97fb7003f97fdeebff84f3eb295f58ae26a992a0c6ab3d2e117a6c84abcee602a903d61f021d937ddef5f618703d1209551889ca52e3a7302c527886e17162f174228b854fd4d8e8271d3b77e8aa33b714c08ede8d343e8642e8c83307e6fb2f23389b93c12ea75cd3883e5528ad407941063a4224b5b7b7c7531c181eb6bae6141894c226927932134b252e712ca25c8d291ab55aa5be8edb56a3a26b2ee78fb3c29b20430d46dad5e6dd5842d858b220ef335f8b3ea5e8c9581c1fdd8f56fe15af7890a5cab9f78dc4b31dc45b42c987952f36c180266dc2360fe82a4c211782f2359eee88ebe19d1a7591ec447116025fe0be748480c5ee2024718e0f795af8d7c6b020560de3387a193a2f1e6dff626889afd4df852d6e1c6de3281198cbe9a83d4ff7a95896b44446456ceddc4519ecf82be599eef6dc7b794bd6f92ec942884d0528aeff56358f4eee26d07be7de2f5ac2727de8f1b629b88ab0e763196eabe5a7f7f2cb6dafdf04f50a8c5d8a805347540178ab28d22e245c6131cadadb9ca958196d237f07a50f1fbb44bdff8e88ad8733ce841643f5d7b7022758b4a9345c1b7b31565bc74a12a7c085dc00a6cf463fb1b1ac795836e6f2b43920c0fc20c17cd95dbedae9cd203f58424948f0367182084b7549dc0c2200107121b3c02a3ee3e39b067553d1311f1e58352ca10d84dd7d17276d360ed7e9309295feac5d88ca1c485bfbf038a2840a2ada75e1a38f101a1381146d184e4888bfe2863d0bc0eaeed2f600e014278d14962c9ecaa9dc28bc0b6f2921d63a5b7d4d00169966b7e3a6265504b12abe27ff29678a60ee025eb25feea02a687180f577801c753ffa1f07c00cc7497984b9eca861650799787f824dc0fcb2cfe416b28ab392bb8895ce29426d105e0617b32403a3e5ec00c6ad952a70923310d0dac8f3dfc47034f88af267f64f7d53bbc7b9d9d56f0fbbeaddbdf5f7813622d03b6d7f3ceb81a51696c9b7c77b6aa702dd88e6c073d709a2753543a358d1de322a4c8dbcc3db3a5f9ed7dd102670b616f9567068b55b4934717815707e69ee8670662551c12b5d068e09096246a942e4ce9a3a5994bd81fa9549fa3cbf47abd1c4ec5443d56b90b3ac9e750c36e91c6f49d1b97ed542a698b29b4779620eeac24f255e387d69bab1fc87e72be01ec05a54ee71ebf2ed9ccf23dffd2380e13fadb8aaa97244ec94f57309bd9345abfb46a823c41e491ae621204e73b21eac2a2e940b012e5783db6c3260bc7018839abe98025a63392e37a0e6c2a488cf21cfb06f89589a25d39d1791d6a8ca900fd8d5139f3887db2d6850381a29b48e23d4e3568a4930a7e3ea07f87ac112c14dd9ac20a2998fd9832bdf9f6f4b5f7bb85165d32092372f7f34131c7d8f2ce32bba1de5770f9bf0f5f206bb31122ea2634f9b890112a4f6e80b888bbae702b1104ac9d49f882f35b69e5e490fde6e3cfd824529b6c59eeeff0bbaa79afed49ab696176fe3d748999a6c24c9c05d09305cda382ac834a88ca6762892a0f3db9402bf51adc55d52342e5ec9ad5a2f74c4be34800ead2ce896ce5a377ded3e370f305cea97068f87b17a88a5361c4f1a04ba10a3044c82c80dca05e9e41f37abd8b9bdaaf4f32fc16b7775a18a0f95adb424a497f264c9cde746e9861614788e887fcba8691e644348d40f3937f9ab069dda947c278495766f3e194c480e35449c47a5e227f8767487664c9e9328375544a2e744ad440e96b0c5278935552e549041c39af916fc6571db28601e66ee2a37d895757491dc574c4a5ac18b5914fae2bcc7ab6b4166f00a9fbdf95ea337586752414bb4c216d5494eb7c0f7ed032bb2e23d794665bb52e3b0e6e493cd8a89103c6b930363b716e78ff869aba2b11da9b7f303bc439429ee877bdfaa1ed74279e217532e3c4ce93e37ab2a5ecd1398189f6981f57b7471a5c15b14848009ffb645e4c91d8753e52a05aba30b891e53712208b26af0fdf9616e100506683763350309a7ad1830d91aeac9c5a79c9999e30342147145d55a2d9dea28b1983a4183c2c6fa37e903ef90d15787513e1108c291e0d8208dbe865311d54670c2405f217605f478ea561aa0f2ebcbdc2ffbe3d74f57ffa872603ace37f95cfe0232d0678de56e8707891472f725c72d29dd333b3fcd9fd3dbe9fbab96baf4c64bfba719eb6252efe739847d9b59d38cbd621827de7e0b7c052d28dc98eb52d3228813ea513c4bc99263ab7622baa75575364968ed4fe09fa42f419690aa3570fc7a11b34442344a2061d752b214fa2804900a8bedfa1965d58b23a09eb3e142aac4d5fc41053dd5ad5b8c0a3f54dfbe54cb58cee72be43e4f5e643a9070b608bc8f5f5c9320acfcec900306143e7f45f4d236d5333889647a28c659e1dabb8cd22099b7f158708098787a78419e42b3ee284a7abe1872d1e6be5051e13512d067e4b8008eb6cd7597d37b2ecc49593017880ab59f20b927350d12f2c2df725360a6a131b53bad3ba72626cca4d631242abf4e157b4233b9f201665978a8a01b74f5316a65be4cd40c176a24d53344dbdf3877b759493023610b2bd2811d586c529f3b12dd1cc55120c04e64934d8e68f3cc97ad4d439758d0f53f9028282fb2b606bcec2ede128ee8777c6ef602d5734935fb5d07f427687b242d42b848e7fac5ba87fad6de76cbbf1177752734594ef59657623294b0a570eff9132f338e00afd4117c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>ccf</category>
      </categories>
  </entry>
  <entry>
    <title>游园不值</title>
    <url>/2020/08/11/%E6%B8%B8%E5%9B%AD%E4%B8%8D%E5%80%BC/</url>
    <content><![CDATA[<div align = center>
    <h2> 游园不值
    </h2>
    <div>
    [宋]叶绍翁
    </div>
    <div>应怜屐齿印苍苔，小扣柴扉久不开。
    </div>
    <div>
        春色满园关不住，一枝红杏出墙来。
    </div>
</div>

]]></content>
      <categories>
        <category>诗词赋</category>
        <category>叶绍翁</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>叶绍翁</tag>
      </tags>
  </entry>
  <entry>
    <title>道德经（第七十六章）</title>
    <url>/2020/08/10/%E9%81%93%E5%BE%B7%E7%BB%8F%EF%BC%88%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h2 align = center>道德经（第七十六章）</h2>

<p>   人之生也柔弱，其死也坚强。草木之生也柔弱，其死也枯槁。故坚强者死之徒，柔弱者生之图。是以兵强则灭，木强则折。强大处下，柔弱处上。</p>
]]></content>
      <categories>
        <category>道德经</category>
      </categories>
      <tags>
        <tag>道德经</tag>
      </tags>
  </entry>
  <entry>
    <title>江南春</title>
    <url>/2020/08/09/%E6%B1%9F%E5%8D%97%E6%98%A5/</url>
    <content><![CDATA[<div align=center>
    <h2>
        江南春
    </h2>
    <p>
        [唐]    杜牧
    </p>
    <p>
        千里莺啼绿映红，水村山郭酒旗中。
    </p>
    <p>
        南朝四百八十寺，多少楼台烟雨中。
    </p>
</div>



]]></content>
      <categories>
        <category>诗词赋</category>
        <category>杜牧</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>杜牧</tag>
      </tags>
  </entry>
  <entry>
    <title>YunBlog可以评论啦</title>
    <url>/2020/08/08/hexo-Next%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>​        本来我这个博客也没有很多人看到，只是自己写着玩的，所以就没有设置评论的功能。</p>
<p>​        但是今天有个小可爱问我怎么没有评论功能，导致她想评论的时候，没有办法。那不行呀，必须服务好她。所以就在网上找了一些教程。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808212733403.png" alt="image-20200808212733403"></p>
<p>​        首先是查看有哪些评论系统，网址在这里，<a href="https://www.zhihu.com/question/267598518" target="_blank" rel="noopener">Hexo（NexT 主题）评论系统哪个好？</a></p>
<p>​        然后选择了Valine，然后它主页说hexo已经可以支持这个评论系统了，那下面的事情就简单很多了。接下来找了一个教程：<a href="https://yuanmomo.net/2019/06/20/hexo-add-valine/" target="_blank" rel="noopener">Hexo Next 主题添加 Valine 评论系统</a>。感谢博主的帮助。</p>
<h3 id="系统配置："><a href="#系统配置：" class="headerlink" title="系统配置："></a>系统配置：</h3><ol>
<li><p>申请 LeanCloud账户，这个具体干啥的我也没研究，感觉功能挺多。</p>
</li>
<li><p>申请应用，按照下图添加两个类：</p>
</li>
</ol>
<pre><code>![image-20200808213759214](https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808213759214.png)
</code></pre><ol>
<li><p>最后应用Keys中记住两个<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214003660.png" alt="image-20200808214003660"></p>
<p>​    这是要填写在配置文件中的。</p>
</li>
</ol>
<h2 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h2><ol>
<li>编辑 next的_config.yml 文件</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214252561.png" alt="image-20200808214252561"></p>
<p>修改 valine.min.js 的 cdn 文件地址，到这里 <a href="https://www.jsdelivr.com/package/npm/valine" target="_blank" rel="noopener">https://www.jsdelivr.com/package/npm/valine</a> 这个地址选择最新版本的Valine，然后获取cdn地址，修改到 主题配置文件 _config.yml 即可。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214325591.png" alt="image-20200808214325591"></p>
<h2 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h2><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808214539154.png" alt="image-20200808214539154"></p>
<p>搞定啦！🐱‍🏍💞</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>南园十三首（其五）</title>
    <url>/2020/08/08/%E5%8D%97%E5%9B%AD%E5%8D%81%E4%B8%89%E9%A6%96%EF%BC%88%E5%85%B6%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p><h2><div align=center >
    南园十三首（其五）
</div></h2></p>
<div align = center>
    [唐]李贺
</div>
<div align=center >
    <p>    
        男儿何不带吴钩，收取关山五十州。
    </p>
    <p>
        请君暂上凌烟阁，若个书生万户侯?
    </p>
</div>



]]></content>
      <categories>
        <category>诗词赋</category>
        <category>李贺</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>李贺</tag>
      </tags>
  </entry>
  <entry>
    <title>且行且珍惜</title>
    <url>/2020/08/07/%E4%B8%94%E8%A1%8C%E4%B8%94%E7%8F%8D%E6%83%9C/</url>
    <content><![CDATA[<p><h2><div align=center>且行且珍惜</div></p>
<div align=center>[明]无名氏</div>

<div align=center >
    看山思水流，触景进乡愁，问君意随流，绵愁几时休。
</div>
<div align=center >
    念己勿念欲，行己知行义，相离莫相忘，且行且珍惜。
</div>

]]></content>
      <categories>
        <category>诗词赋</category>
        <category>无名氏</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>无名氏</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL无法使用</title>
    <url>/2020/08/07/WSL%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="WSL无法正常启动，报错"><a href="#WSL无法正常启动，报错" class="headerlink" title="WSL无法正常启动，报错"></a>WSL无法正常启动，报错</h2><p>win10更新之后，打开wsl报错，报错内容是：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808151143995.png" alt="image-20200808151143995"></p>
<p>然后在网上找办法，最后在vscode的github上的issue找到了解决办法：</p>
<p><a href="https://github.com/microsoft/WSL/issues/5633" target="_blank" rel="noopener">GitHub/vscode</a></p>
<p>这是一个解决办法，可以在cmd和powershell中使用：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808151412228.png" alt="image-20200808151412228"></p>
<p>下面的可以在windows Terminal和vscode中使用：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200808151509638.png" alt="image-20200808151509638"></p>
]]></content>
      <categories>
        <category>WSL</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>杂曲歌辞•杨柳枝</title>
    <url>/2020/08/06/%E6%9D%82%E6%9B%B2%E6%AD%8C%E8%BE%9E%E2%80%A2%E6%9D%A8%E6%9F%B3%E6%9E%9D/</url>
    <content><![CDATA[<p><h2><div align=center>杂曲歌辞•杨柳枝</div></p>
<div align=center>[唐]白居易</div>

<p><div align=center>一树春风千万枝， 嫩于金色软于丝。</p>
<p><div align=center>永丰西角荒园里， 尽日无人属阿谁。</p>
]]></content>
      <categories>
        <category>诗词赋 - 白居易</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>白居易</tag>
      </tags>
  </entry>
  <entry>
    <title>win+ununtu双系统</title>
    <url>/2020/08/04/win-ununtu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="win-ununtu双系统"><a href="#win-ununtu双系统" class="headerlink" title="win+ununtu双系统"></a>win+ununtu双系统</h2><p>​    现在学习需要使用Ubuntu16的系统，但是系统要求比较高，不能在虚拟机上安装，需要安装原生的系统，但是我的win10确实是很好了，舍不得放弃它，没办法只能装个双系统了。</p>
<p>​    教程都是在百度上找的，下面这个很全面，很实用，我已经按照这个完成了。下面放出链接：<a href="https://blog.csdn.net/fanxueya1322/article/details/90205143" target="_blank" rel="noopener">win+Ubuntu</a>。</p>
<p>​    安装过程还是比较顺利的，就是安装的时间花费比较久。</p>
<p>​    下一步就是美化Ubuntu了。</p>
<p>​    我承认自己不折腾会死。💖🐱‍🏍</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Omnet++</title>
    <url>/2020/08/03/Omnet++/</url>
    <content><![CDATA[<h2 id="Omnet"><a href="#Omnet" class="headerlink" title="Omnet++"></a>Omnet++</h2><p>主要由六个部分组成：</p>
<ol>
<li>仿真内核库（simulation kernel library,简称Sim）</li>
<li>网络描述语言的编译器（network description compiler, nedc）</li>
<li>图形化的网络编辑器（graphical network description editor,GNED）</li>
<li>仿真程序的图形化用户接口－Tkenv</li>
<li>仿真程序的命令行用户接口－Cmdenv</li>
<li>图形化的输出工具－Plove和Scalar<br>整个结构如下：<br><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/p1.png" alt="p1"></li>
</ol>
]]></content>
      <categories>
        <category>Omnet++</category>
      </categories>
      <tags>
        <tag>Omnet++</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Congestion Avoidance through Packet-chaining Reservation</title>
    <url>/2020/08/03/Network-Congestion-Avoidance-through-Packet-chaining-Reservation/</url>
    <content><![CDATA[<h2 id="Network-Congestion-Avoidance-through-Packet-chaining-Reservation"><a href="#Network-Congestion-Avoidance-through-Packet-chaining-Reservation" class="headerlink" title="Network Congestion Avoidance through Packet-chaining Reservation"></a>Network Congestion Avoidance through Packet-chaining Reservation</h2><p>基于数据包链预约的主动拥塞控制协议</p>
<p>​        预约的本质就是在整个网络中做仲裁，而仲裁时间和仲裁粒度必须要匹配。基于此，本文提出了数据包链预约协议（Packet-chaining Reservation Protocol，PCRP），选取合适的预约粒度以和预约的时间相匹配，提升预约的准确性和灵活性；还通过在全网提升短流的优先级的方法，有效的保障了短流的利益，降低流完成时间。</p>
<h3 id="数据包链预约协议"><a href="#数据包链预约协议" class="headerlink" title="数据包链预约协议"></a>数据包链预约协议</h3><p>​        对应于在 SRP 中分配预约时间片的方法，PCRP 采用以数据包链（packet chaing）为单位进行预约的方法。术语“packet-chaing”是几年前首次提出的，它通过将发往同一目的地的数据包链接在一起来操作，以复用数据包在通过交换机时的交换机连接，减少交换机仲裁次数。本文借鉴了数据包链的概念来描述流中几个连续数据包的集合。为了优化流完成时间，PCRP 在发送端采用基于SRPT 的调度策略，并使用多优先级队列来支持接收端的基于优先级的调度。此外，PCRP 使用动态优先级表来执行多次授权。将详细描述 PCRP。</p>
<h4 id="1-1设计空间"><a href="#1-1设计空间" class="headerlink" title="1.1设计空间"></a>1.1设计空间</h4><p>​        由预约协议表示的主动拥塞控制机制基本上通过调整发送端的行为来避免网络拥塞。发送端可以控制要发送的数据量：不发送，发送一个数据包或发送整个流。SRP，SMSRP 和 BFRP 都是极端的。它们实际上是以整个流为粒度进行预约的，第二章解释了这种情况的缺点。在另一个极端，预约是以数据包为粒度的，这就要求接收端在每次发送端想要发送数据包时发送信用数据包。但是，我们没有时间去安排和调度每个数据包。因此，短流将因等待接收端的调度决定而受到影响，并且大量的信用数据包将使网络负担加重。</p>
<p>​        PCRP 设计空间的一个挑战是如何选择链接数据包的大小来平衡准确性和预约开销之间的矛盾。一方面，在预约期调度每个数据包在时间上是昂贵的。另一方面，使用流的粒度进行调度将显着地降低预留准确性。为了匹配作为单个往返时间（RTT）的网络仲裁周期，我们将 RTT 的数据量作为数据包链的大小。这是一个很好的折衷方案。</p>
<p>​        PCRP 的另一个挑战是如何最大限度地避免短流受到协议本身的干扰。因为长流比短流长得多并且可以严重阻塞短流，所以我们必须在长流前安排短流传输以减少短流的完成时间。PCRP 为短流分配更高的优先级，以确保在发送端，网络和接收端中更早地调度这些流。此外，PCRP 允许多个请求和多个授权以实现过度匹配。我们缓冲到达的数据包链并优先考虑短流的数据包链接。结合过度匹配和优先级策略，PCRP 可以显着减少流完成时间。</p>
<h4 id="1-2-执行过程"><a href="#1-2-执行过程" class="headerlink" title="1.2 执行过程"></a>1.2 执行过程</h4><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806091617781.png" alt="image-20200806091617781"></p>
<p>​        PCRP 将每个流划分为多个数据包链，每个数据包链包含固定数量的数据包（流的尾数据包链包含的数据包数可能少于此值）。如图（a）所示，数据包链的大小设置为可以在 RTT 中传输的数据量。Flow 1 分为三个数据包链，其中尾数据包链仅包含两个数据包。由于 flow 2 的长度小于数据包链，因此整个流是一个数据包链。</p>
<p>​        由于 PCRP 不需要预先进行发送预约请求，因此发送端可以以投机的方式直接将每个流的第一个数据包链发送到网络中。投机包具有比正常包更高的优先级，并且不会在网络中被丢弃。虽然第一个数据包链可以以投机方式直接发送，但剩余的数据包链必须在发送之前等待接收端的授权（grant）才能激活。图（b）显示了 PCRP 过程。发送源 <em>S</em> 直接将 flow 1 的第一个数据包链的数据包逐个注入网络，并向接收端请求发送下一个数据包链。在从 <em>S</em> 接收到数据包之后，接收端D 计算剩余的 flow 1 的长度，并确定是否有必要向 <em>S</em> 发送授权数据包。如果需要，则向 <em>S</em> 发送授权数据包。同时，授权数据包携带优先级信息，用于引导 flow1 的下一个数据包链（即非投机数据包链，正常数据包链）中在进入网络时的的优先级。在 <em>S</em> 从 <em>D</em> 接收到授权数据包并激活下一个数据包链之后，数据包链中的数据包可以参与发送方的调度仲裁，直到整个流被发送完成。由于合理的数据包链大小设置，flow 1 的传输过程是连续的。</p>
<p>​        PCRP 允许接收端同时授权多个不同的流，其中高优先级的短流优先于低优先级的长流。一个例子如图3.3（c）所示。当 <em>D</em> 从 <em>S</em>1 接受 flow 1 时，由 <em>S</em>2 发送的较短流 flow 2 到达 <em>D</em>。此时，<em>D</em> 将基于其优先级优先处理 flow 2 的数据包，并将到达的 flow 1 的数据包临时存储到 NIC。在完全接收 flow 2 之后，再从 NIC 的缓冲区中提取来自 flow 1 的数据包进行处理。发送源 <em>S</em>1 等待 <em>D</em> 发送的第二个授权数据包到达并重新开始 flow 1 的发送。由于数据包链的大小恰好是可以在 RTT中传输的数据量，所以当 flow 1 的最后一个数据包链到达时，存储在 <em>D</em> 的 NIC缓冲器上的数据包刚好被 <em>D</em> 处理完毕，因此在重新启动之后 flow 1 的传输仍然是连续的。</p>
<h4 id="1-3发送端行为"><a href="#1-3发送端行为" class="headerlink" title="1.3发送端行为"></a>1.3发送端行为</h4><p>​        当应用程序生成流时，PCRP 发送端首先将其划分为多个数据包链。数据包链具有以下状态：</p>
<p>​        <strong>投机</strong>：每个流的第一个数据包链可以在没有授权的情况下以投机模式直接发送，并承担向接收端发出类似预约请求的任务。</p>
<p>​        <strong>非活动</strong>：除流的第一个数据包链外，任何后续数据包链默认情况下都处于非活动状态。需要激活它们才可以进行发送，这些数据包链必须等待来自接收端的授权。</p>
<p>​        <strong>活动</strong>：收到授权后，发送端激活相应的数据包链。激活的数据包链可以参与调度仲裁，直到它被发送。</p>
<p>​        相应地，每个流也有两种状态：就绪和等待。当流具有投机或活动数据包链时，流处于就绪状态; 如果流的数据包链都是非活动状态，则流处于等待状态。</p>
<p>​        PCRP 在发送端利用 SRPT（最短剩余处理时间）仲裁策略。SRPT 调度策略的基本机制是根据流的大小确定流的优先级，从而可以优先传输剩余最小的流。这种策略的优点是即将完成传输的流不会被另一个较小的短流中断。但是，使用SRPT，更多的投机数据包链将无节制注入网络，然后汇聚到接收端。为了减轻对接收端和网络的压力并更好地保证预约的效率，我们将变量 EU-Flow（最早未完成流）添加到调度器中。每次发送数据包时，发送端调度器将进行仲裁。调度器首先检查 EU-Flow 变量记录的流是否就绪。如果是，则调度器选择其为将要传输的流; 如果没有，它将使用 SRPT 策略选择另外一个已就绪的流进行传输。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806092714656.png" alt="image-20200806092714656"></p>
<p>​        图显示了 PCRP 发送端的调度策略。图的左侧是每个流的剩余长度。Flow 3 处于等待状态，不能参与仲裁。调度器首先检查 EU-flow 是否准备就绪。Flow 4 准备就绪，因此调度器选择它。其他已就绪的流，如 flow 2，其剩余大尽管小于 flow 4 的剩余大小，必须暂时等待。EU-Flow 机制确保了首先开始发送的流优先从发送端发送。这不仅避免了发送端向网络中注入大量投机数据包所造成的拥塞，而且避免了短流被超短流拦截而引起的不必要的性能下降。</p>
<p>​        在 HPC 的通信负载中，长流的长度经常是短流的几百倍。如果调度器总是执行上述方法，那么长流将被饿死。为了避免长流被饿死，PCRP 会考虑流在调度器中的等待时间。如果长流的等待时间超过流最大等待时间（Maximum Flow Wait Time，MFWT），则长流的优先级将增加，以便调度其可以及时将其发送。请注意，我们不会将长流的优先级提高到最高级别，以避免阻塞其他短流的发送。在我们的实现中，MFWT 根据 HPC 网络负载特性设置为固定值。</p>
<h4 id="1-4-接受端行为"><a href="#1-4-接受端行为" class="headerlink" title="1.4 接受端行为"></a>1.4 接受端行为</h4><p>​    PCRP 接收端根据其优先级调度数据包链。我们在 NIC 上添加了一些轻量级缓冲区，以临时存储到达接收端的数据包，这些缓冲区以多个优先级队列的形式组织，如图3.5所示。接收端 NIC 首先根据优先级从队列中提取数据包，从最高到最低。但是，NIC 的接口速率是固定的，即每个周期只能接收一个 flit，并且必须串行处理 flit。到达的数据包不会自动驻留在缓冲区中，这样优先级队列就不能发挥作用。为此，我们在 NIC 上添加了一个等待窗口。在此窗口中，NIC 仅接收数据包但不处理它，因此这些数据包将驻留在缓冲区中。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806093144375.png" alt="image-20200806093144375"></p>
<p>​        PCRP 在接收端侧维护动态优先级表。当 NIC 从队列中提取新流数据包进行处理时，它会将流的信息添加到动态优先级表，并根据流的大小对表重新进行排序。然后，NIC 对动态优先级表进行索引，并通过比对流的大小和剩余的大小来确定提取的流是否需要授权。此外，NIC 从动态优先级表中获取该流的优先级，并通过授权报文向发送端通知优先级信息。当发送端收到授权时，它会激活相应的数据包链并用授权数据包携带的优先级标记它。当数据包链到达接收端时，它根据其优先级进入相应的队列。</p>
<p>​        但是，接收方无法在没有限制的情况下授予所有到达的流量。PCRP 设置了在接收端可以授权的流的数量的上限。也就是说，当表已满时，NIC 将不会在新的流到达时更新动态优先级表，并且除非表中的旧流已被处理掉，否则无法发送授权数据包。设置授权的上限阈值是一种预约的方式。PCRP 接收端可以同时响应多个流的预约请求，并将不能立即处理的数据包链临时存储到缓冲区中。</p>
<h4 id="3-5-数据包链优先级"><a href="#3-5-数据包链优先级" class="headerlink" title="3.5 数据包链优先级"></a>3.5 数据包链优先级</h4><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200806093612568.png" alt="image-20200806093612568"></p>
<p>​        PCRP 发送端发送的每个数据包链都带有优先级。投机数据包链的优先级由集中统计单元根据流的大小分布决定，正常数据包链的优先级由接收端的授权决定。</p>
<p>​        每个数据包链中的所有数据包都具有相同的优先级。投机数据包链具有比正常数据包链更高的优先级。如果网络支持 8 个优先级，并且 <em>P</em>0 <em>&gt; P</em>1 <em>&gt;</em>…<em>&gt; P</em>7，一种可能的解决方案是将 <em>P</em>0 到<em>P</em>3 分配给投机数据包链，将 <em>P</em>4 到<em>P</em>7 分配给正常数据包链。</p>
<p>​        <strong>投机数据包链优先级</strong>。投机数据包链的优先级由集中统计单元获得，集中统计单元计算网络中流的长度分布，然后通知发送方。如图3.6所示，集中统计单元收集接收端接收到的流的大小信息，然后计算网络中流的累积分布函数（CDF）。集中统计单元将 CDF 分成四个相等的部分（基于投机数据包链被分配四个优先级的假设），然后获得对应于每个优先级的大小范围。发送端收到该信息后，根据每个流的大小设置其第一个数据包链的优先级（投机数据包链接）。由于 HPC 网络中的实时流量不会频繁更改，因此无需实时更新优先级信息。因此，为了减少浪费网络带宽，以较低的固定频率动态更新投机数据包链的优先级信息。</p>
<p>​        <strong>正常数据包链优先级。</strong>正常数据包链的优先级信息由接收端实时动态调整。接收端维护一个动态优先级表，并根据流的大小对其进行排序。流的长度越小，优先级越高。如果表中的流的数量超过了可以分配给正常数据包链的优先级的数量，则所有后续所有的流都被赋予最低优先级。如图3.5所示，分配给第一个到第五个流的优先级分别是 <em>P</em>4，<em>P</em>5，<em>P</em>6，<em>P</em>7 和 <em>P</em>7，并且所有排序在更后面的流将被分配给最低优先级。</p>
<p>​        动态优先级表有助于接收端更准确地处理正常的数据包链优先级。另外，接收端不需要考虑整个网络的流的大小分布情况，而优先级可以由动态优先级表直接分配。这确保了在优先处理短流的同时网络性能受到的影响较小。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>PCRP</tag>
      </tags>
  </entry>
  <entry>
    <title>CRSP: Network Congestion Control Through Credit Reservation</title>
    <url>/2020/08/03/CRSP-Network-Congestion-Control-Through-Credit-Reservation/</url>
    <content><![CDATA[<h2 id="Network-Congestion-Control-Through-Credit-Reservation"><a href="#Network-Congestion-Control-Through-Credit-Reservation" class="headerlink" title="Network Congestion Control Through Credit Reservation"></a>Network Congestion Control Through Credit Reservation</h2><p>​        ECN对参数敏感，网络拥塞的响应时间较慢，而SRP的预留操作不准确。为了实现更有效的拥塞管理，提出了CRSP，一种主动的信用保留调度协议，它可以有效避免端点的拥塞并减少流完成时间。与SRP相似，CRSP还需要在发件人和目的地之间进行预留许可的握手操作，以避免形成网络拥塞。但是我们以控制报文少的轻量级版本实现了CRSP，并且CRSP的开销小于SRP。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200804095356406.png" alt="image-20200804095356406"></p>
<p>​        CRSP的操作如图5所示。发送方中的活动流通过首先发送保留数据包Res（1）来启动与目的地的通信。预留包是小且具有最高优先级。它在单独的控制虚拟通道（VC）上传输以确保快速传输。每个预留分组携带预留大小n，这意味着预留流的迁移数量。目的地将根据预留大小和Res来为流量分配信用。发送预留数据包后，该流将等待目的地分配的信用的答复，并且不会发送此流的任何信息。</p>
<p>​        在目的地中，添加了一个保留缓冲区（Res  buf）以缓冲预约数据包。目的地接收到预约包后，它将被放入预约缓冲区的尾部。另外，在目标中添加了一个名为“信用池”的计数器。目的地中的信用编号存储在贷方池中，它指示目的地的吞吐能力。信用号由目的地的接受率决定。在每个周期中，目的地将首先在预留缓冲区的前面获取一个预留数据包，然后将预留大小（即Res中的n）与尚未分配的剩余信用数进行比较（2）。如果剩余信用数大于预留数据包所需的数量，目的地将源节点所有所需的信用分配给源节点，目标节点将通过生成授权数据包以通知源，预留流被允许发出数据包。到目的地（3）。同时，目的地将更新信用缓冲区并从预留缓冲区中弹出相应的预留包（4）。可以从预留数据包的源获取授权数据包的目的地。但是，如果剩余积分的数量不足以分配给预留包，则预留缓冲区前面的预留包将必须等待下一个周期，而不是被丢弃。也就是说，如果剩余的信用额度小于预留数据包所需的信用额度，则信用额度缓冲器将不会被更新（5）。</p>
<p>​        当源节点接收到一个流的授权包时，它将立即发布该流的数据包（6）。  CRSP根据流调度数据包，以确保将流完成时间最小化，这意味着只有当流已被传输时，才能选择具有最小q的其他流来发布。当目的地接收到数据包时，已分配到相应流的信用额将被收回。恢复的信用将添加到信用缓冲池中，然后分配给其他流。所有传输将重复此过程。但是，值得注意的是，当目的地将信用分配给多个流时。这些流可能会在某个时间到达目的地，这也可能导致端点拥塞的形成。为了避免这种情况，我们设置阈值p以限制信用缓冲池的大小。阈值p表示允许源节点保留的信用池中的流数。如果将阈值设置得太大，则表示信用池允许大量流在一段时间内进行保留，并且这些保留的流可能同时到达目标节点，从而导致目标节点发生拥塞。如果阈值设置太小，则网络带宽无法充分利用，将降低吞吐量。在此实验中，我们将阈值p设置为两个最大流量的大小。</p>
<p>​        CRSP旨在最小化流延迟并获得更高的网络带宽。  CRSP避免在发送方将数据包发布到网络之前形成端点拥塞。与其他基于时分协议的主动式拥塞管理机制（例如SRP）相比，CRSP更加准确有效。为了最小化控制数据包的开销，所有保留数据包，授权数据包都被最小化，并在单独的高优先级VC上传输以保证快速传递。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>CRSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Channel Reservation Protocol for Over-Subscribed Channels and Destinations</title>
    <url>/2020/08/03/Channel-Reservation-Protocol-for-Over-Subscribed-Channels-and-Destinations/</url>
    <content><![CDATA[<h2 id="Channel-Reservation-Protocol-for-Over-Subscribed-Channels-and-Destinationsv"><a href="#Channel-Reservation-Protocol-for-Over-Subscribed-Channels-and-Destinationsv" class="headerlink" title="Channel Reservation Protocol for Over-Subscribed Channels and Destinationsv"></a>Channel Reservation Protocol for Over-Subscribed Channels and Destinationsv</h2><h3 id="1-信道保留协议CHANNEL-RESERV-ATION-PROTOCOL"><a href="#1-信道保留协议CHANNEL-RESERV-ATION-PROTOCOL" class="headerlink" title="1. 信道保留协议CHANNEL RESERV ATION PROTOCOL"></a>1. 信道保留协议CHANNEL RESERV ATION PROTOCOL</h3><p>​        使用CRP，每个超额预订的信道和目的地都会保留一个预留表。该表中的每个单元代表一个未来的时隙，并以时钟周期（连续）粒度记录可用带宽。源发送记录参与资源可用性的请求。然后，目的地将计算满足请求大小的最早的公共可用性，并以授予进行响应。然后，Grant然后在转移回源时最终确定参与资源中的保留。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803174200355.png" alt="image-20200803174200355"></p>
<h4 id="1-1-Reservation-Tables"><a href="#1-1-Reservation-Tables" class="headerlink" title="1.1 Reservation Tables"></a>1.1 Reservation Tables</h4><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803175034293.png" alt="image-20200803175034293"></p>
<p>​        将预留表与每个资源相关联。表的每个单元格对应一个时隙，该单元格中的值表示相应时隙中可用带宽的cycles数。上图显示了32个表单元（$V<em>{cells}$）的示例配置，每个表单元占用512个周期（$C</em>{max}$）。在此示例中，将来最多可以保留16384个周期的资源。在图中，单元格A对应于包含周期0-511的时隙，单元格B代表周期512-1023的时隙，依此类推。如图所示，时隙（单元）A具有512个可用周期，而时隙B仅具有10个可用周期。<br>​        如果$t[i]&gt;0,t[i]+t[i+1]\geq x$，则资源可以在时隙i内容纳大小为x的请求。也就是说，对应的表格单元必须至少有一个空闲时钟周期，并且该表格单元与下一个单元的总和必须至少为请求大小。这允许请求跨越两个相邻的单元格，从而减少碎片的不利影响。<br>​        当时间提前$C<em>{max}$个cycles时，保留表在逻辑上会移动一个单元格。在上面的示例中，当系统时间变为512时，删除单元格A，并将表向左移动一个。在右侧插入了一个值为$C</em>{max}$的新单元格。为了保持同步，必须使用某种技术<em>（A fine-grain clock synchronization mechanism for myrinet clusters. ）</em>将所有资源同步到全球时基，且精度至少为±$C_{max}$个cycles。<br>​        为每个关键资源维护保留表。每个目标的网络接口卡（NIC）均包含该目标的出口通道的表格。每个路由器为驱动潜在瓶颈通道（例如群集间通道）的每个输出端口维护一个表。  </p>
<h4 id="1-2-Reservation-Handling-in-Channels"><a href="#1-2-Reservation-Handling-in-Channels" class="headerlink" title="1.2 Reservation Handling in Channels"></a>1.2 Reservation Handling in Channels</h4><p>​        预留请求携带一个长度为$V_{cell}$的位向量，其中每个位都表示一个时隙的可用性。请求向量初始化为全true。每次请求向量传递资源时，该资源都会重置向量中与资源没有请求带宽的时隙相对应的任何位。实际上，每个资源在通过时将其可用性与请求向量进行“AND”运算。当请求向量到达目的地时，它表明：在请求通过资源时所有必需的关键资源都具有足够带宽来处理请求的时隙。 <img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20200803184015703.png" alt="image-20200803184015703"> </p>
<p>​        预留向量与预留表同时向左移动一位。当预留向量发生移位时，将在右边插入一个T比特，因为最初在新的时隙内资源可用。保留向量移位由路由器执行。</p>
<p>​        考虑下图。在此示例中，单元格A和C保持为T，因为该表可以容纳这些时隙中的80个周期的请求。单元D将其位设置为false，因为它没有剩余带宽，而单元E将其位设置为false，因为单元E和F的总和不足以进行请求。最后，单元格B保持为真，因为单元格B和C的总和可以容纳80个循环。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803184159859.png" alt="image-20200803184159859"></p>
<h4 id="1-3-Rservation-Handling-in-Destinations"><a href="#1-3-Rservation-Handling-in-Destinations" class="headerlink" title="1.3 Rservation Handling in Destinations"></a>1.3 Rservation Handling in Destinations</h4><p>​        目的地将到达的请求的预留向量与其自己的表进行比较，并计算出请求路径上所有参与资源（包括目的地）可以容纳的最早时隙。与信道中的向量处理类似，如果时隙具有可用周期并且其和下一个小区的可用带宽之和满足传入请求，则认为该时隙在目标位置可用。  </p>
<p>​        在对它们的可用性进行“与”运算后放入请求向量中，目的地生成一个授权响应，该响应带有一个时间戳，该时间戳对应于最终向量的最左边的T位。这是所有必需资源都可用的最早时间。</p>
<p>​        此操作如下图所示。在此示例中，目的地的单元格A无法容纳请求，因为目的地的保留表中的单元格A和B的总和小于所请求的80个周期。但是，单元格B可以容纳该请求，因为合并的单元格B和C具有140个自由周期。单元C也能够容纳该请求。我们选择单元格B作为最早可以处理请求并减少单元格B和C的表条目的表格，以保留80个周期（每个单元格40个）。实际的预留周期跨越了两个时隙，包】括时隙B的最后40个周期和时隙C的前40个周期。时间戳记为984，对应于时隙B的最后40个周期的第一个周期</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803184701842.png" alt="image-20200803184701842"></p>
<h4 id="1-4-Grant-and-Retry-Operation"><a href="#1-4-Grant-and-Retry-Operation" class="headerlink" title="1.4 Grant and Retry Operation"></a>1.4 Grant and Retry Operation</h4><p>​        当授权数据包返回源时，它们会沿其路由递减每个保留表的相应单元，以将分配的带宽标记为其他流不可用（图2中的C点）。如果那时与时间戳相对应的单元没有足够的周期来满足请求，则从下一个单元中减去任何剩余的时隙。在图5的示例中，目标为80个保留周期的周期生成了周期984的授予时间戳记。当该授权到达具有图4中所示的预留表的信道时，单元B对应于周期984，因此将减少10，并将其设置为0，而将单元C减少剩余的70个周期，从而将其设置为30。</p>
<p>​        如果两个表单元格不再具有足够的周期来满足请求，则授权将转换为重试响应。如果带宽是在保留请求到达其目的地，生成授权并返回到参与信道（从图2中的A点到C点）所花费的时间内由另一个流保留的，则可能会发生这种情况。如果预订请求的最终向量没有T位或不存在公共可用性，则目的地也会发出重试。重试指示在短暂的延迟($R<em>{cycles}$)后源重新传输。唯一的例外是当发出重试的原因是目的地的预订表在任何时间段内都无法使用指定的预订大小，而与预订请求的向量无关。在这种情况下，重试将指示源在$V</em>{cells}×C_{maxcycles}$之后减去往返延迟后重新发送其请求</p>
<p>​        当授权在信道上转换为重试时，目的地中预留和信道中回复已经遍历过的预留不会取消。我们的实验证实了推测性数据包（在下面说明）和控制数据包有效地利用了带宽。大量超额预订的资源更靠近流量源会增加带宽不必要地在下游资源中以这种方式分配的可能性。</p>
<p>​        为了防止由于多个流试图保留相同的时隙而导致重试，保留请求可以选择在它们遍历参与信道时急切地保留最早的时隙（图2中的A点）。如果有目的地，目的地将优先授予该预定的时隙。预留赠款会释放对赠款流程的所有不必要的急切保留。由于急切的预约与流标识符相关联，因此这需要标签匹配。为单个请求急于保留一个以上的时隙（$R_{res}$），会增加目的地授予预保留时隙的可能性，即使存在合格请求，也会增加空闲带宽的可能性。授予和重试被强制使用请求路径的相反方向返回，以便它们可以操纵正确的通道保留表。通过使请求数据包记录其路径或在确定性路由的情况下通过简单的计算来标识反向路径。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>CRP</tag>
      </tags>
  </entry>
  <entry>
    <title>BFRP: Endpoint Congestion Avoidance Through Bilateral Flow Reservation</title>
    <url>/2020/08/03/BFRP-Endpoint-Congestion-Avoidance-Through-Bilateral-Flow-Reservation/</url>
    <content><![CDATA[<h2 id="Bilateral-Flow-Reservation-Protocol，BFRP"><a href="#Bilateral-Flow-Reservation-Protocol，BFRP" class="headerlink" title="Bilateral Flow Reservation Protocol，BFRP"></a>Bilateral Flow Reservation Protocol，BFRP</h2><p>​        与基于数据包的调度机制不同，BFRP通过调度流来避免拥塞。我们的设计基于SRP的调度策略。流完成时间与大流和小流的发送顺序有关。首先安排小流量可以减少平均流量完成时间。但是，当调度程序每次选择最小流量时，大流量可能会饿死。为了避免这种情况，我们为每个流设置优先级p，并且p等于流大小。每次调度程序对流进行舍入时，p的值都会减少d。当大流量四舍五入时，p的值将变得非常小，调度程序每次都会选择具有最小p的流量，以避免出现饥饿的情况。    </p>
<p>​        图3显示了BFRP的过渡过程。在一个节点中，整个过程分为三种状态：SPECa，SPECb和NORMAL。如果网络没有拥塞，则BFRP将不会进入NORMAL状态。  SPECa状态是BFRP中发送方的初始状态。首先，发送方将选择具有最小p的流，并将推测性数据包发送到网络中。当发送方收到否定确认数据包（NACK）时，它将发送y预留数据包到目标，然后进入SPECb状态。但是，在SPECb状态下，如果发送方在预留数据包发送开始到授权时间到达之间的时间内未执行任何操作，则会急剧增加准备发送的其他流的排队延迟，从而导致平均流量延迟增加。因此，建议在达到授权时间之前，先发送其他流的推测包。详细地说，在发送方发送预留数据包之后，数据包调度程序会在其他发送队列中选择具有最小p的就绪流，然后提前发送这个流推测性数据包。当发送方收到确认数据包（ACK）时，它将继续发送推测数据包。当接收到NACK时，为了确保源的多个预约流没有冲突授予时间，发送方将不对此流进行预留，以确保只有一个流预约给目标。但是，调度程序将选择另一个具有最小p的流进行传输。在授予时间到来之前，BFRP进入正常状态，并且数据包调度程序选择保留的流，发送方以正常模式发送该流的数据包。传输完成后，调度程序将根据此规则选择其他准备传输的流。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200803203856734.png" alt="image-20200803203856734"></p>
<p>​        下图显示了BFRP的操作。首先，我们假设网络没有拥塞。数据包调度程序从发送方队列（1）中选择具有最小p的流。之后，发送方将推测性数据包发送到目的地（2）。推测数据包在低优先级VC上传输。每个推测性分组都与生存时间survival time（ST）和排队时间相关联，如果网络中的推测性分组的排队时间大于ST，则该推测性分组将被丢弃。在我们的实现中，ST是基于高负载均匀流量下网络的数据包延迟分布的固定值，当推测性数据包进入路由器的输入端口时，数据包的排队时间开始。当排队时间到达输出端口中VC的开头时，将检查排队时间。接收到推测性数据包后，目的地需要用ACK进行回复，以通知发送方这些数据包已被接受。当网络没有拥塞时，通常会接受推测性数据包，并且目标返回ACK（3）。这样，分组将以推测性分组的形式传输，并且不会带来任何其他开销。</p>
<p>  <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200804090633984.png" alt="image-20200804090633984"></p>
<p>​        在拥塞的网络中，初始操作与上述相同。但是，当面临端点拥塞时，由于到达ST的排队时间，推测性数据包将被丢弃。届时，NACK将在路由器中生成并发送回发送方（5）。发送方中的NACK管理器收到NACK数据包后，发送方将从SPECa状态转换为SPECb状态，然后发送预约数据包与目标进行握手（6）。预留数据包很小，优先级最高。它在单独的VC上传输，以确保高优先级传递。预留数据包包含一个值n，它是将要发送的数据包的数量。</p>
<p>​        一旦接收到预留包，接收器中的时间管理器将根据预留包中的n为发送方分配授权时间（$t_s$），并在回复包中返回相应的授权时间（7）。之后，时间管理器状态将正确更新。如果有另一个发送方发送的其他保留数据包到达此接收方，则时间管理器将返回给该保留数据包不早于$t_s  + n(1+ε)T_p$的开始时间，其中常数$T_p$是接收方接收所需的时间信道来接收消息，并且ε取决于控制分组的带宽开销。发送方的授权管理器将在收到授权数据包后开始计时，然后数据包调度程序将选择准备发送到其他发送队列中的，具有最小p的流（8）。然后，选定的流以推测性数据包的形式发送数据包（9）。如果目的地没有拥塞，将返回ACK数据包（10）。发送方继续发送推测性分组（11）。但是，如果端点在某个时刻过载，则推测包将被丢弃，路由器将生成NACK包并将其返回给发送方（12）。在接收到NACK之后，发送方将不会调度该流以发送保留数据包，而是选择具有最小p的另一个流并继续发送推测性数据包（13）。当预留流达到授予时间时，BFRP从SPECb状态进入正常状态，并且调度程序调度发送队列以发送普通数据包(14)(15)。在所有剩余的数据包都已发送后，BFRP从正常状态进入SPECa状态。所有传输将重复此过程。应当强调的是，为了最小化由控制操作引起的开销，所有预留分组，ACK，NACK和授权分组都是小的并且在单独的高优先级信道上发送。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>BFRP</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Endpoint Congestion Control for Fine-Grained Communication</title>
    <url>/2020/07/29/Network-Endpoint-Congestion-Control-for-Fine-Grained-Communication/</url>
    <content><![CDATA[<p>需要快速的响应时间和较低的开销</p>
<h4 id="Small-Message-Speculative-Reservation-Protocol"><a href="#Small-Message-Speculative-Reservation-Protocol" class="headerlink" title="Small-Message Speculative Reservation Protocol"></a>Small-Message Speculative Reservation Protocol</h4><p>SMSRP基于以下观察结果：如果端点没有拥塞，则无需为每个消息进行预留握手。与SRP协议会在每次消息传输之前急于启动保留的协议不同，SMSRP仅在通过推测性消息的丢弃在端点检测到拥塞之后才发布保留。    </p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200730071219006.png" alt="image-20200730071219006"></p>
<p>图详细显示了SMSRP的操作。在此示例中，网络源正在将两个小消息M1和M2发送到可能拥塞的端点。每个消息足够小以适合单个网络数据包。消息准备好后，源将以推测模式立即将其发送。与SRP中的推测模式相似，推测消息使用低优先级VC，并且在发生拥塞时可以被网络丢弃。如果推测传输成功，例如在M1的肯定确认A1指示的情况下，则不需要保留。结果，当端点没有拥塞时，SMSRP几乎不会在网络中产生任何开销。</p>
<p>如果网络端点拥塞，则经过一段时间的排队延迟后，网络将丢弃推测性消息，就像消息M2一样。网络交换机将相应的NACK发送回源。当消息源收到NACK时，它将启动到目的地的预留Res2，以获取消息的重传时间。在从目的地接收到授权Gnt $t_2$之后，源将等待直到分配的传输时间$t_2$为止，然后再以非推测性模式重新传输M2。保证非推测性消息是无损的，并使用单独的更高优先级的VC来确保它们不会在推测性消息之后被阻塞。</p>
<p>除了在无拥塞的网络条件下具有较低的开销外，SMSRP的主要吸引力在于，它可以添加到已经实施SRP的网络中，而硬件改动很小。  SMSRP的投机丢弃策略和预约握手与SRP相同。唯一需要做的更改发生在源网络接口上：更改预约握手和推测性传输的顺序。</p>
<h3 id="Last-Hop-Reservation-Protocol"><a href="#Last-Hop-Reservation-Protocol" class="headerlink" title="Last-Hop Reservation Protocol"></a>Last-Hop Reservation Protocol</h3><p>在网络不拥塞的情况下，以推测方式急切传输小消息可减少SMSRP的控制开销。但是，SMSRP的缺点是，当需要预约来解决拥塞时，控制消息必须到达端点处的预约调度程序。结果，预留握手消息与数据分组竞争弹出信道带宽。对于小消息，控制数据包消耗的一部分弹出带宽会极大地导致目标的额外超额预订，并可能导致更多的推测性消息丢失。直观上，弹出通道带宽是关键资源，仅应为数据包保留</p>
<p>LHRP通过将预留调度程序从端点移动到端点上游的最后一跳交换机来避免导致端点超额预订。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200730071945735.png" alt="image-20200730071945735"></p>
<p>LHRP的详细操作如图所示。像上一节中的示例一样，网络源正在向可能超额订阅的端点发送两个小消息。这两个消息都由源以推测方式立即发送。如果推测传输成功（如M1的情况），则不需要保留，并且协议不会产生额外的开销。</p>
<p>LHRP通过将预留调度程序从端点移动到端点上游的最后一跳交换机来避免导致端点超额预订。通过允许在交换机为连接到该交换机的端点的服务保留请求提供服务时，我们消除了弹出通道的控制开销。在最后一跳交换机处处理预留也打开了其他优化机会。对于小消息，可以在数据消息本身以及与任何丢弃关联的NACK上piggy带保留和授权信息，而不是发送用于保留握手的单独控制包。此保留搭载优化对于SMSRP没有用，因为到达端点处的保留调度程序的数据包不再需要保留。</p>
<p>如果端点被超额预订，则拥塞将首先在最后一跳交换机处发生。就像M2一样，推测消息可能会在最后一跳交换机上遇到较大的排队延迟。与SRP和SMSRP不同，LHRP推测性数据包仅在最后一跳交换机处合格。我们修改了网络交换机，以跟踪与交换机相连的每个端点排队的数据包数量。当端点的排队级别超过阈值时，交换机将开始丢弃发往该端点的推测消息。排队阈值的目的是动态地维持推测丢弃率，以使拥塞的推测消息不会备份到相邻的交换机中，从而在网络的其余部分中造成树饱和。</p>
<p>当最后一跳交换机丢弃推测消息时，预留调度程序还为该消息分配了重传时间，该重传时间随NACK ，N2t2返回。当源节点接收到NACK时，它也接收到重发时间t2。然后，源节点以保证无损传输的非推测性模式在时间t2重新传输M2。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>SMSRP</tag>
        <tag>LHRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Congestion Avoidance Through Speculative Reservation</title>
    <url>/2020/07/29/Network-Congestion-Avoidance-Through-Speculative-Reservation/</url>
    <content><![CDATA[<a id="more"></a>
<p>SRP，Speculative Reservation Protocol，投机预约协议。</p>
<p>协议通过以下方式提高了拥塞控制的最新水平：</p>
<ul>
<li><p>SRP防止拥塞的形成，而不是在拥塞发生后对其进行反应。</p>
</li>
<li><p>SRP具有非常快速的瞬态响应，与易发生拥塞的流量的发生几乎立即做出反应，相比之下，像ECN这样的数据包标记协议需要数百微秒的响应时间。</p>
</li>
<li><p>SRP的开销很低，可以与网络媲美，而不会对良性流量进行拥塞控制。</p>
</li>
<li><p>SRP提高了争夺网络热点的来源之间的公平性。</p>
<p>阻塞案例：拥塞的扩散影响。</p>
</li>
</ul>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729205521681.png" alt="image-20200729205521681"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729205638729.png" alt="image-20200729205638729"></p>
<p>解决拥塞的办法：</p>
<ol>
<li><p>ECN</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729205721994.png" alt="image-20200729205721994"></p>
<p>启用ECN的路由器通过监视其输入或输出缓冲区的占用来检测拥塞。当缓冲区的占用率超过某个阈值时，路由器会标记通过缓冲区的数据包的ECN字段（在某些系统中，标记操作仅在标识为拥塞根源的端口上进行）。当标记的数据包到达其目的地时，ECN字段将使用拥塞通知数据包返回到数据包的源。发送方收到消息后会减缓发送速率，来缓解拥塞。在没有拥塞通知的情况下，发送方将逐渐提高其注入速率，以充分利用未拥塞网络的带宽。</p>
</li>
<li><p>Speculative Reservation Protocol</p>
<p>预防拥塞。</p>
<p>传输信息，需要一个预约许可的握手</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729210250143.png" alt="image-20200729210250143"></p>
<p>a)是正常运行的时序图，在这种情况下，网络中不存在热点。发送方S通过首先发出预留数据包R来启动到目的地D的通信。此预留数据包很小，具有较高的网络优先级，并且在单独的控制虚拟通道（VC）[8]上传输以保证快速传递。预留中携带预留大小n，它指示源打算发送的数据包数量。选择大小以分摊多个数据包之间的SRP开销，同时提供对多个流的公平性和响应性。</p>
</li>
</ol>
<p>发出预约后，S开始以投机地方式将数据包P1和P2发送至D。这些推测数据包在低优先级VC上传输，并且等待时间（TTW）有限。如果投机性数据包在网络内部的总累积排队时间大于其TTW，则路由器会将其丢弃。我们通过在到达路由器输入端口时对数据包打上时间戳，然后在数据包位于输入缓冲区的开头时对此时间戳执行检查来实现TTW跟踪。由于投机数据包的性质不可靠，因此需要ack以通知源是否已成功传送或丢弃了它们。</p>
<p>一旦预约数据包到达 <em>D</em>，目的地将根据其当前预约时间表返回一个携带发送起始时间的小型授权数据包 <em>G</em>($T_s$)（Grant）。另外，<em>D</em> 更新其预约时间表，它给下一个源的发送起始时间不会早于 <em>$T_s$</em> + <em>n</em>(1 + <em>ϵ</em>)$τ_p$。其中，常数 $τ_p$ 是目的地接收单个数据包的时间，<em>ϵ</em> 表示控制数据包（如 reservation、grant、ACK 等）的带宽开销。所有发送源都必须通过如此预约的方式想目的地进行预约并获得开始发送时间。</p>
<p>当 <em>S</em> 收到授权数据包时，它停止向 <em>D</em> 发送投机数据包。到达时间 $T_s$ 之后，<em>S</em> 以非投机数据包的模式（即正常数据包）恢复向 <em>D</em> 的传输，从图2.1（a）中的示例 <em>P</em>3 开始。正常数据包不能被丢弃，并且不需要 ACK。在 <em>S</em> 成功发送完所有<em>n</em> 个数据包之后，未来 <em>S</em> 和 <em>D</em> 之间的任何传输都将重复此预约过程。</p>
<p>图b显示了一个时序图，说明了在拥挤的网络中且节点 <em>D</em> 处有热点时的 SRP 执行过程。最初，<em>S</em> 发送预约数据包和投机数据包的过程与上述示例相同，具有较高网络优先级的预约数据包很快到达 <em>D</em>。但是，投机数据包在 <em>D</em> 附近遇到了较大的排队延迟。当排队延迟超过其 TTW 时，投机数据包被路由器丢弃，并且路由器返回 NACK 数据包给 <em>S</em>。当 <em>S</em> 收到 NACK 数据包时，它将停止向目标传输投机数据包，而后以正常数据包的模式在$T_s$处恢复数据包传输，从之前被丢弃的的数据包开始。</p>
<p>由于丢弃协议，每个预约内乱序包的到达都是可能的。在图b的情况下，如果NACK数据包在ts之后返回，则重新发送的数据包将以乱序到达D。这个可以通过牺牲带宽来避免这个问题。方法是通过修改协议，使得在达到ts之后，S重新传输所有未完成的推测性数据包。这样可以确保有序的数据包到达，但要以可能的重复数据包到达D为代价。</p>
<p>SRP 可以减少延迟和带宽开销。发送投机数据包可以减少 SRP 的等待时间开销。在中低网络负载下，大多数投机数据包能够到达目的地，并使得 SRP 的延迟与基准网络的延迟相同。为了防止超短流预约开销过大和长流长时间垄断热点目标，SRP 设置了两个阈值：<em>$n_{min}$</em> 和 $n<em>{max}$。当流长度 n &lt; $n</em>{min}$，绕过 SRP协议直接发送；当流长度 n &gt; $n<em>{max}$ 时，则将长流按照$n</em>{max}$进行分段，分为多个长度为的$n_{max}$流，SRP 将他们视为不同的流，分别进行预约。</p>
<p>在高网络负载下，由于增加的排队延迟，推测性数据包被更频繁地丢弃。丢弃推测性数据包会浪费网络带宽，并且是高负载时开销的主要来源。但是，推测性数据包永远不会减少可用于非推测性数据包的带宽，因为它们是在单独的较低优先级虚拟通道上发送的。可以通过调整推测的TTW和预留粒度来控制推测的丢弃开销。</p>
]]></content>
      <categories>
        <category>HiNA</category>
        <category>Papers</category>
        <category>拥塞控制</category>
      </categories>
      <tags>
        <tag>拥塞控制</tag>
        <tag>SRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch7</title>
    <url>/2020/07/29/Interconnection-Networks-ch7/</url>
    <content><![CDATA[<h2 id="CHAPTER-7-Slicing-and-Dicing"><a href="#CHAPTER-7-Slicing-and-Dicing" class="headerlink" title="CHAPTER 7 Slicing and Dicing"></a>CHAPTER 7 Slicing and Dicing</h2><p>我们首先看concentrators and distributors。集中器将多个终端节点的流量组合到单个网络通道上。当来自任何终端的流量很小以充分利用网络通道时，可以使用它们。它们还可以有效地组合来自许多突发性终端的流量。当峰值流量与平均流量之比较大时，使用集中器可降低序列化延迟，并降低网络成本。</p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch6</title>
    <url>/2020/07/28/Interconnection-Networks-ch6/</url>
    <content><![CDATA[<h2 id="Non-Blocking-Networks"><a href="#Non-Blocking-Networks" class="headerlink" title="Non-Blocking Networks"></a>Non-Blocking Networks</h2><a id="more"></a>
<p>如果网络可以处理输入和输出排列的所有电路请求，则称该网络为非阻塞网络。即，可以形成从每个输入到其选择的输出的专用路径，而没有任何冲突（共享通道）。相反，如果网络无法处理所有此类电路请求而没有冲突，则它就是阻塞网络.</p>
<p>两种类型的非阻塞网络。strictly non-blocking, rearrangeably non-blocking</p>
<p>首先，如果可以每次一个电路递增地设置任何排列，而无需重新路由（或重新排列）任何已设置的电路，则网络严格不阻塞。如果可以将任何未使用的输入连接到任何未使用的输出，而无需更改任何其他流量所采用的路径，则说明网络完全是无阻塞的。</p>
<p>相反，如果网络可以路由电路进行任意排列，则网络可重新排列为非阻塞（或简单地可重新排列），但是排列的渐进式构造可能需要重新布置一些早期电路，以允许以后建立电路。可重新排列的网络可以将任何未连接的输入连接到任何未连接的输出，但是可能需要重新路由一些不相关的流量才能建立连接。</p>
<h3 id="6-1-Non-Blocking-vs-Non-Interfering-Networks"><a href="#6-1-Non-Blocking-vs-Non-Interfering-Networks" class="headerlink" title="6.1 Non-Blocking vs. Non-Interfering Networks"></a>6.1 Non-Blocking vs. Non-Interfering Networks</h3><p>分组交换网络中，资源分配好之后就不会互相影响。</p>
<p>实际上无阻塞的网络就是为了实现无干扰的网络。</p>
<h3 id="6-2-Crossbar-Networks"><a href="#6-2-Crossbar-Networks" class="headerlink" title="6.2 Crossbar Networks"></a>6.2 Crossbar Networks</h3><p>一个n×m交叉开关或交叉点开关将n个输入直接连接到m个输出，没有中间级。</p>
<p>m=n,square</p>
<p>m&gt;n||m&lt;n,rectangular</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728123737611.png" alt="image-20200728123737611"></p>
<p>在输入线与输出线交叉的每个点（即，在每个交叉点），开关都可以选择将输入线连接到输出线。为了正确操作，每个输出最多必须连接到一个输入。但是，输入可以连接到多个输出.</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728124036608.png" alt="image-20200728124036608"></p>
<p>今天，大多数交叉开关都是使用数字逻辑实现的，其结构如图所示。 n条输入线中的每条连接到m  n：1多路复用器的一个输入。多路复用器的输出驱动m个输出端口。多路复用器可以通过驱动输出线的三态门或线或门实现。</p>
<p>简化图：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728124207488.png" alt="image-20200728124207488"></p>
<p>纵横开关显然对于单播和多播流量都严格不阻塞。可以通过开关不同开关门。</p>
<p>建造其他无阻塞网络，原因是成本和可伸缩性。</p>
<p>成本都是$N^2$的。</p>
<p>下图显示了如何使用2×2的n×n交叉开关阵列构造2n×2n交叉开关，从小型交叉开关构建大型交叉开关的成本也是二次方。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728125956171.png" alt="image-20200728125956171"></p>
<h3 id="6-3-Clos-Networks"><a href="#6-3-Clos-Networks" class="headerlink" title="6.3 Clos Networks"></a>6.3 Clos Networks</h3><h4 id="6-3-1-Structure-and-Properties-of-Clos-Networks"><a href="#6-3-1-Structure-and-Properties-of-Clos-Networks" class="headerlink" title="6.3.1 Structure and Properties of Clos Networks"></a>6.3.1 Structure and Properties of Clos Networks</h4><p>Clos网络是一个三阶段网络，其中每个阶段都由许多纵横开关组成。对称Clos的特征是三元组（m，n，r），其中m是中级开关的数量，n是每个输入（输出）开关上的输入（输出）端口的数量，r是输入和输出开关的数量。此处输入和输出都一样为r和n.对于不一样的网络可以设为$(m,n_0,n_1,r_0,r_1)$</p>
<p>中级交换机，到每个输入和输出交换机都有相应的链路。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728132321853.png" alt="image-20200728132321853"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728132403217.png" alt="image-20200728132403217"></p>
<p>在引用Clos网络的输入和输出端口时，我们将交换机s的端口p表示为s.p。</p>
<h4 id="6-3-2-Unicast-Routing-on-Strictly-Non-Blocking-Clos-Networks"><a href="#6-3-2-Unicast-Routing-on-Strictly-Non-Blocking-Clos-Networks" class="headerlink" title="6.3.2 Unicast Routing on Strictly Non-Blocking Clos Networks"></a>6.3.2 Unicast Routing on Strictly Non-Blocking Clos Networks</h4><p>定理：A Clos network is strictly non-blocking for unicast traffic iff m ≥ 2n − 1.</p>
<p>要将单播呼叫从a.i路由到b.j，可通过将a不使用的交换机列表与b不使用的交换机列表相交来找到中间级交换机。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729082144535.png" alt="image-20200729082144535"></p>
<p>如下图，电路从输入1.1（1）路由到输出3.3（9）。其中虚线为已经本占用的线路。最终选择为加粗的线。一个完整的排列{5、7、11、6、12、1、8、10、3、2、9、4}。也就是说，输入1（1.1）路由到输出5（2.2），输入2（1.2）路由到输出7（3.1），依此类推。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729081302659.png" alt="image-20200729081302659"></p>
<p>假设按{9,6,7,8,3,12,10,5,1,11,2,4}的顺序应用呼叫。</p>
<p>显示了在（5,3,4）Clos网络上路由此呼叫集的过程。该表的每一行对应于路由过程中的一个步骤。该表的每一行对应于路由过程中的一个步骤。前三列显示呼叫来自的输入交换机（进入），呼叫去向的输出交换机（离开）和分配给呼叫的中间交换机（中间）。其余八列给出位向量，显示哪些中间交换机不受每个输入和输出开关的影响。</p>
<p>第一个呼叫为9（3，3），查排列集合，输入交换机为3，输出应该为3，交换机为输出switch1。并且由于第一个调用没有阻塞的路径，因此将其分配给中间交换机1.所以将输入交换机的路径3到中间交换机1忙（输入空闲3 = 01111），从中间交换机1到输出交换机1的路径忙（输出空闲1 = 01111）。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729083340014.png" alt="image-20200729083340014"></p>
<h4 id="6-3-3-Unicast-Routing-on-Rearrangeable-Clos-Networks"><a href="#6-3-3-Unicast-Routing-on-Rearrangeable-Clos-Networks" class="headerlink" title="6.3.3 Unicast Routing on Rearrangeable Clos Networks"></a>6.3.3 Unicast Routing on Rearrangeable Clos Networks</h4><p>定理：A Clos network with m ≥ n is rearrangeable.</p>
<p>显示了一种在可重排的非阻塞网络上路由一组呼叫的算法。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729093630509.png" alt="image-20200729093630509"></p>
<p>定理：使用循环算法建立单个呼叫需要最多重新安排2r-2个其他呼叫。</p>
<h4 id="6-3-4-Routing-Clos-Networks-Using-Matrix-Decomposition"><a href="#6-3-4-Routing-Clos-Networks-Using-Matrix-Decomposition" class="headerlink" title="6.3.4 Routing Clos Networks Using Matrix Decomposition"></a>6.3.4 Routing Clos Networks Using Matrix Decomposition</h4><p>利用矩阵来路由网络。</p>
<p>矩阵R，每一个元素$X_{ij}$表示从输入交换机i到输出交换机j的呼叫次数。</p>
<p>例子：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729094145622.png" alt="image-20200729094145622">该矩阵可以分解为一组m个正矩阵的总和，其中每一行和每一列的总和最多为1。该组中的每个矩阵对应于中间级开关的设置。<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729094247379.png" alt="image-20200729094247379"></p>
<p>矩阵分解可用于路由单播或多播流量，并可应用于可重排和严格无阻塞的Clos网络。</p>
<h4 id="6-3-5-Multicast-Routing-on-Clos-Networks"><a href="#6-3-5-Multicast-Routing-on-Clos-Networks" class="headerlink" title="6.3.5 Multicast Routing on Clos Networks"></a>6.3.5 Multicast Routing on Clos Networks</h4><p>定义：多播呼叫集合$C={c<em>1,c_2,……,C_n}$，其中每个多播呼叫$c_i=(a_i,、{b</em>{i1},b<em>{i2}……,b</em>{if}})$，输入端口$a<em>i$，$f$个输出端口$b</em>{i1},b<em>{i2}……,b</em>{if}$，$f$为扇出。</p>
<p>例子：考虑多播调用集（只考虑交换机号）：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729095529689.png" alt=""></p>
<p>向量表示：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729095559587.png" alt="image-20200729095559587"></p>
<p>如果$c_i \bigwedge c_j=0$ ,$c_i,c_j$可以映射到相同的中间阶段。</p>
<p>上图实例不能实现，所以需要扇出。</p>
<p>通过在输入开关中执行扇出，可以将输出集分配到多个中间阶段。</p>
<p>k-way输入扇出，就是将$c_i={a,B}$分成k个呼叫，分别为：</p>
<p>$c<em>{i1}=(a,B_1),…,c</em>{ik}=(a,B<em>k),\bigcup</em>{j=1}^kB_j=B$</p>
<p>将上面的集合分解如下：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729102606396.png" alt="image-20200729102606396"></p>
<p>中间交换机的使用：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103143490.png" alt="image-20200729103143490"></p>
<p>最终的路由线路：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729102709756.png" alt="image-20200729102709756"></p>
<p>知道中间交换机的数理，扇出的限制：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103305798.png" alt="image-20200729103305798"></p>
<p>知道了扇出，中间交换机的要求：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103331640.png" alt="image-20200729103331640"></p>
<p>算法流程：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200729103048886.png" alt="image-20200729103048886"></p>
<h3 id="6-4-Beneˇ-s-Networks"><a href="#6-4-Beneˇ-s-Networks" class="headerlink" title="6.4 Beneˇ s Networks"></a>6.4 Beneˇ s Networks</h3><p>由2×2交换机构成的Clos网络也称为Beneˇ网络</p>
<h3 id="6-5-Sorting-Networks"><a href="#6-5-Sorting-Networks" class="headerlink" title="6.5 Sorting Networks"></a>6.5 Sorting Networks</h3><p>N输入分类网络在其N个输入端子上接受一组用唯一分类键标记的N条记录，并在其N个输出端子上按键顺序输出这些记录。</p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch5-1</title>
    <url>/2020/07/20/Interconnection-Networks-ch5-1/</url>
    <content><![CDATA[<h2 id="Torus-Network"><a href="#Torus-Network" class="headerlink" title="Torus Network"></a>Torus Network<a id="more"></a></h2><h3 id="5-3-Building-Mesh-and-T-orus-Networks"><a href="#5-3-Building-Mesh-and-T-orus-Networks" class="headerlink" title="5.3 Building Mesh and T orus Networks"></a>5.3 Building Mesh and T orus Networks</h3><p>将网络的抽象节点映射到物理空间中的实际位置，不同的封装技术可以实现一维的，二维的等映射。</p>
<ul>
<li><p>最简单的方式就是$p_i=a_i$，物理位置和逻辑地址相同，每个节点之间距离相同。</p>
</li>
<li><p>但是这将导致$p_k和p_0$之间距离过大，如此长的信道可能导致过多的等待时间或需要较慢的信令速率。所以提出折叠的环形网络来解决问题。一种环形网络的折叠入下：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727131524647.png" alt="image-20200727131524647"></p>
<p>消灭了 最长的网络，但是牺牲了以相邻节点距离短的优点。</p>
</li>
</ul>
<p>最终的物理放置图对比：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727131557787.png" alt="image-20200727131557787"></p>
<p>通常，通过以折叠顺序组合k个折叠的k-ary n-1cube来构造折叠的k-ary n-cube</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727131614133.png" alt="image-20200727131614133"></p>
<p>当逻辑维数超过物理维数时，必须将几个逻辑维映射到每个物理维中。如果物理维数为q，则直接映射是将逻辑维的q折叠为每个物理维。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727132711914.png" alt="image-20200727132711914"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200727132749954.png" alt="image-20200727132749954"></p>
<h3 id="Express-Cubes"><a href="#Express-Cubes" class="headerlink" title="Express Cubes"></a>Express Cubes</h3><p>原因：环状网络通道短，$t_c$时间通常由$t_r$决定，与直径小的网络相比，导致更多的$T_H$。可以增加维度减小直径。但是会导致$T_s$增大。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728114113438.png" alt="image-20200728114113438"></p>
<p>所以Express sube出现了。就是添加了几个快速通道。通过路由必须在快速通道上的某个维度上经过较长距离的数据包，报头等待时间可以减少到接近信道等待时间限制。因为可以控制快速通道的数量以匹配网络的二等分宽度，所以可以在不增加序列化延迟的情况下实现报头延迟的减少。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728114625185.png" alt="image-20200728114625185"></p>
<p>每个维度，每隔i个节点设置一个express channel。</p>
<p>普通网络中，在j维度有$H_j$跳，那么在快速立方体中，跳数为：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728115227480.png" alt="image-20200728115227480"></p>
<p>对于长的维度，选择$i = \frac{t_r}{t_c}$,来平衡式中的两项，短的维度，选择$i=\sqrt{H_min}$</p>
<p>分层的快速cube:</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728120044122.png" alt="image-20200728120044122"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200728120023536.png" alt="image-20200728120023536"></p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-10</title>
    <url>/2020/07/20/Interconnection-Networks-ch5/</url>
    <content><![CDATA[<h2 id="CH4-Torus-Networks"><a href="#CH4-Torus-Networks" class="headerlink" title="CH4 Torus Networks"></a>CH4 Torus Networks<a id="more"></a></h2><p>圆环和网状网络（ k-ary n-cubes）在规则的n维网格中打包$N=k^n$个节点，每个维中都有k个节点，并且最近邻之间有通道。</p>
<p>优点：</p>
<ul>
<li>这种规则的物理布置与包装约束非常匹配。</li>
<li>具有良好的路径分集，即使在排列流量上也可以具有良好的负载平衡。</li>
<li>通道是双向的,可以利用双向信令，从而更有效地利用引脚和电线。</li>
</ul>
<p>缺点：</p>
<ul>
<li>它们的跳数比对数网络大；</li>
<li>增加了网络的引脚成本。</li>
</ul>
<h3 id="4-1The-Structure-of-T-orus-Networks"><a href="#4-1The-Structure-of-T-orus-Networks" class="headerlink" title="4.1The Structure of T orus Networks"></a>4.1The Structure of T orus Networks</h3><ul>
<li>$N=k^n$个节点</li>
<li>每个维中都有k个节点</li>
<li>每个节点同时充当网络的输入端，输出端和交换节点</li>
<li>每个节点被分配一个n-digit radix-k地址{an−1,…,a0}</li>
<li>通过一对通道（每个方向一个）连接到地址相差±1（mod k）的所有节点。只需一个地址位。</li>
<li>每个节点每个维度需要2个通道，总共2nN个通道。</li>
</ul>
<p>规则的（所有节点的度数相同），并且也是边缘对称的。<br>网状网络和环状网络的区别：</p>
<ol>
<li>网状网络 在每个方向上都省略了从地址ak−1到地址a0的连接</li>
<li>网状网络具有相同的节点度，但是对等通道的数目是具有相同基数和尺寸的圆环的一半</li>
<li>放弃了圆环的边缘对称性，对中央通道的需求可能会大大高于对边缘通道的需求</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200720140511291.png" alt="image-20200720140511291"></p>
<p>环面网络的每个维度都可以具有不同的基数。例如，下图说明了一个2,3,4-ary 3-mesh，其y方向的基数为2<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200720141524634.png" alt="image-20200720141524634"></p>
<h3 id="5-2-performance"><a href="#5-2-performance" class="headerlink" title="5.2 performance"></a>5.2 performance</h3><p>throughput, latency, and path diversity.</p>
<h4 id="5-2-1-Throughput"><a href="#5-2-1-Throughput" class="headerlink" title="5.2.1 Throughput"></a>5.2.1 Throughput</h4><p>在两层封装模型中，吞吐量受引脚带宽或二等分带宽限制。我们首先考虑对分限制并计算网络的信道对分为:</p>
<p>k为偶数</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161336861.png" alt="image-20200722161336861"></p>
<p>由于<strong>圆环</strong>既是节点对称的，又是边缘对称的，从平分信道负载中确定均匀流量下的信道负载。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161423232.png" alt="image-20200722161423232"></p>
<p>由于<strong>圆环</strong>的边缘对称性：</p>
<p>​                    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161456946.png" alt="image-20200722161456946"></p>
<p>由于网格是不对称的，由于上面用于圆环的跳数，它无法达到下限。相反，在统一流量下<strong>网格</strong>的信道负载为<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161558619.png" alt="image-20200722161558619"></p>
<p>对于最坏情况的流量，所有流量都会越过平分线，并且通道负载会加倍。        </p>
<p>​                            <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161807795.png" alt="image-20200722161807795"></p>
<p>每个节点四个信道：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161854710.png" alt="image-20200722161854710"></p>
<p><strong>圆环</strong>的最大通道宽度<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161920581.png" alt="image-20200722161920581"></p>
<p><strong>网格</strong>的：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161938362.png" alt="image-20200722161938362"></p>
<p>计算均匀负载下的吞吐量：</p>
<p>​    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722161959797.png" alt="image-20200722161959797"></p>
<h4 id="5-2-2-Latency"><a href="#5-2-2-Latency" class="headerlink" title="5.2.2 Latency"></a>5.2.2 Latency</h4><p><strong>环形</strong>网络的延迟在很大程度上取决于尺寸。在低维度上，延迟是由高跳数决定的。在维度的极端情况下，串行延迟由于通道宽度w的狭窄而占主导地位。最佳等待时间通常发生在较低的中间维度。</p>
<p><strong>环型</strong>网络的串行化等待时间</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722162116800.png" alt="image-20200722162116800"></p>
<p><strong>网格</strong>网络</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722162144750.png" alt="image-20200722162144750"></p>
<p><strong>圆环</strong>网络中的平均最小跳数是通过对所有节点对上的最短距离求平均来确定的，从而得出<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722162239212.png" alt="image-20200722162239212"></p>
<p><strong>网格网络</strong>：在均匀的流量和偶数基数的情况下，数据包平均在n个维度中的每个维度上四分之一地传播，即$\frac{k}{4}$跳。因此偶数k，跳数为$\frac{nk}{4}$,对于奇数k，平均距离包括一个小的附加系数。</p>
<p>​    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722163218184.png" alt="image-20200722163218184"></p>
<h4 id="5-2-3-Path-Diversity"><a href="#5-2-3-Path-Diversity" class="headerlink" title="5.2.3 Path Diversity"></a>5.2.3 Path Diversity</h4><p>路径数量，我们只考虑最短路径，并且所有路径在每个维度（单向路线）都采用相同的方向。</p>
<ul>
<li><p>一维网络，只有一个路径</p>
</li>
<li><p>二维网络，考虑节点a，b，如果在x方向，二者被$\Delta x$跳分割，y方向上，$\Delta y$跳，那么路径数量为：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
R_{ab}
\end{vmatrix}=\binom{\Delta_x+\Delta_y}{\Delta_x}</script></li>
<li><p>三维网络，增加z的维度</p>
</li>
</ul>
<script type="math/tex; mode=display">
    \begin{vmatrix}
    R_{ab}
    \end{vmatrix}=\binom{\Delta_x+\Delta_y+\Delta_z}{\Delta_x}\binom{\Delta_y+\Delta_y}{\Delta_y}=\frac{(\Delta_x+\Delta_y+\Delta_z)!}{\Delta_x!\Delta_y!\Delta_z!}</script><ul>
<li>n维：从a到b的最小单向路线的总数为<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200722181511667.png" alt="image-20200722181511667"></li>
</ul>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection-Networks-ch4.md</title>
    <url>/2020/07/19/Interconnection-Networks-ch3/</url>
    <content><![CDATA[<h2 id="Butterfly-Networks"><a href="#Butterfly-Networks" class="headerlink" title="Butterfly Networks"></a>Butterfly Networks</h2><p>俩个主要的拓扑家族</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719101415173.png" alt="image-20200719101415173"></p>
<p>蝶形网络是最基本的间接网络。</p>
<p>对于交换机度数为$\delta = 2k, H = \log_kN +1$的N个节点的网络，BN拥有最小的直径。</p>
<p>缺点：</p>
<ol>
<li>no path diversity: there is exactly one route from each source node to each destination node.</li>
<li>the butterfly cannot be realized without long wires that must traverse at least half the diameter of the machine. </li>
</ol>
<h3 id="4-1The-Structure-of-Butterfly-Networks"><a href="#4-1The-Structure-of-Butterfly-Networks" class="headerlink" title="4.1The Structure of Butterfly Networks"></a>4.1The Structure of Butterfly Networks</h3><p> k-ary n-fly</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719114542950.png" alt="image-20200719114542950"></p>
<p>2-ary 4-fly</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719114551161.png" alt="image-20200719114551161"></p>
<p>​    k-ary n-fly网络由$k^n$个源终端节点，n个阶段, 每个阶段$k^{n-1}$ k×k crossbar switch节点以及最后$k^n$目的地终端节点组成。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719115531276.png" alt="image-20200719115531276">            </p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719144626828.png" alt="    ">        </p>
<p>​    关于网络中报文的走向问题。</p>
<p>根据每一个发出报文的终端编号可以决定不同路由路径。我们使用 n-digit radix-k number, ${d<em>{n−1},d</em>{n−2},…,d_0}$. 来表示每一条路径。</p>
<p>对于k-ary n-fly网络。每一级有$k^{n-1}$个路由器，所以需要有n-1比特来进行选择。前n−1个数字${d<em>{n−1},d</em>{n−2},…,d_1}$.标识交换机，最后一个数字$d_0$标识交换机上的终端也就是决定了最终出口的选择。具体的使用如下：</p>
<ol>
<li>​    从输入节点开始，比如9这个输入节点，对应的二进制为1001；前三位为100，那么第0级交换机选择为4号。</li>
<li>此时，d_0可以随机选择为0或者1，这是再将d_0和d_3进行交换，可以得到前三位000或者100，这样第1级交换机可以选择为1，0或者1，4.</li>
<li>依次类推，最好已经决定输出的终端。</li>
</ol>
<p>具体来说：第一级设置dn−1，第二级设置dn−2，依此类推，最后一级设置d0已处于正确位置，</p>
<h3 id="4-2-Isomorphic-Butterflies（同构）"><a href="#4-2-Isomorphic-Butterflies（同构）" class="headerlink" title="4.2 Isomorphic Butterflies（同构）"></a>4.2 Isomorphic Butterflies（同构）</h3><p>网络K，其节点和信道集定义：$K=(N^*，C)$。</p>
<p>如果$K_1=(N_1,C_1),K_2=(N_2,C_2)$是同构的 ：</p>
<p>​         顶点中存在一个置换$\pi$，对于边${u,v}\ \in C_1$存在${\pi(u),\pi(v)} \in C_2$</p>
<h3 id="4-3-Performance-and-Packaging-Cost"><a href="#4-3-Performance-and-Packaging-Cost" class="headerlink" title="4.3 Performance and Packaging Cost"></a>4.3 Performance and Packaging Cost</h3><p>​    对于k-ary,n-fly网络：</p>
<p>​    交换节点的度$\delta _{fly}= 2k$</p>
<p>​    信道二等分(N是偶数)$B_{C,fly } = \frac{N}{2}$</p>
<p>​                                        <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719160533316.png" alt="image-20200719160533316"></p>
<p>​    信道负载</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719160543008.png" alt="信道负载"></p>
<p>计算出两层包装层次结构下蝶形网络的通道宽度：    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719172821869.png" alt="image-20200719172821869">        </p>
<p>在均匀负载且γ= 1的情况下，理想吞吐量：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719173001335.png" alt="image-20200719173001335"></p>
<p>蝶形网络的目标：</p>
<p>​    目标是首先获得最大的吞吐量，其次是最大程度地减少消息延迟。</p>
<p>为此选择最大的K</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200719173225620.png" alt="image-20200719173225620"></p>
<p>这个k值给出了最小的直径，这使得延迟的H部分最小化，同时使信道带宽最大化。这也最大限度地提高了理想的吞吐量并最小化了序列化延迟。任何小于此值的k都不会提高吞吐量，只会由于额外的跃点计数而增加延迟.</p>
<h3 id="4-4-Path-Diversity-and-Extra-Stages"><a href="#4-4-Path-Diversity-and-Extra-Stages" class="headerlink" title="4.4 Path Diversity and Extra Stages"></a>4.4 Path Diversity and Extra Stages</h3><p><img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20200720071823533.png" alt="image-20200720071823533">没有路径多样性</p>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection_Networks-ch2</title>
    <url>/2020/07/09/Interconnection-Networks-ch2/</url>
    <content><![CDATA[<h2 id="CH2-A-Simple-Interconnection-Network"><a href="#CH2-A-Simple-Interconnection-Network" class="headerlink" title="CH2 A Simple Interconnection Network"></a>CH2 A Simple Interconnection Network</h2><h3 id="2-1网络规范和限制"><a href="#2-1网络规范和限制" class="headerlink" title="2.1网络规范和限制"></a>2.1网络规范和限制</h3><p>​    有关网络设备的规范和约束，规范比如端口数量，传输速率。约束有关带宽，消耗。</p>
<h3 id="2-2拓扑"><a href="#2-2拓扑" class="headerlink" title="2.2拓扑"></a>2.2拓扑</h3><p>​    蝶形网络拓扑</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200713072010.png" alt="image-20200709110727663"></p>
<p>​    speedup 加速比 网络总输入带宽与网络理想容量的比值。也被称为蝶形基数。</p>
<h3 id="2-5路由器"><a href="#2-5路由器" class="headerlink" title="2.5路由器"></a>2.5路由器</h3><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200713072031.png" alt="image-20200713071446699"></p>
<p>路由器的数据路径包括四个18位输入寄存器，四个18位4：1多路复用器，四个移位器（用于移位标头phits的路由字段）和四个18位输出寄存器。数据路径由144位寄存器和大约650个门（等效于2个输入NAND）组成。</p>
<h4 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h4><p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200713072037.png" alt="image-20200713071629935"></p>
<p>分配器由四个几乎相同的位片组成，每个位片分为三个部分：解码，仲裁和保持。</p>
<p>在解码部分中，对每个输入phit的高四位进行解码。每个解码器生成两个信号。如果输入i是一个head phit并且路由字段的高两位与输出端口号匹配，则信号i请求为true。此信号指示输入phit请求使用此头phit开始使用输出端口路由数据包。如果输入i上的点是有效载荷点，则解码器还会生成信号有效载荷i。分配器的保持逻辑使用此信号在数据包持续时间内保持信道（只要有效载荷位在所选输入端口上）</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>通过三种方法来判断互连网络：成本，延迟和吞吐量。延迟和吞吐量都是性能指标：延迟是数据包穿越网络所花费的时间，吞吐量是网络可以从输入传输到输出的每秒位数。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715163552820.png" alt="image-20200715163552820"></p>
<p>对加权延迟求和，我们将平均延迟计算为</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715164709817.png" alt="image-20200715164709817"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715164655766.png" alt="image-20200715164655766"></p>
<p>延迟和吞吐率的曲线</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715165107829.png" alt="image-20200715165107829"></p>
<p>相对延迟是简单网络的所提供流量（注入速率）的函数。实线显示了本文中介绍的简单模型，而虚线则包含了额外的排队延迟。</p>
<h2 id="CH3-T-opology-Basics"><a href="#CH3-T-opology-Basics" class="headerlink" title="CH3 T opology Basics"></a>CH3 T opology Basics</h2><ol>
<li>重要性</li>
</ol>
<ul>
<li>是设计第一步，决定了策略路由和流控制方法；</li>
<li>拓扑不仅指定网络的类型（例如，蝶形），还指定详细信息，例如交换机的基数，级数以及宽度和比特率每个频道</li>
</ul>
<ol>
<li>考虑的东西</li>
</ol>
<ul>
<li>端口数量以及每个端口的带宽和占空比的驱动</li>
<li>每个芯片和板可用的引脚，线密度，可用的信号速率以及驱动器的驱动</li>
<li>成本和性能。性能包括带宽和延迟，由拓扑以外的因素决定，例如，流量控制，路由策略和流量模式。</li>
</ul>
<ol>
<li>评价</li>
</ol>
<ul>
<li>二等分带宽，信道负载和路径延迟之类的措施，这些措施反映了拓扑对性能的影响。</li>
</ul>
<ol>
<li>设计的陷阱</li>
</ol>
<p>​    尝试使网络的拓扑结构与当前问题的数据通信相匹配。</p>
<p>​    原因：专用网络通常不是好主意，问题中的动态负载不平衡，或者问题大小与计算机大小之间不匹配，因此此类网络上的负载通常平衡不佳。如果重新分配数据和线程以平衡负载，则问题和网络之间的匹配将丢失。特定问题的网络通常无法很好地映射到可用的封装技术，需要较长的导线或较高的节点度。最后，这样的网络是不灵活的。如果算法更改为使用其他通信模式，则无法轻松更改网络。</p>
<ol>
<li>拓扑案例</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200715175324694.png" alt="image-20200715175324694"></p>
<h3 id="3-1-Nomenclature（命名法）"><a href="#3-1-Nomenclature（命名法）" class="headerlink" title="3.1 Nomenclature（命名法）"></a>3.1 Nomenclature（命名法）</h3><h4 id="3-1-1-Channels-and-Nodes"><a href="#3-1-1-Channels-and-Nodes" class="headerlink" title="3.1.1 Channels and Nodes"></a>3.1.1 Channels and Nodes</h4><p>​    互连网络的拓扑结构由一组节点N <em>指定，该节点N </em>通过一组通道C连接。消息在一组终端节点N（其中N≥N *）中发起和终止。</p>
<p>​    拓扑有向图</p>
<p>channel c = (x, y) ∈ C。x是源节点$sc$，y是目的节点$dc$</p>
<p>信道特征：</p>
<ul>
<li>width($w<em>c$,$w</em>{xy}$)   包含的并行信号数</li>
<li>frequency, $f<em>c$or $f</em>{xy}$    每个信号上的比特传输速率</li>
<li>latency, $t<em>c$or$ t</em>{xy}$    从x到y所需的时间。与传播速度和信道的物理长度直接相关$l_c = v<em>t_c$.信道带宽$b_c=w_c</em>f_c$</li>
</ul>
<h4 id="3-1-2-Direct-and-Indirect-Networks"><a href="#3-1-2-Direct-and-Indirect-Networks" class="headerlink" title="3.1.2 Direct and Indirect Networks"></a>3.1.2 Direct and Indirect Networks</h4><h4 id="3-1-3-Cuts-and-Bisections"><a href="#3-1-3-Cuts-and-Bisections" class="headerlink" title="3.1.3 Cuts and Bisections"></a>3.1.3 Cuts and Bisections</h4><p>​    网络切割点$C(N_1,N_2)$是一组通道，它将所有节点N *的集合划分为两个不相交的集合$N_1$和$N_2$</p>
<p>$C(N_1,N_2)$每个元素都是一个通道，其源位于N1，目标位于N2，反之亦然。cut的带宽：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716092425525.png" alt="image-20200716092425525"></p>
<p>​    Bisection二等分，就网络几乎分为一半的cut满足$N_2\le N_1 \le N_2+1$</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093016194.png" alt="image-20200716093016194"></p>
<p>​    有最小信道数</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093153743.png" alt="image-20200716093153743"></p>
<h4 id="3-1-4-Paths"><a href="#3-1-4-Paths" class="headerlink" title="3.1.4 Paths"></a>3.1.4 Paths</h4><p>信道的有序集合<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093402879.png" alt="image-20200716093402879">$d<em>{c_i} = s</em>{c_{i+1}}$</p>
<p>minimal path 节点x到节点y的跳数最小的路径</p>
<p>$R_{xy}$所有x到y的最小路径的集合</p>
<p>$H(x,y)$是最小路径的节点跳数</p>
<p>网络的直径。所有节点对中$R_{xy}$    的最大值</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716093858198.png" alt="image-20200716093858198"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716094313632.png" alt="image-20200716094313632"></p>
<p>平均最小跳数</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716094621734.png" alt="image-20200716094621734"></p>
<h4 id="3-1-5-对称性"><a href="#3-1-5-对称性" class="headerlink" title="3.1.5 对称性"></a>3.1.5 对称性</h4><p>​    节点对称，边对称</p>
<h3 id="3-2-交通模式"><a href="#3-2-交通模式" class="headerlink" title="3.2 交通模式"></a>3.2 交通模式</h3><p>​    考虑互连网络中消息的空间分布是很有用的。利用流量矩阵$\wedge$. 每个矩阵元素$\lambda_{s,d}$给出从节点s发送到节点d的流量份额</p>
<p>​    评估互连网络的常见静态流量模式    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716100035143.png" alt="image-20200716100035143"></p>
<p>​    随机流量：网络评估中最常用的流量模式是随机流量，其中每个源均可能发送到每个目的地。随机流量非常有益，因为通过使流量均匀分布，即使是通常负载平衡非常差的拓扑和路由算法，它也可以平衡负载。仅使用随机流量进行评估时，某些非常差的拓扑和路由算法看起来非常好。</p>
<p>​    permutation（置换流量）：为了强调拓扑或路由算法，我们通常使用置换流量，其中每个源s将其所有流量发送到单个目标d  =π（s）。用于排列的流量矩阵是一个排列矩阵（其中每一行和每一列包含一个条目，所有其他条目均为零。由于它们将负载集中在单独的源－目的地对上，因此排列会强调拓扑和路由算法的负载平衡。</p>
<h3 id="3-3performance"><a href="#3-3performance" class="headerlink" title="3.3performance"></a>3.3performance</h3><h4 id="3-3-1Throughput-and-Maximum-Channel-Load"><a href="#3-3-1Throughput-and-Maximum-Channel-Load" class="headerlink" title="3.3.1Throughput and Maximum Channel Load"></a>3.3.1Throughput and Maximum Channel Load</h4><p>​    网络的吞吐量是网络每个输入端口接受的数据速率（以比特/秒为单位）。吞吐量是整个网络的属性，并且取决于路由和流量控制（如我们在第2章中所看到的）以及拓扑。</p>
<p>​    信道负载：$\gamma_c$定义为通道c所需带宽与输入端口带宽之比。等效地，该比率是如果每个输入根据给定的流量模式注入一个流量单位，则必须穿越通道c的流量数量。因为是比率，所以通道负载是无量纲的量。</p>
<p>​    maximum channel load $\gamma<em>{max}=max</em>{c \in C}\gamma<em>c$ 当提供的流量达到网络的吞吐量时，此瓶颈通道上的负载将等于通道带宽b。定义理想吞吐量$\Theta</em>{ideal} = b/\gamma_{max}$</p>
<p>​    负载下限：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716204550252.png" alt="image-20200716204550252"></p>
<p>​    负载上限：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716204900596.png" alt="image-20200716204900596"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716205205552.png" alt="image-20200716205205552"></p>
<h4 id="3-3-2-Latency"><a href="#3-3-2-Latency" class="headerlink" title="3.3.2 Latency"></a>3.3.2 Latency</h4><p>网络的等待时间是指从数据包的头部到达输入端口的时间到数据包的尾部离开输出端口的时间</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716212441662.png" alt="image-20200716212441662"></p>
<p>$T_h$头等待时间。报文的头部头经过网络所需的时间</p>
<p>$T_s$序列化等待时间，尾部追赶所需的时间，即长度为L的数据包穿过带宽为b的信道的时间。</p>
<p>$T_0$表示零负载下没有竞争发生的延迟</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200716213005459.png" alt="image-20200716213005459"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200717193238297.png" alt="image-20200717193238297">s</p>
<p>​    $t_r$路由延迟</p>
<p>​    $t_{xy}$链路延迟</p>
<h4 id="3-3-3-Path-Diversity"><a href="#3-3-3-Path-Diversity" class="headerlink" title="3.3.3 Path Diversity"></a>3.3.3 Path Diversity</h4><p>​    节点不相交路径</p>
<p>​    边不相交路径</p>
<h3 id="3-4-Packaging-Cost"><a href="#3-4-Packaging-Cost" class="headerlink" title="3.4 Packaging Cost"></a>3.4 Packaging Cost</h3><ol>
<li>通道宽度w受每个节点的引脚数和全局布线总量的限制。</li>
</ol>
<p>​    基于典型的两层封装层次结构</p>
<p>​    第一层，各个路由器通过本地布线连接。</p>
<p>​    第二层，通过全局布线连接本地节点组。</p>
<p>​    对于最大引脚数为$W_n$的节点，通道宽度w受以下条件约束：<img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200718190946225.png" alt="image-20200718190946225"></p>
<p>​    在此级别上，可用的全局导线数$W_s$限制了各个通道的宽度。</p>
<p>​    为了估计特定拓扑所需的全局通道数，我们使用拓扑的最小通道二等分$B_c$</p>
<p>​        优点：</p>
<p>​            平均划分网络，又减少了导线的数量。有利于本地打包。        </p>
<p>​        缺点：</p>
<p>​            许多网络必须划分为两个以上的本地组才能满足打包技术的约束，无法实现</p>
<p>​        带宽约束：    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200718193846863.png" alt="image-20200718193846863"></p>
<p>综上：    <strong>$ \omega \leq min(\frac{W_n}{\delta}, \frac{W_s}{B_C})$.</strong></p>
<p>​    利用带宽来表示，而不是使用信道宽度.</p>
<p>​    节点的最大带宽为$B_n = fW_n$，系统二等分的最大带宽为$B_s = fW_s$。</p>
<p>​    则：每个通道的最大带宽为 $b \leq min(\frac{B_n}{\delta}, \frac{B_s}{B_C})$</p>
<ol>
<li><p>布线长度</p>
<p>网络通道的长度必须保持较短，因为在临界长度以上，信号频率会随着导线长度呈二次方下降：</p>
<script type="math/tex; mode=display">
f = min(f_0,f_0(\frac{l_w}{l_c})^{-2})</script><p>$l_c$:导线的临界长度</p>
<p>$f_0$:导线的标称信号传输率</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>书生</title>
    <url>/2020/07/04/%E4%B9%A6%E7%94%9F/</url>
    <content><![CDATA[<p>书生不可以没有，但空谈误国！</p>
<p>不可以空谈，但是要有向往！！！</p>
<p>少年中国有希望！</p>
]]></content>
      <categories>
        <category>我团</category>
      </categories>
      <tags>
        <tag>生活的感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划一点收获</title>
    <url>/2020/06/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E7%82%B9%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<h2 id="动态规划——收获"><a href="#动态规划——收获" class="headerlink" title="动态规划——收获"></a>动态规划——收获</h2><p>​    <a href="https://yunruowu.github.io/2020/06/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%88%91%E6%9D%A5%E5%BA%B7%E5%BA%B7/" target="_blank" rel="noopener">动态规划第一篇</a></p>
<p>​    之前说了最近要学习动态规划算法，然后自己也刷了十几道题目。下面说一下自己的看法。</p>
<p>​    首先动态规划的效率确实比很多暴力解法要好很多。但是同时必须要付出空间上的开销。一般都是一个dp数组。从我做的题目来看，动态规划就是求解N处的某个问题的解f(n)的最优解。同时f(n)又与f(n-1),f(n-2)等有关。最重要的就是如何求解这些关系。暴力方法可以使用递归直接去求解，但是如果用树形图画出求解过程，就会发现有很多f(k)会被多次计算，这就是开销最大的地方。那么我们自然而然的想法就是减少f(k)的计算次数，怎么做？一种是带一个备忘录，这个方法也不是最优的。最优的是自底向上的来计算f(i)并且进行记录，这样可以减少子问题的计算次数，也就提升了计算效率。有时间再取一些例子进行分享。</p>
<p>​    😪</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>20.6.25一点杂念</title>
    <url>/2020/06/25/20-6-25%E4%B8%80%E7%82%B9%E6%9D%82%E5%BF%B5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="129ac185bb8e07a2ff6d75c855c12cd3d55688b6dbeff3094961faf4454e4f5f">0ad2aeb4bf0a00f059acc3e8525b3e6ccc39d5851c0af66bbc3eb19a31ba06d91ce96607dc89cfe75a1cf6912357a7f456f3009b5b8a2ade50ccc8a241c81a137a1ff269b53258d443b07cd77e5a40802e9cdacb512e7eb2161b0c555cba242801a8e5e4a7f25492370d186952a1a53f7e3db269fe089c031868a2fb015391392c349ec292239bc5a37694264115c6738ef6b3045233e66870125474876deef9b974f18ddfa0825971188a036c19f594257dca600d303c625d7ac92e73dab83cbc5e5d8df258e97490e19fe0592bd3dfebf90d1a5629af5ceeba38a3098ecd78a86eae466d675755d26013b886c17211c62fa82c23ed5d9fc671009071e4abd699809a6b7ace29c48e6f08762aba55d56f51457f103f9d3cd5fea7d8ce0f376d1e2e46eea8a210b474fe622a2bb5d78696452a4b4414910966097f0c483ed90e75ba63128519848711201da5ff1f40b1ddc0992143309cf7b253701ffe7dca8b7e8051d87ac8003e531543cb5f897411448f4614b59c656ef1cbb539a2e95948a0b559fd9dcf10ced2f28980875e8083e36388c38274d3ab2765be109caca3add4af55e155c5521ee82a413bb3395f647f364d4852746aafb06becf223eba0da2db972c9b93fd57396bb3b361e2fdfe44d45380bb3f51dd3852c56a142c72897b97bec9653ed4f06a67528a5e4ba8f2405983991a0cfe9ccf16f9531af979bf827e95ae1654ccba144411ae99f3d967a87e17404675cb2fd93a758436b00dde094c1b7980c11abdd5908c7dca35021c52d32f0ecbbafdf0ce6471eabea5990f9cf6ff323f2aa55c529a4bc3695e7a1d3b89ee83a7da582fd7971bf40299bf2ed36ffa57b780299e8cffd2f1b14de49a95804b2e6787d981701009201fe17c9d9bec03fa29552bba62cf9cb516371283b0134f11d91274e863cb98495b63daa059cf8175b72cfa7597fff853675202a7518a89b384ddbbbe9ef946bf8a1894a448751bac469277444f3c3aa41eb7b30cdd20b74341074e46ae04c7d2708809d8a714f4624e46f946da70e9766a84be51e6e4cf9640452e3b04d6e4eead29444ce35ec32572113d55ffbd3b0e9b1e4849e8518bcbb863b2f535c7302455918430244e1aa7483766e3bf82189cb9b59e043da2903e5885a3d144dd005f4699b04665f96ccdf659b7b977a30838a9197c4da035c3bce15882960492fc1681a5ff76b0c613efb1da7adcf58f26081074188fd4a1e662263db6b5fabc2d7d2b3eec86587bb960560841210c03138f305d135b5286fa5a53aa7a68614dac6d2999acbb90d0f83a8bb4a03fb8bddf6fd0c8c1d3445c1651cf9216bce805b3b07b010b3c4be74320c79fdd9ed149f6d2b84b126e8c78b9f14c410bd8859f0f6d5708fc38028748957e39efe2f183af5c1b20a9477cf2bc77ed675d8bf971eb0485765d07ef9131ecbcbaefec87831802c2531790f5f383017c25d7a1e9380a980c760d252af5ac6f65c9797390f0ac7033dbeefbf6e267180036f946882ab59c57c985fb7149a1d31eed34ae193614d71eebe6d4afb33634e04ff6e9c71bdde39d41d328d675e520bd9f5316845a13654c514e9c9b1ae90927c0b8610170e8b63bc6ee3fb011d4791918306ae3315cc11ac774187c06faa40f0397163d03c26460143838f7b2a1dbe0dcb5bc229c05adba76aafe14d9be9c9b3aa876b3836e539f11d789d1a9730c5a51a93876b13ffb4427dcb5e27f03d92948dd9afd9374a76ae5403ca69d8ebbd321b60de41287d3720f2dbfde270112c88d5c6fe21ad90cac562717159744fa9f59c0d4b654ab1eaf30390415416b85fe94c44a955ebf97915c7cba26da1542287e7529665adb32476e176b4310187b8a4a1b9c173a1069a4bd56970c1d33cbb2816d91b2a7b81e41612e0b5a5b2a82d92f20af6f9c4c8f62d83375bb77647af4f1abddd6ba8570e3763882a0f67fedfbbe77b2260d73b8a21602b81d14551110e4a6f4e9ae9561b3609acf6ffca496956d087aee9c2fa6c047f080e55e23310f3d46e4b2ced554d0ed284c111f85746045fb2c7af8af023b8bf32fa154fae806904726b0d52354b4c0ec013069cba5492f9119c20f9175f35044eef3563363e2ba90a42d849d494c900dbcdf76fa33b1249e5d4b1ff80d821d2da648e303de80ac7bfc87757dcaba30d6868ac2fe3e974f0feb4b21a4217328da68bee4cafe57405825071f37dc5d58eb4d21ec69ae389ac3e434d56f134531db3a64c27e85a4a266702758a1ec4fc70b0480cc93e42c26d05242c90e4b75fd9b22bd036ffb35af3941de763cbbc62521b441485ad955b907f4eebd68cf83c4d0c93f341800de5fd42ae9babf2a7cf8da293c8196a2ad2da26f5ff3be6dbfc8d36ee890bdd4b5489056c002c43f22313d678d2d32f657e990b0b444f92ee509d3acd315b4956209edc14ca3c275b6e2a60df3b68dfea23303cc616c8b4153f51eee1b5934591379df83f7eac1b59a2be1a475f88fecea3380ffcf195b8d54d4cac7f97ce77995ebd50069bbdc4e4d106213877c237250abab6442bbc261c92f10e68c0829828b06176acc249ded553c048dfe67f8c6e659133a20f307e157e466c5b1848af3ff4a8927b1fe210278c21466b9985a290261e1763c222a63e751354a575eceebad3ae4bb323530592dd8bb71495c74fe4cb0b1c6e70ca0e5d77ae1b4f9de9eae7f4b5c1c5d6027754ce7648e9dbcc6cf127494b065bd5d5cb068628c725ad9a0e831aa08af9c2e354810921a94203afe6cb6b4ec2d827dcd0e03c398eeb2d328fe1a72a136571daebef05389fb1bcf0a8f5696b97466d6a34835dcc4e8d3998cb0e139b7eab9782cb3c44d9ee10490098a46818a3315d3167b90c086d96ffdd6c81791342c2f85dc17524724cdb27b2f393b1eea33b4559f29c4ab89f938b4e3f90a2840899d592bd45ce6fd10cdbc867f9ab018b3bc177b7d319c8507c9b5d0bab6c572b407db8bcb145629a7e353d88464bf37d4359a0a4aadc1b26f4ba860b212146f7b73ecb72e4d56f7d3505bc17aa8e28b5c7e6c26ca0cec1446e8fb9055b32110cbcaa8314ef6b5dc983fa0f257c43797cf095a9d72e15997af3b543111ef22cef6a8eecce2db865b78fc237733aa2c81e05d18d91ffed81fdf2f95e5e8d378d47ddd30c353b4eabd518758c73225cd8e1be7d2523e08b15e6e81a36ccb0f59a87a46c7d0ca3e7ff29cbe09c850a4e2bcb49ab4be177cb48b12e5daa7994b07e6c2325eb13ee87d42904f108a3a33af3bda30e80c3c49cf380911a05000bc8c08ec8475833ce2d8b6b1b3772847b8370989b87747b11a24aa444d18798a19815bcedf5075d0097431bdebdde3907706947276ec29199ce1cd04cff612fe36343c6bc99b37dd1f34d688676ef3aeeaeaf386b20cd2b24cb58897c7601520e3bc029fc93991deeadfb9324a42fc26cf72e782104c82f22fc82dd19c355cd8ba9a1f3380f51e6b67755174abc7b2e81a8c14e1b7d9825ed57959c7c431ff1b52539921d65b3dd1e711acc09b9bea67c398d55b0a64d35a7a7005acd48747b7272c527669b7a468b395f13721e2e1647367d0a20990c5b2730276cea1651a0840d82d83d22baeeb4f0fa543185ef2e0d1d6837fb6705046a728a8d8c8406289318bf03a52270afd3b6d63375e9bb1d216b672b0ba7592f84ee2cd3a85e6edba7a4b54270e3ce37ebd6ef5febc535c84433909f34482454e105ded1d458f7316c960fe6d26615cf551b29d4030cb2be219d88c14c64b54de969072ba17b942a83af8f3e3b0f1c2812b2eacaab92dbb28176c1bd777adc3c3e6a26f5240737155847f442935e95802eb6bf9255314a2a5d7b80d60243b9a9d6bd3986d05dce40e0e8a8c118a4c5aff962f48f5ab214ae8a7e38f1f7bf55ed5380468bf1f8ac374e2b842c3caa205267e6f0270785d900290c1c76a674d39a6aea8fd7e4fa1f78ea2637f120bcc7a9b0cf0bd34462871a3c460ea0a9d1c3cd74005e47d092d476bfed02058ed13a1bf8aed32d2cbe223dec25b58160358cf1cd3c0ae0e10389f30110bbfd546e449718e265297668680d2874f838382c3e2aae5b4317500bd4b0e719072a60cf9c3d184863b8c465e51f5e94a0bf84d410d0939a8b0805fba79fc3dacbf06558b0041935afcc6c3a7d15a9a739b7a470fc79e9979104fd5cda27aced7afb34bab3bf2016f728e9e8587b8e64db22389e9362b4863a70a4afb38b9d0542acc7dd0ee240f93fc2adb592895028a40d8dd121b82f41a940736f48fef9aec460f1d6d870defd5da2bbaf8b75e4d959ac89067778929a586dd7c93a3e9081227e9662b4bf8bb44ade1cbca0731791e1450fa091b3ae50f6f02a73bafdbc52fdb329dddaee54759dba598bd972cbb72859d8ac795018a6b830ac2fe9b28769627b94ab5b3e30bd3316ac887f3f211a30c6b89656adcbda98becd3306d173a752eaf3cdcc2e8e8b6be3514109409aa1ba7e212f3d80ba1da07c337b1c6c9a0c79ca6626712994894ede67dd68b84293356191376d9269189227f080a15bbde25eb4e2cd2b944bda0b1ad13d983a83e60d5a1845921c35e5d4183e744c71f5bb1728e6d072d0a24e2b02db0c9fca7d4b89fd9bb898b479b931bc2fdf9ca74391566070659964c7ed20c72126143e354b3243ae9c5b40d32ae616ef10149b0c02f359786a5dbd0dc6b74037306a9d4ea039dd3d1cc2fa5b385459</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>思想的火花</category>
      </categories>
      <tags>
        <tag>悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>Interconnection_Networks-1</title>
    <url>/2020/06/24/Interconnection-Networks-ch1/</url>
    <content><![CDATA[<h2 id="第一章-互连网络简介"><a href="#第一章-互连网络简介" class="headerlink" title="第一章 互连网络简介"></a>第一章 互连网络简介</h2><ol>
<li><p>什么是互联网络？</p>
<p>互连网络是在终端之间传输数据的可编程系统。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200624161515545.png" alt="image-20200624161515545"></p>
</li>
</ol>
<p>从网络在不同时间可以建立不同链接的角度来看，该网络是可编程的。</p>
<p>本书研究小型的网络，从芯片级别到系统级别的。</p>
<ol>
<li><p>Where do you find interconnection networks? </p>
<p>组件间只要存在通信就有内联网络</p>
</li>
<li><p>Why are interconnection networks important?</p>
<p>成为提升系统性能的限制。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Interconnection_Networks</category>
      </categories>
      <tags>
        <tag>Interconnection_Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令积累</title>
    <url>/2020/06/24/Linux%E5%91%BD%E4%BB%A4%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h2 id="Linux命令积累"><a href="#Linux命令积累" class="headerlink" title="Linux命令积累"></a>Linux命令积累</h2><ol>
<li><p>移动、复制命令：</p>
<p><code>mv 源地址 目的地址</code></p>
<p><code>cp 源地址 目的地址</code></p>
</li>
<li><p>添加路径到PATH</p>
<p><code>export PATH=&quot;$HOME/bin:$PATH&quot;</code> 临时的</p>
<p>~/.bashrc 打开这个文件，在后面添加上述命令即可完成永久的修改</p>
<p>source ~/.bashrc  source 命令保存文件并将新文件中的 $PATH 加载到当前 shell 会话中：</p>
</li>
<li><p>创建目录</p>
<p><code>mkdir 文件名</code></p>
<p><code>mkdir -p /temp/dir1/dir2</code>创建文件树</p>
</li>
<li><p>安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apt<span class="literal">-get</span> install package_name 安装/更新一个 deb 包 </span><br><span class="line">apt<span class="literal">-cdrom</span> install package_name 从光盘安装/更新一个 deb 包 </span><br><span class="line">apt<span class="literal">-get</span> update 升级列表中的软件包 </span><br><span class="line">apt<span class="literal">-get</span> upgrade 升级所有已安装的软件 </span><br><span class="line">apt<span class="literal">-get</span> remove package_name 从系统删除一个deb包 </span><br><span class="line">apt<span class="literal">-get</span> check 确认依赖的软件仓库正确 </span><br><span class="line">apt<span class="literal">-get</span> clean 从下载的软件包中清理缓存 </span><br><span class="line">apt<span class="literal">-cache</span> search searched<span class="literal">-package</span> 返回包含所要搜索字符串的软件包名称</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>一次Ubuntu的安装记录</title>
    <url>/2020/06/23/%E4%B8%80%E6%AC%A1Ubuntu%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="一次Ubuntu的安装记录"><a href="#一次Ubuntu的安装记录" class="headerlink" title="一次Ubuntu的安装记录"></a>一次Ubuntu的安装记录</h2><p>​    最近要在Linux上做一点东西，但是自己不太理解要做啥，本来是想用WSL的，结果发现有点困难😂。只能转到虚拟机里面来工作了。找了一个Ubuntu的iso安装文件，安装，很快。</p>
<p>​    由于是新系统肯定需要下载软件，更新软件，确实花费了一定的时间。最难的是安装中文输入法，搞了我好久。现在还有一个bug，中文输入在terminal中无法显示光标。</p>
<p>​    后面我还行去WSL里面试试，不折腾会死就是我本人了。</p>
<p>​    一些小的启发：发现问题时多去百度，谷歌，收益很多。然后就是多试试，自己总能解决问题。</p>
<p>​    还有Linux不要随意删除自带的python，很坑。记住！</p>
]]></content>
      <categories>
        <category>软件安装</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划我来康康</title>
    <url>/2020/06/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%88%91%E6%9D%A5%E5%BA%B7%E5%BA%B7/</url>
    <content><![CDATA[<h2 id="动态规划的-云-看法"><a href="#动态规划的-云-看法" class="headerlink" title="动态规划的  云  看法"></a>动态规划的  <span style = "color :#87CEFA">云</span>  看法</h2><p>​    个人而言，时而觉得动态规划比较神秘困难，时而觉得简单。主要还是没有完全掌握方法和技巧，所以最近准备重新全面的了解一下这个算法，同时在LeetCode中进行刷题。</p>
<p>​    现在我知道了递归的一般思路：递归解法-&gt;带备忘录的递归解法-&gt;动态规划的解法。</p>
<p>​    其中还有求解最优子问题。</p>
<p>​    动态规划问题最困难的就是写出状态转移方程。</p>
<p>​    下面就安装上面的思路去刷题，看看自己能得到什么🏃‍♂️🏃‍♂️🏃‍♂️</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>一点点小想法</title>
    <url>/2020/06/17/%E4%B8%80%E7%82%B9%E7%82%B9%E5%B0%8F%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="391bf898615aebc3f527a6764c85fee651d400dedeff098d3bd79fbca494db4b">7598fd0d447fa3eaa88cce180daf64da4d9e073c4ff02148c2bad48a61baf8f79bb7abbc9f7a20735ce2e59ca867107e6f8f1e21c3cd6fdc7c0e3d4d1069073188486e6c5a90a010a8cf12d588f499ab6f668210701f5089e886619fc98ebb28706a188b8d0127f4d87ec30b3f245ea235c612dc64c07ad8b171827ba415a1a7ddb2b47c74fd1ee9e6166dc5551f43c517f12d02172edab29b8cef36d7bc80e1c6531810306b7d77ff5e24e4e6a539ed5fecb75495a77b33949208a2fee3dc867d22ca9b0293df7cf8ffc852b7a90d00a296e711a747cf2a5f2df20352c45bdeffaccfdc5a735bc0736d33512c5cd5a52b2444474a409c27fcdc220d2f0974bd31b5638db53558b93afb2b4e0bf02e512dd926b824800908c0258791e30ed9953055c976c3081e60a61f52d1c8ff3f2f1ada4b7768ce46698bb44fd9a979f0607c9f39bac064ad1cd31993609d097e25adca8a658704236c666012a65a6f0066f6e7d52a30815bdfbb0c35932e19e4612be71599656105d0fc8fabd5e1a8c95aee23fa17a9e1091d3b97b7f2da490ef23a81a8c44423aa54f30111ab09d2deba7748fa5c01b4ea3e66335535d4700dc773ef803f31d9a98a9c9a6644690a1e89f26d3ab295a18f974d624251bd63b446889042504aa6a1cfdc0885a6d0599eca50137263fce6741570552caae4f15926b9a48e864c7c49d5936bf2a4803a004968a10d87b278637166b314152fe557a24fa60d9b902f7a6b450f7be733e81d04b1b7e33e95b9e31395e2054014bacb537fe76c014de04db0b4a6c7d1ae0ffbe39283e9450fb7c87110f3a8c694106de2f00ee80278c2860b7e8635942e094e77bb0a55a04b3552946f32f8b17847965187196aac7e16a31a1d042059a9f59c514cae681b4bb66e9e6371d0ecc963e32acf02d6a80f4b1b6c132a4c90b3b08e42088affc859b0ceaf58ab987b9c06b84c601329c9afd0e9d5f10bb18e7b0e0018687bb928c0289ad0ba5f11149c9961439589395dc7077aa486de5ff71959e500e184cf1cd8b521a397bd38fe19fde423851f42538a49eff2c45c94a17ed8a8446471e3fd86a619382970621ffad008736e18798697c8412da3a5830aa2ca3afc2d647d565bf7c6fbc0d9b91555ca3b66e2d8d46006d591ea43b7d6196b8fb20326ef7a98c927a333805ca7eb4a6d751dcbdc2ba62da7c9346786cd4064b9c3d010e676abb239bde122403dc820105caa707434b7e4cb5eb1a39c32f48db4c8183f69a9f3bb86d4aba8b675aa67ab72c66b69c33eedf8b47a143216811d279f4eb84546f6a6b3ef680513e7b2fe7994821837e57bee68156451ea88fe6c888fb35870c34b7bc6b4ec194eb17692e5e92a023b4d635b67c07a63ad3c2f2ff2a056</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>内省</category>
      </categories>
      <tags>
        <tag>悟与梦</tag>
        <tag>内省</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11</title>
    <url>/2020/06/17/LeetCode-11/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ol>
<li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/description/" target="_blank" rel="noopener">187.重复的DNA序列</a></li>
<li><a href="https://leetcode-cn.com/problems/single-number-ii/description/" target="_blank" rel="noopener">137.只出现一次的数字 II </a></li>
</ol>
<p>两个题目都是关于位运算的。不得不承认自己不会💔，确实没有这方面的练习，完全没有想法。这个还是需要自己多去尝试，多学习学习。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-10</title>
    <url>/2020/06/16/LeetCode-10/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>这次题目没啥。难度不大</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener">105.从前序与中序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="noopener">106.从中序与后序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener">114.二叉树展开为链表</a></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>前两题简单。直接第三题<br>要求就是把树变成链表，如下：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/2.png" alt="2"></p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/33.png" alt="33" style="zoom: 80%;" /></p>
<p>具体算法是：</p>
<ol>
<li>将右节点放到左节点的最右边的节点下面。</li>
<li>将左节点放到右节点的位置，左节点为空；</li>
<li>遍历一下即可。</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>win10汇编学习的环境配置</title>
    <url>/2020/06/13/win10%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>​    想学习汇编语言的，首先最重要的装环境。学语言躲不掉的，而且头疼的步骤😂</p>
<p>​    最开始肯定是想在win10下面运行的。网上一查装，感觉有点麻烦。然后就放弃了准备转战linux。之前把WSL删除了，又要重新弄，之前操作过，难度不大。之后就是安装汇编语言环境，这里也是坑，最后成功了，发现虚拟机DOSbox运行的时候很不正常。运行结果如下，我个人觉得是因为wsl不支持弹出程序界面。具体的我也不知道。就这样吧，win10我来了。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200613215435.png" alt="image-20200613215432641"></p>
<h2 id="win10汇编学习的环境配置"><a href="#win10汇编学习的环境配置" class="headerlink" title="win10汇编学习的环境配置"></a>win10汇编学习的环境配置</h2><p>下面的都是自己在百度上找的，有的已经忘记了网址，只能提供下面几个了。</p>
<p><a href="https://www.cnblogs.com/liuzeyu12a/p/10285384.html" target="_blank" rel="noopener">下载教程</a></p>
<h3 id="需要的工具"><a href="#需要的工具" class="headerlink" title="需要的工具"></a>需要的工具</h3><ol>
<li>dosBox模拟器。</li>
<li>masm 5.0</li>
<li>debug程序</li>
</ol>
<h4 id="一、dosBox模拟器"><a href="#一、dosBox模拟器" class="headerlink" title="一、dosBox模拟器"></a>一、dosBox模拟器</h4><ul>
<li><p>下载地址：直接到官网下载即可。        </p>
</li>
<li><p>百度的简介：DOSBox是一个软件。它是当前在 <a href="https://baike.baidu.com/item/Windows/165458" target="_blank" rel="noopener">Windows</a> 系统运行 <a href="https://baike.baidu.com/item/DOS/32025" target="_blank" rel="noopener">DOS</a> 游戏的较为完美的解决方案，该软件不仅能支持相当多的游戏实现正常运行，而且能将声音完美表现出来。</p>
<p>说实话我也不是很清楚这是干啥的，大概就是一个模拟器，或者是虚拟环境，包含8086汇编环境的，正好适合我的学习。</p>
</li>
<li><p>安装：安装包下载下来直接next,记得选择自己的安装目录就可以。</p>
</li>
<li><p>配置：这要是挂载目录。命令<code>mount c: c:\</code>前一个c盘是模拟器里面的，后面的是win10主机的目录。这样在模拟器里面需要每次输入一次。解决办法，修改配置文件DOSBox 0.74 Options.bat。</p>
</li>
<li><p>修改结果如下：</p>
<p>配置环境变量主要是在后面使用其他工具时不需四处调整目录，简化操作。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200613221849.png" alt="image-20200613221849549"></p>
</li>
<li><p>难度：❤🧡💛</p>
</li>
</ul>
<h4 id="二、masm5-0"><a href="#二、masm5-0" class="headerlink" title="二、masm5.0"></a>二、masm5.0</h4><ul>
<li><p>安装：</p>
<p>这个只要是为后面编译，链接程序，debug配置的</p>
<p>主要程序如下：</p>
</li>
</ul>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200613222317.png" alt="image-20200613222317896"></p>
<p>​        之前以为挺难的，后面发现只要下载了即可。我太高估了。💔</p>
<ul>
<li>难度：❤🧡</li>
</ul>
<h4 id="三、debug"><a href="#三、debug" class="headerlink" title="三、debug"></a>三、debug</h4><p>这个是单独装的，最后我移动到masm文件夹里面一样可以使用</p>
<ul>
<li>安装地址：github<a href="https://github.com/Microsoft/MS-DOS" target="_blank" rel="noopener">网址</a></li>
<li>使用：<a href="https://yunruowu.github.io/2020/06/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%ADDebug%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">debug使用</a></li>
<li>难度：🤍</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言中Debug的使用</title>
    <url>/2020/06/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%ADDebug%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="汇编语言中Debug的使用"><a href="#汇编语言中Debug的使用" class="headerlink" title="汇编语言中Debug的使用"></a>汇编语言中Debug的使用</h2><p>​    学习汇编语言肯定需要工具来帮助解决问题,比如调试等.所以学习debug的使用也是比然的.下面介绍一些debug的常用命令.Debug是DOS、windows提供得实模式（8086方式）程序得调试工具。可以查看cpu各种寄存器的内容、内存使用情况和机器码级跟踪程序的运行</p>
<p>​    (汇编中应该是不区分大小写的~)</p>
<h3 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h3><ol>
<li><a href="#一、R命令的使用">R命令</a>：查看、改变寄存器</li>
<li><a href="#二、D命令的使用">D命令</a>：查看内存内容</li>
<li><a href="#三、E命令的使用">E命令</a>：改写内存</li>
<li><a href="#四、U命令">U命令</a>：机器指令翻译成汇编指令</li>
<li><a href="#五、T命令">T命令</a>：执行一条机器指令</li>
<li><a href="#六、A命令">A命令</a>：以汇编指令的格式在内存写入一条机器指令</li>
</ol>
<h4 id="一、R命令的使用"><a href="#一、R命令的使用" class="headerlink" title="一、R命令的使用"></a>一、R命令的使用</h4><ul>
<li>功能：查看改变CPU寄存器的内容</li>
<li><p>命令格式：</p>
<ol>
<li><p><code>r</code> 可以查看所有寄存器的内容；</p>
<p>​    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200614100127.png" alt="image-20200614100127586"></p>
</li>
<li><p><code>r ax</code> ax为寄存器的名称，修改某个寄存器的内容；按下ENTER键之后，会出现‘：’作为输入提示符，后面输入数字，再按下ENRTER,即完成了对AX的修改。</p>
<p>​    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614100432318.png" alt="image-20200614100432318"></p>
</li>
</ol>
</li>
</ul>
<h4 id="二、D命令的使用"><a href="#二、D命令的使用" class="headerlink" title="二、D命令的使用"></a>二、D命令的使用</h4><p>​    功能：D命令是查看内存单元的命令。<br>​    命令格式:</p>
<ol>
<li><p><code>d</code>直接查看预设地址的内容。</p>
</li>
<li><p><code>d 段地址:偏移地址</code>：查看内存某处的内容。</p>
<p>eg: 查看内存10000H处的内容，</p>
<div align="center">
    <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614101142785.png"/>
</div>

<p>Debug将列出从指定位置开始的128个内存单元的内容。<br>D命令会输出三个内容：</p>
<ul>
<li><p>左边是每行的起始地址；</p>
</li>
<li><p>中间是内存单元的内容，每行的输出从16的整数倍地址开始</p>
</li>
<li><p>右边是内存单元中数据对应的可显示的ASCII码字符，没有对应的字符则用”.“替代。<br>eg: 查看1000:9处的内容</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614103307054.png" alt="image-20200614103307054"></p>
<p>还是从当前地址开始显示，但是前面1000:0H到1000:8H的不在显示</p>
</li>
<li><p>使用上面的命令后，继续使用D命令可以列处后面的内容。</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614103559342.png" alt="image-20200614103559342"></p>
</li>
</ul>
<p>3.<code>d 段地址:起始偏移地址 结尾偏移地址</code> 查看指定范围的内容</p>
</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614104157817.png" alt="image-20200614104157817"></p>
<h4 id="三、E命令的使用"><a href="#三、E命令的使用" class="headerlink" title="三、E命令的使用"></a>三、E命令的使用</h4><ul>
<li>功能：改写内存的内容</li>
<li><p>命令格式：</p>
<ol>
<li><p><code>e 起始地址 数据 数据 数据 数据 ……</code><br> eg:      <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614104602641.png" alt="image-20200614104602641"></p>
</li>
<li><p>采用提问的方式改写</p>
<ul>
<li><p>输入地址e 1000:0 按下ENTER;</p>
</li>
<li><p>显示当前位置，和内容加一个‘:’</p>
</li>
<li><p>输入内容，可修改</p>
</li>
<li><p>输入空格，下一个地址，输入ENTER结束</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614104915485.png" alt="image-20200614104915485"></p>
</li>
</ul>
</li>
<li><p>E命令可以写入字符和字符串</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/image-20200614105202142.png" alt="image-20200614105202142"></p>
</li>
<li><p>也可以直接写入机器码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b80100  mov ax,0001</span><br><span class="line">b90200  mov cx,0003</span><br><span class="line">01c8    add ax,cx</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20200614121158381.png" alt="image-20200614121158381"></p>
</li>
</ol>
</li>
</ul>
<h4 id="四、U命令"><a href="#四、U命令" class="headerlink" title="四、U命令"></a>四、U命令</h4><ul>
<li><p>功能：查看机器码对应的汇编指令</p>
</li>
<li><p>命令格式：<code>U 起始地址</code></p>
<p>eg:</p>
<p><img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20200614121300693.png" alt="image-20200614121300693"></p>
</li>
</ul>
<h4 id="五、T命令"><a href="#五、T命令" class="headerlink" title="五、T命令"></a>五、T命令</h4><pre><code>* 功能：执行一条或多条指令，执行CS:IP指向的指令。  
* 命令格式：`t`
* 注意，首先利用r将CS:IP指向要运行的地址
</code></pre><p><img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20200614121825077.png" alt="image-20200614121825077"></p>
<ul>
<li><p>执行<code>t</code>.</p>
<p><img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20200614121910203.png" alt="image-20200614121910203"></p>
<p>执行完成自动显示寄存器状态，CS：IP指向下一条指令，输入t继续执行指令</p>
</li>
</ul>
<h4 id="六、A命令"><a href="#六、A命令" class="headerlink" title="六、A命令"></a>六、A命令</h4><ul>
<li><p>功能：以汇编指令的形式写入机器指令</p>
</li>
<li><p>命令格式：<code>A 地址</code>。</p>
<p>eg:</p>
</li>
</ul>
<p><img src="C:\Users\mcdxw\AppData\Roaming\Typora\typora-user-images\image-20200614122319851.png" alt="image-20200614122319851"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    已经开始入门了，除了debug,还需要学会文件的编译和链接。继续加油！！！💤</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu命令行更换软件源</title>
    <url>/2020/06/11/Ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9B%B4%E6%8D%A2%E8%BD%AF%E4%BB%B6%E6%BA%90/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd判圈算法（龟兔赛跑算法）</title>
    <url>/2020/06/11/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%EF%BC%88%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>​    Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明，但这一算法并没有出现在罗伯特·弗洛伊德公开发表的著作中。</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>​    如何检测一个链表是否有环，如果有，那么如何确定环的起点.</p>
<h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><p>​     空间复杂度为O(1), 时间复杂度为O(n).</p>
<p>对于一个有环的链表，利用Floyd算法可以做到下面三件事：</p>
<ol>
<li>判断是否有环</li>
<li>计算环的长度</li>
<li>寻找环的起点</li>
</ol>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200611083405.png" alt="image-20200611083243900"></p>
<h4 id="1-判断是否有环"><a href="#1-判断是否有环" class="headerlink" title="1.判断是否有环"></a>1.判断是否有环</h4><p>​    使用两个指针slow和fast。两个指针都从链表的起始处S开始。slow每次向后移动一步，fast每次向后移动两步。若在fast到达链表尾部前slow与fast相遇了，就说明链表有环。<br> 这里可以简单的证明一下：反证法，假如没有环，那么slow永远追不上fast，那么在fast到达链表尾部前slow不会fast相遇了。若相遇了，链表就有环。</p>
<h4 id="2-求环的长度"><a href="#2-求环的长度" class="headerlink" title="2.求环的长度"></a>2.求环的长度</h4><p>​    当slow和fast相遇时，slow和fast必定在环上，所以只要让一者不动，另一者走一圈直到相遇，走过的节点数就是环的长度。</p>
<h4 id="3-求环的起点"><a href="#3-求环的起点" class="headerlink" title="3.求环的起点"></a>3.求环的起点</h4><p>如图所示，设AB=n, SA=m。设环的长度为L。<br> 假设slow走过的节点数为i，那么有：<br> i = m + n + a<em>L        a为slow绕过的环的圈数。<br> 因为fast速度为slow的两倍，所以相同时间走过的节点数为slow的两倍，所以有：<br> 2</em>i = m + n + b<em>L    b为fast绕过的环的圈数。<br> 两者做差有 : i = (b-a)</em>L。<br> 所以可知，fast和slow走过的距离是环的整数倍。<br> 所以有m+n=(b-2a)L。<br> 所以此时让slow回到起点S，，fast仍然在B。<br> 让两个指针以每次一步的速度往前走。<br> 当走了m步时，可发现slow和fast正好都在A处，即是环的起点。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>c_plus_plus的小知识1</title>
    <url>/2020/06/07/c-plus-plus%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%861/</url>
    <content><![CDATA[<p>厚积薄发！！！</p>
<h2 id="遇到的小知识"><a href="#遇到的小知识" class="headerlink" title="遇到的小知识"></a>遇到的小知识</h2><ol>
<li>内部函数命名。__fun(),函数前面加上前导符。</li>
<li>c++STL“前开后闭”的思想</li>
<li>c++插入是指“插入在……之前”，也就是在指定迭代器i的插入x即<code>insert(iterstor,x)</code>，插入之后i这个迭代器在x之后。</li>
<li>vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。</li>
<li>adapter(配接器) ：修改某物接口，形成另一种风貌.</li>
<li>inline 关键字。解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。<a href="https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html" target="_blank" rel="noopener">inline</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>我的团长我的团—1</title>
    <url>/2020/06/07/%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E2%80%941/</url>
    <content><![CDATA[<h2 id="扎心"><a href="#扎心" class="headerlink" title="扎心"></a>扎心</h2><p>今天看到小太爷走出小醉家门，那段旁白。艹！脑子有问题的孟烦了。这是头疼，可爱不可得。真惋惜，气死！</p>
]]></content>
      <categories>
        <category>我团</category>
      </categories>
      <tags>
        <tag>生活的感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-9</title>
    <url>/2020/06/06/LeetCode-9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>今天就一个题目，有些不好意思🙈</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">寻找峰值</a></li>
</ol>
<p>具体点，就是求解数组中的极大值，并且假设相邻的不会相等，同时nums[-1],nums[n+1]为负无穷。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​    看着题目很简单，一遍遍历即可，但是复杂的是O(n)的。题目要求$O(log(n))$。所以还需改进。</p>
<p>​    我是看了一眼解答提到的边界值，想到解法的。</p>
<p>​    思路就是比较中值mid和两段的中间值l_mid,r_mid。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid]&lt;nums[l_mid])&#123;<span class="comment">//在左边</span></span><br><span class="line">        right = mid;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&lt;nums[r_mid])&#123;<span class="comment">//在右边</span></span><br><span class="line">        left = mid;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//在中间</span></span><br><span class="line">        left = l_mid;</span><br><span class="line">        right = r_mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是代码解释的快。嘎嘎嘎！</p>
<p>还有一些边界值，这些比较简单，数组数目1，2可以单独考虑。再一个，最先比较边界的是否为极值也是一个简化的过程。</p>
<p>最终还是完成，花费的时间比较久，主要是没有安心，而且没有认真理解题目。继续🐱‍🏍。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Binary_Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora上传图片</title>
    <url>/2020/06/05/Typora%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    从开始用markdown写文章，自己只会写文字，现在有了多元的需求。比如图片，代码等。这些东西利用原生的代码可以完成，但是人总是偷懒的，没有人愿意先上传图片，再复制链接，最后写在文章中，这样存在很多无用功，所以需要偷懒。😀😉！</p>
<h2 id="我的历程"><a href="#我的历程" class="headerlink" title="我的历程"></a>我的历程</h2><ol>
<li>手写链接+本地保存。垃圾+蠢</li>
<li>利用SMMS图床，用了几次感觉没啥意义，立马放弃。</li>
<li>picGo+github图床。使用起来比较好用，但是国内访问github比较麻烦，上传问题不大，主要是本地显示问题。有点麻烦，于今天弃坑。</li>
<li>picGo+gitee图床，这里必须表扬gitee，访问快，无阻碍。❤</li>
</ol>
<h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><p>现在说来只有一句，搞这个玩意，我花了4-5个小时，还不加之前配置picGo+github图床的时间，心累💢！。</p>
<ol>
<li><p>gitee创建仓库，生成令牌，这个比较简单，gitee全中文的界面没有障碍。</p>
</li>
<li><p>下载picGo插件picgo-plugin-gitee-uploader。不知道picGo怎么回事，反正我装了好久才成功，还使用了<code>`npm install picgo-plugin-gitee-uploader -g</code>下载，最终是怎么成功的，我自己也不知道了😅。</p>
</li>
<li><p>配置插件。    </p>
<p>​     <img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200605164924.png" alt="image-20200605164924047"></p>
</li>
<li><p>配置Typora</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200605165122.png" alt="image-20200605165122064"></p>
<p>细节性的就不细说，看看就可以理解了。</p>
</li>
<li><p>最后验证一些即可。好用的不行。</p>
</li>
</ol>
<h2 id="报错的排除"><a href="#报错的排除" class="headerlink" title="报错的排除"></a>报错的排除</h2><p>在上传的时候主要有两个错误</p>
<ol>
<li><p>“failed to fetch” 这个是picGo的端口设置错误，改成<strong>36677端口</strong>。</p>
</li>
<li><p>{“success”,false}，出错，基本上是配置（可能是重名）错了，现在运行起来基本不会出现。</p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在找解决办法的过程中，真的好无奈，啥也不敢确定，只能不断地测试，最终成功后：</p>
<p><strong>拨开云雾见青天！</strong></p>
<p>人的心情都好了😉😉😉！</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora绘图</title>
    <url>/2020/06/05/Typora%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<p>在学习的过程中不可避免地要绘制流程图，树状图，这些图画起来比较简单，但是要达到美观就比较麻烦了。所以在网上找了一些绘图的工具，首先是Typora的自带绘图工具。</p>
<h2 id="Typora的绘图代码"><a href="#Typora的绘图代码" class="headerlink" title="Typora的绘图代码"></a>Typora的绘图代码</h2><h3 id="mermaid绘图"><a href="#mermaid绘图" class="headerlink" title="mermaid绘图"></a>mermaid绘图</h3><p>首先是成品：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">    C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line"></span><br><span class="line">    C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line"></span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure>
<p>下面是代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line"></span><br><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"></span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=<span class="number">1</span>| D[结果<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    C --&gt;|a=<span class="number">2</span>| E[结果<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    F[横向流程图]</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>接受一下算法：</p>
<ol>
<li>{}表示的是条件判断，[]是方形的边框，（）是圆形的。</li>
<li>—&gt;表示的线，A,B,C是标号。||是条件，括号内的是节点名称。</li>
<li>LR表示横向， TD是竖向</li>
</ol>
<h3 id="标准流程图flow"><a href="#标准流程图flow" class="headerlink" title="标准流程图flow"></a>标准流程图flow</h3><p>成品：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```flow</span><br><span class="line"></span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e=&gt;<span class="built_in">end</span>: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```flow</span><br><span class="line"></span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e=&gt;<span class="built_in">end</span>: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line"></span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line"></span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>到此也就结束了，还有UML等的绘制，但是目前我用不到，再此就不进行记录了。</p>
<h3 id="工具绘图Graphviz"><a href="#工具绘图Graphviz" class="headerlink" title="工具绘图Graphviz"></a>工具绘图Graphviz</h3><p>Graphviz 是一个开源的图可视化工具，非常适合绘制结构化的图标和网络。Graphviz 使用一种叫 DOT 的语言来表示图形。</p>
<p><strong>DOT 语言</strong></p>
<p>DOT 语言是一种图形描述语言。能够以简单的方式描述图形，并且为人和计算机所理解。</p>
<p>有关代码：</p>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">graph graphname &#123;</span><br><span class="line">   a -- b -- c;</span><br><span class="line">   b -- d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digraph graphname &#123;</span><br><span class="line">    a -&gt; b -&gt; c;</span><br><span class="line">    b -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h4><p>属性可以设置在节点和边上，用一对 <em>[]</em> 表示，多个属性可以用空格或者 <em>,</em> 隔开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strict graph &#123;</span><br><span class="line">  &#x2F;&#x2F; 设置节点属性</span><br><span class="line">  b [shape&#x3D;box];</span><br><span class="line">  c [shape&#x3D;triangle];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置边属性</span><br><span class="line">  a -- b [color&#x3D;blue];</span><br><span class="line">  a -- c [style&#x3D;dotted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的属性列表可以参考 <a href="https://link.zhihu.com/?target=http%3A//www.graphviz.org/content/attrs">attrs | Graphviz - Graph Visualization Software</a></p>
<h4 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h4><p>subgraph 的作用主要有 3 个：</p>
<ol>
<li>表示图的结构，对节点和边进行分组</li>
<li>提供一个单独的上下位文设置属性</li>
<li>针对特定引擎使用特殊的布局。比如下面的例子，如果 subgraph 的名字以 cluster 开头，所有属于这个子图的节点会用一个矩形和其他节点分开。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digraph graphname&#123; </span><br><span class="line">    a -&gt; &#123;b c&#125;;</span><br><span class="line">    c -&gt; e;</span><br><span class="line">    b -&gt; d;</span><br><span class="line"></span><br><span class="line">    subgraph cluster_bc &#123;</span><br><span class="line">        bgcolor&#x3D;red;</span><br><span class="line">        b;</span><br><span class="line">        c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subgraph cluster_de &#123;</span><br><span class="line">        label&#x3D;&quot;Block&quot;</span><br><span class="line">        d;</span><br><span class="line">        e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>默认情况下图是从上到下布局的，通过设置 rankdir=”LR” 可以让图从左到右布局。</p>
<p>现在够用了。</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>使用dot -T输出的格式 dot文本 -o *.输出格式 命令，可以生成相应格式的图片。比如要根据上面的脚本生成一个svg图片，可以执行命令：dot -Tsvg eg.dot -o eg.svg</p>
<p>生成图片</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dot test.dot -T png -o test.png</span><br></pre></td></tr></table></figure>
<p>由一个节点指向多个节点时，可以将它们用大括号包上，当子节点含有空格时可用引号将其包含。可以对脚本代码加上注释，其风格与C++的注释风格一样，可以用/<em> </em>/包括注释内容，也可以用//将后面到下一行为止全当作注释。</p>
<h4 id="节点描述中包含空格导致被拆分成两个节点"><a href="#节点描述中包含空格导致被拆分成两个节点" class="headerlink" title="节点描述中包含空格导致被拆分成两个节点"></a>节点描述中包含空格导致被拆分成两个节点</h4><p>​    解决方案一，使用 label</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">graph pic1 &#123;</span><br><span class="line">        google [label=<span class="string">"Google 搜索"</span>];</span><br><span class="line">        百度搜索 <span class="comment">-- 大象笔记</span></span><br><span class="line">        google <span class="comment">-- 大象笔记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方案二，加双引号</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">graph pic1 &#123;</span><br><span class="line">        百度搜索 <span class="comment">-- 大象笔记</span></span><br><span class="line">        <span class="string">"Google 搜索"</span> <span class="comment">-- 大象笔记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一些基本图形"><a href="#一些基本图形" class="headerlink" title="一些基本图形"></a>一些基本图形</h4><p>节点形状</p>
<p><a href="https://graphviz.gitlab.io/_pages/doc/info/shapes.html" target="_blank" rel="noopener">https://graphviz.gitlab.io/_pages/doc/info/shapes.html</a></p>
<p><img src="https://cdn.sunzhongwei.com/sunzhongwei_5badb625d6a88?imageView2/2/w/800/format/jpg/interlace/1/q/97%7Cimageslim" alt="画流程图工具 Graphviz，简介及基础教程"></p>
<p>箭头的形状也有很大的选择空间</p>
<p><a href="https://graphviz.gitlab.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">https://graphviz.gitlab.io/_pages/doc/info/arrows.html</a></p>
<p><img src="https://cdn.sunzhongwei.com/sunzhongwei_5badb62eaf68f?imageView2/2/w/800/format/jpg/interlace/1/q/97%7Cimageslim" alt="画流程图工具 Graphviz，简介及基础教程"></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法题目</title>
    <url>/2020/06/05/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a><a href="https://leetcode-cn.com/tag/backtracking/" target="_blank" rel="noopener">算法描述</a></h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<h2 id="算法使用方法"><a href="#算法使用方法" class="headerlink" title="算法使用方法"></a>算法使用方法</h2><p>我觉得在使用回溯算法的时候，需要使用树形的结构来帮助算法的运行。我在使用回溯的时候都是理由深度优先搜索算法和剪枝来解决问题的。</p>
<p>整个深度搜索算法的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;	<span class="comment">// 最终能达到的树的深度</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans; <span class="comment">//如果要求不重复，可以声明为set或者在算法中排除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tags, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ins)</span><span class="comment">//cur表示当前到达的树的层次，tag表示一种约束，比如只能元素只能用一次等。ins 表示当前整个路径上的节点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n)&#123;<span class="comment">//可能还有其他限制条件，这里只是深度满足要求。</span></span><br><span class="line">        ans.push_back(ins);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>()&#123;<span class="comment">//遍历可以遍历的</span></span><br><span class="line">        <span class="comment">// 处理tags和ins</span></span><br><span class="line">        dfs(cur+<span class="number">1</span>, tags,ins);</span><br><span class="line">        <span class="comment">//恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用树形图来解释一下算法：</p>
<p><img src="https://gitee.com/yunruowu/PictureForBolg/raw/master/img/20200605162618.png" alt="二叉树"></p>
<p>首先就从空节点a开始，每次添加一个节点，从可选的节点中选择，继续到下一层，同时可以存在剪枝，在每个节点开始时，判断是否达到最终条件或者超过最终条件，这样可以将该节点及其以下的节点删除，不用遍历。在遍历子节点完成后，会回到当前节点的上一个状态，这样就是回溯。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/06/01/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>今天在刷题的过程中，遇到了有关并查集的问题，之前有学过，但是一直没有使用过。所以没啥映像。现在好好学习一下。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>首先这里都是自己看人家写的。还处于学习的阶段。</p>
<p>​    并查集（Union-find Sets）是一种非常精巧而实用的数据结构，它主要用于处理一些<em>不相交集合</em>的合并问题。一些常见的用途有求连通子图、求最小生成树的 Kruskal 算法和求最近公共祖先（Least Common Ancestors, LCA）等。</p>
<p>​    使用并查集时，首先会存在一组不相交的动态集合$S = {S_1, S_2 … S_k}$，一般都会使用一个整数表示集合中的一个元素。每个集合可能包含一个或多个元素，并选出集合中的某个元素作为<strong>代表</strong>。每个集合中具体包含了哪些元素是不关心的，具体选择哪个元素作为代表一般也是不关心的。我们关心的是，对于给定的元素，可以很快的找到这个元素所在的集合（的代表），以及合并两个元素所在的集合，而且这些操作的时间复杂度都是<strong>常数级</strong>的。</p>
<p>​    并查集的操作有三个：</p>
<ol>
<li>makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。</li>
<li>unionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。</li>
<li>find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span>&#123;</span></span><br><span class="line">    <span class="comment">//集合</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">	<span class="comment">//创建n个集合，其中每个元素都是一个单元素集合，即父节点是其自身：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        data.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) data[i] = i;</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = i;</span><br><span class="line">        <span class="keyword">while</span> ( data[root] != root)&#123;</span><br><span class="line">            root = data[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">//合并集合i，j.合并操作 unionSet，并查集的合并也非常简单，</span></span><br><span class="line">    <span class="comment">//就是将一个集合的树根指向另一个集合的树根</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = parent(i);</span><br><span class="line">        <span class="keyword">int</span> p2 = parent(j);</span><br><span class="line">        <span class="keyword">if</span> ( p1 != p2 )&#123;</span><br><span class="line">            data[p1] = p2;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> p1 != p2;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>感觉自己还不是很理解，需要一些练习。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-8</title>
    <url>/2020/06/01/LeetCode-8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/description/" target="_blank" rel="noopener">二叉树的堂兄弟节点</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-islands/description/" target="_blank" rel="noopener">200.岛屿数量</a></li>
<li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/" target="_blank" rel="noopener">201.数字范围按位与</a></li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二叉树的堂兄弟节点"><a href="#二叉树的堂兄弟节点" class="headerlink" title="二叉树的堂兄弟节点"></a>二叉树的堂兄弟节点</h3><p>​    利用结构体，一个属性为父节点，一个为节点深度。</p>
<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p>​    两种方法。</p>
<p>​    法一：深度遍历，遍历完将岛屿清零；</p>
<p>​    法二：并查集。</p>
<h3 id="数字范围按位与"><a href="#数字范围按位与" class="headerlink" title="数字范围按位与"></a>数字范围按位与</h3><p>​    主要思想：不太理解。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-7</title>
    <url>/2020/05/30/LeetCode-7/</url>
    <content><![CDATA[<h2 id="LeetCode-7"><a href="#LeetCode-7" class="headerlink" title="LeetCode_7"></a>LeetCode_7</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol>
<li><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/" target="_blank" rel="noopener">976.三角形最大周长</a></li>
<li><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977.有序数组的平方</a></li>
<li><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/description/" target="_blank" rel="noopener">989.数组形式的整数加法</a></li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="三角形最大周长"><a href="#三角形最大周长" class="headerlink" title="三角形最大周长"></a>三角形最大周长</h4><p>​    先排序，后面就三个一起往后移动。比如此时$a&gt;=b&gt;=c&gt;d$。如果$a,b,c$能组成三角形，那么其是最大的。如果不能，那么应该$a&gt;b+c$，那么$a&gt;b+d$也显然成立。所以直接比较$b,c,d$是否满足要求即可。</p>
<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><p>​    最简单的方法，直接计算，然后排序。</p>
<p>​    稍微好一点的做法，双指针做法</p>
<h4 id="数组形式的整数加法"><a href="#数组形式的整数加法" class="headerlink" title="数组形式的整数加法"></a>数组形式的整数加法</h4><p>​    直接将最后一位与K进行相加，然后进位继续求和。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C艹_创建无重复元素的Vector</title>
    <url>/2020/05/29/C%E8%89%B9-%E5%88%9B%E5%BB%BA%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84Vector/</url>
    <content><![CDATA[<h2 id="c-创建无重复元素的Vector"><a href="#c-创建无重复元素的Vector" class="headerlink" title="c++创建无重复元素的Vector"></a>c++创建无重复元素的Vector</h2><p>​    我们知道，在刷题的时候，总是会遇到让我们创建无重复元素的问题。主要方法，在插入的时候进行处理。这里不选择这个。我们先使用SET容器，这样可以把元素无重复的插入。最后将Set的值赋给Vector。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ans.assign(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>十分简单。学到了。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-6</title>
    <url>/2020/05/29/LeetCode-6/</url>
    <content><![CDATA[<h1 id="LeetCode-6"><a href="#LeetCode-6" class="headerlink" title="LeetCode-6"></a>LeetCode-6</h1><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><hr>
<ol>
<li>953.<a href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary/description/" target="_blank" rel="noopener">验证外星语词典</a></li>
<li>961.<a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/description/" target="_blank" rel="noopener">重复n次的元素</a></li>
<li>965.<a href="https://leetcode-cn.com/problems/univalued-binary-tree/description/" target="_blank" rel="noopener">单值二叉树</a></li>
<li>970.<a href="https://leetcode-cn.com/problems/univalued-binary-tree/description/" target="_blank" rel="noopener">强整数</a></li>
</ol>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h4 id="验证外星语词典"><a href="#验证外星语词典" class="headerlink" title="验证外星语词典"></a>验证外星语词典</h4><p>​    这题目就是一个字典排序题。不过字典序是题目指定的，所以需要一个转换。然后遍历即可，难度不高。</p>
<h4 id="重复n次的元素"><a href="#重复n次的元素" class="headerlink" title="重复n次的元素"></a>重复n次的元素</h4><p>​    一共2n个元素，n+1个不同的，其中n个重复。最简单的就是遍历。另一个解法是：长度为4的子序列中一定会有重复元素。只需要比较所有距离为 1，2 或者 3 的邻居元素即可。</p>
<h4 id="单值二叉树"><a href="#单值二叉树" class="headerlink" title="单值二叉树"></a>单值二叉树</h4><p>​    这个就比较简单了，只需要遍历即可。</p>
<h4 id="强整数"><a href="#强整数" class="headerlink" title="强整数"></a>强整数</h4><p>​    最开始遍历范围，然后计算是否成立，后面是先计算成立的，再计算是否符合范围。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>5.28最近的一些计划</title>
    <url>/2020/05/28/5-28%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol>
<li><p>hexo</p>
<p>工欲善其事，必先利其器。这句话还是很对的，以后要用hexo写博客，之前修改过hexo的主题，但是还有有一些不和谐的地方，在阅读别人博客的时候，确实存在好看的主题和效果，这些都是值得我去学习，借鉴的。所以我要修改一下我的博客，目前主要还是修改功能性的问题，按钮点击没有出现404，每个页面都要设置好，还好页面的显示要合理，不是很丑的那种。之后就是更多的美化这些东西，让他们的“颜值” 不断提升。</p>
</li>
<li><p>读书🛴提升自己</p>
<p>之前买的两本专业书，也可以带着看看了，不然又浪费了金钱。</p>
<p>然后有机会还是要多看看其他方面的书籍，提升一下整个人的内在。</p>
</li>
<li><p>目前的学业和工作任务</p>
<ol>
<li>毕业设计，还要修改，降重；</li>
<li>简历。</li>
</ol>
</li>
<li><p>我的团长我的团，最近又在看了多想想一些自己身上有的不好的地方。</p>
<p>最后，每件事都很容易，难得坚持下去，坚持下去会有不一样得收获。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>任务</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>复试出成绩的一天</title>
    <url>/2020/05/22/%E5%A4%8D%E8%AF%95%E5%87%BA%E6%88%90%E7%BB%A9%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0db31fb6a2c656c5e0397327f986c3f6675f355f1611a602b86de866a3a274bb">165d50f05814027fb7fe5e4ae8a088d8b883c0c71aadc092686b74e9325a2a8a18cf527954f0a57c7ce93ee42094d9d8e2f21e540a9947f30d9e5e1d84a64a312295dd584c9643702d69188d9d47a95e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>强烈推荐Typora</title>
    <url>/2020/05/17/%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90Typora/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="54a9a96b6833b6120c4593cd121bc978aad7a916cdcac827800101f4e8985893">165d50f05814027fb7fe5e4ae8a088d8ed45cb227c5039853179c5405e990a0b314d140398ce74a689e791f2f8ef4df63d145f20f4868bcd51570f350ad62fd6f69056f81455a3a93d4598ba614298abc3f5e00d778e073d19fd24b04433943fe736d550f2b10a4c8530475a5a8ff8a5af59b0a4bba79df5b48fdbe28ef47b629fd5b76b6f3f001399a2816ba9fd25c2b7a0668226869f7531685a04c6f9e0fa8452b066584c36d149d2ca33f1fbd3b931d0d91ad2faf5f179f3b28f128eb209a156d9512fdbc1ae28cef444d4b25f8b8c3759d8188d0166286bc916106c8a19c801742c0b63f0c3c59255bbd9c33cbf8f9dff8a697df213b61d160cf3647e9f0a4d7e442bde29a109717867e41840e77091c1361fd61f58a5ddac59f8f3cbd1770c6bd25bf9b6ca6d316267edc3d49a7fec058130a2165bc8062103216f8e80c7575d08d1dba4aab58a5a17ebe1552cc69f5e6fca1fabb345e8028fd79f8ae64651e24140824b3fd22a2cfa90f85312e3c09e1c8fb47b17c3cb06f9f4f4306d4fa37e1867df2e88f3acc4cedb11b891070456b48e6e5b980d9347076bac2ffafaa118b662808614c3212ce4381815f09c93de198d5a77d69921b133db0880b9291e39e17eb7d618188d3c592e425dbc9c9c328d117fbb9f77e08f1fd18efc8f894bb7d1696ba87654729db7a2ac1bb6b90d9062ad923a8b41d09d6770ebbaf7c9d2c859c21b8da104d6da804af31c00fc4b6ff36daced78c8aefb8ab19c82c3b4ad2e6ed90c09c580473c3030f780e181f46baf876727a927fe525fe2a9c0e8fde974f5bbe7f2e4fe072552ddfc520bf98090c8d0a534eb78ac21ca93e9119acd0084437e29cc4b3c1312b7940c0b96d17dd89c422a23832ae1a3cf93cde9f8b302e69b822239c1ebfe2359b2172c0262b39bbdf5e8aadc781de2a7c7f3f263b04c34a4c0fc618e23b93b3368e221cd5f63f529f8e14026b790f55e3ed587ee</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>准备复试的某一天</title>
    <url>/2020/05/17/%E5%87%86%E5%A4%87%E5%A4%8D%E8%AF%95%E7%9A%84%E6%9F%90%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="266f19497ae5cecae49a9619a05d90092b9510e3463d5bf7eeec742f239029a9">9c18114bfffb75bea463c3ab069bee10c3b28437808ee210f2550d1502faac2db4c2faa24aeef9c8ca77c215318df8c0ff055c4fe84752920b69c2aab8c5ae838fa2e1e380da8547b968f4b4419418d0a224260548bf4f8c7fa6dc53cc18c297b8fe4a3631eb8d7f5d139874f1b7b9d12bfb6a63055069c02603bd3f025f8f30d549bb36384767e964dce06a2c6f76f3781e60c338725d98a390b270b606ecc45bdfa5069bb487ccdb8e738060d47fb8ee93a06cc1598dde13f1c83a6007aabe14d791ff83200c92b87aa51d0865edca135f770b02414964c3086570d9ad691b06f14a0262347f653b6e3b552741b485927a924b9dbcc425ceec1d7e4985df1a27a037e0f365ca0e0feef2dc15dd826399444b0f02cf0503c59147351cd9d57ecd7ca76d741b75db93ee45d61739752d05e07e2a3f1d8514708cdea28bc38e1d5c8f85ccde9da161032193f3568e9ed3a8cafa0943433b617b0215eda644041bceb8e5e7edb307a2803e30df43159a9b085cb41b4d05418bff6f6155f8c06848ca7978f7d13c2d56d4e95761deb6b9573c26fe85c153f8294cba6c53ea34493e684aa436257b4fc56e430253511f93b0cd3bf427d57b835bbdde9a3906b3450a13db1ccf60cbf69c11eaff56c0a7476966488bf4ac6f5ba60fdb8ee2db48b4779eac52c6267332e2d9d11d99c7858b8143b8f16b04afa7c98ed4dad297bf90ff261e6ca46731746784bc69b523d54eb9ef1d72686c43a0cd9adb6eeba02a758245034b14eeb25a2bf9be90fec07ca49c007bad4632024aaa8c03b1cc2ba203ee9c005a8fbb205b3d6e7a902ffab00a82e4ca257eac76024aa5988c6cd6033f529e8795743fe4e3b7c9c47fc61610f97dc058eacb48d00daab37b27e9c7c40459d29dd718750aad143553e68859af21f9726eafb9e236f4ee1c3d41a6387b08c870aaad2df7e1766ccc7660af3966f8e2c8d5e1e622a9cdd73d2a007cc4a4b17b011b66079f5c8b1bd775870c32f32057e82791f518578fdbfe367b481fc0ae6d5c9d187f4f532474bb459b123fccd41efe380478d728ddee00861fb43e841e6a691354d898c50f4e3357a32b4f2193fd1e23a6235b78f696b5a53fca28a78172004bc306805b5f44e1d0a088b1f36ff7f790a9d2c32939c552d9386b5b04becc2d35a7f9c980973dd6a4602fc8e9004eb914fd9f4fff8fb756a468fb3b5190762e718a68a7ef00a54d0b3dad8cce1a9a1b0148a7296901fab5b375a8d69a5212d2f4e1a922a8c59bfb7496e4a5f354a10bd50a6d8085a2b19e2a26f413837476264ad744650dd707108c0bb65de2438d8f61680bbdb9d329adc33fedddee13285ef1b9600e88559e8b79731f31f6fb78f689e90ec77cf84e099a39ba2ea53589d387bea7bba7c96546f2c0d39078a5c15f6c323c54fc64002c1bbc7d1d5aa65c81a564a1886db93ae897ade507e1d699108643417bf10e0b35124e7367abeaadb766f0e6cc0bc37eb09118bdac67bc7c819098043b030376994405ce4a4db9f4ceb6487c00da305c5b6a453d9bce4125a8dfcec7826f5c079eb4118f00d8c6cf5b8f67bfaf8a1e032d4c4cf0e88b54ac1344a903c81f14206ebbfceedd8a39fc2dcb630ab2e7dfd9a3794927da9e4747d85b09938c832539c8f5953f5a1a46701d6a453ac03e365e9775e939c449f13f6de97e9b8a55874a245e5f8e44052c1e4f4c8957668f797e832165bc47d5a79d0d14385a67e87e6453979a8235330a379464a09e967a400b13498f11cedfa346d28ec8f7740de062710babf310d7d75bf31e587f50dc392a7c5e77e9ba16e18bfedebcb88b867ad4a0fd2fd853abb36301c768ed57b63841d922d1767c8525e93d4ba36dd05aac6b256055626c91fcdbe9975352eeaefade987bb58088317aee9fba39ea4d0731937cc8d3ccb0871d1549f8261aa834a9f0b2f277c3519f4e4b91b067dafef3bd022c9bde1f0602b0b131689c1d30065a3c824ba62be7f21ea57d80d1d1d6065d4b03781aa309ee1c8052b3e9947dd4fdbb97764055b19a6fb75e5b3352e2a7368eb9cd0dab54f8b22681d62713f807c9906029c03e24f436e9673a5fcdb49574c43e5b2aa4bef2d7de8f9066264dbb2ec68846323c987f604ecb49a58b2378710b1cc9a8a4dc0714e03d33b4887e8c62fa0d9db744fe2d7bb6c96734c1cb6b868339eb3110870d5bfed647d896656082c98c5b8c200d9c694ee1ca9ee82653f23d3a0fd863708b6991898c24fae5d7e1a06851a8b9483ac273a390dfc2072c7787a9c816bf9c778bb1e5b9e4085f4481d9ad4d00cbf20cc53dfee120d2179ea936e64895430ff09bed2c91c23f0aefe494dc5d18e0737d241b4b15a4b5222948d8fef377c425e58e60888c9500c7e45db32a6ac00d629fb2062f1627e0b4d246486a2ed83b991dbd66a11175d3b07a2442714d0e90ea0ae58d0917aac90e4e0d02bc3a13c306f803fe97e7fe677760afcbfb5c583684d8fb78c68504eec141c4228fcd7ba7dd23f0417049cd62de7eaaaaa451d8be4bc17a6188694cb991beac19fea34d5136a3986f9b69d80f3c398df3176935bdf354cc8f5e615ab341d82e1542e0e2645ae9cfb064c156f4a2a78215fceafc791c58856fb72232edbbedd88b83a731d6dbdb1d08cff21957b920a25cf69067928a2ae0045513893d4605acbc3880cb2c8b3aeb59875761dca33e2e875dc50c78ee993f469d5aa7a6279c37ec54b7452b5cf3f67e98983f16d6d4e4629d20345f676992aa73946d727be2807e33f5fae306cbe517bceb708c68af86f76998056c7ed2d5e7382eb49383b95536be5aae7f3a218431405b30b15604a60b8d9b6baa9ed0d85adb6c7806843018a2ec44abc8e1f1faa7490194225cc9d3bfe9cfaedf1af5033d3feab0a5b6b089a195cb694ede4b7254317da4b7e9c7c843e2f86ced177f810a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>思想的火花</category>
      </categories>
      <tags>
        <tag>日常，悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年五四的一些感想</title>
    <url>/2020/05/05/2020%E5%B9%B4%E4%BA%94%E5%9B%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<h2 id="五四，青年的日子"><a href="#五四，青年的日子" class="headerlink" title="五四，青年的日子"></a>五四，青年的日子</h2><p>这里我只想应用鲁迅先生的一句话：</p>
<blockquote>
<p>愿中国的青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热、发一分光。就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。  </p>
</blockquote>
<p>诚然，我所处的时代，不是一个黑暗的时代，但是我们的时代仍然有不公，依旧需要我们的努力。青年一代的我，作为这个社会的支撑，必须要拿出自己的担当。去面对未知于黑暗，去创造可能与光明。奉献自己的萤火，照亮这世间的黑。  </p>
]]></content>
      <categories>
        <category>思想的火花</category>
      </categories>
      <tags>
        <tag>悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>python中plt画图出现警告</title>
    <url>/2020/04/29/python%E4%B8%ADplt%E7%94%BB%E5%9B%BE%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>最近做毕设的时候，需要画图来查看算法优化性能。之前都是利用截图来保存的，今天网上找到了可以自动保存图片的方法，在使用的过程中出现警告：<code>libpng warning: iCCP: known incorrect sRGB profile</code>。在查阅资料后发现是因为使用了QQ输入法，这个错误也太搞笑了，记录一下。顺便记录保存图片代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">t = np.arange(<span class="number">0</span>, <span class="number">69</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, t, <span class="string">'r'</span>, t, t**<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">label = [<span class="string">'t'</span>, <span class="string">'t**2'</span>]</span><br><span class="line">plt.yscale(<span class="string">'log'</span>)</span><br><span class="line">plt.legend(label, loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.savefig(<span class="string">'./test'</span>+str(i)+<span class="string">'.png'</span>)</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line">plt.pause(<span class="number">1.5</span>)</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中：：的使用</title>
    <url>/2020/04/17/C-%E4%B8%AD%EF%BC%9A%EF%BC%9A%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="c-中-的用法"><a href="#c-中-的用法" class="headerlink" title="c++中::的用法"></a>c++中::的用法</h2><p>::是运算符中等级最高的，它分为三种:</p>
<ol>
<li>global scope(全局作用域符)，用法(::name)</li>
<li>class scope(类作用域符)，用法(class::name)</li>
<li>namespace scope(命名空间作用域符)，用法(namespace::name)<br>他们都是左关联(left-associativity)<br>他们的作用都是为了更明确的调用你想要的变量，如在程序中的某一处你想调用全局变量a，那么就写成::a，如果想调用class A中的成员变量a，那么就写成A::a,另外一个如果想调用namespace std中的cout成员，你就写成std::cout(相当于using namespace std; cout)意思是在这里我想用cout对象是命名空间std中的cout(即就是标准库里边的cout)</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>本地git连接GitHub</title>
    <url>/2020/04/16/%E6%9C%AC%E5%9C%B0git%E8%BF%9E%E6%8E%A5GitHub/</url>
    <content><![CDATA[<ol>
<li>进入要操作的文件夹</li>
<li><p>命令行操作</p>
<ul>
<li><strong>第一步</strong>： 进入要所要上传文件的目录输入命令 <code>git init</code></li>
<li><strong>第二步</strong>： 创建一个本地仓库origin，使用命令 <code>git remote add origin git@github.com:yourName/yourRepo.git</code> youname是你的GitHub的用户名，yourRepo是你要上传到GitHub的仓库，这是你再GitHub上添加的仓库。  </li>
<li><p><strong>第三步</strong>： 比如你要添加一个文件xxx到本地仓库，使用命令 <code>git add xxx</code>，可以使用<code>git add .</code>自动判断添加哪些文件</p>
</li>
<li><p><strong>然后</strong>把这个添加提交到本地的仓库，使用命令 <code>git commit -m</code>说明这次的提交</p>
</li>
<li><p><strong>最后</strong>把本地仓库origin提交到远程的GitHub仓库，使用命令 <code>git push origin master</code></p>
</li>
</ul>
</li>
<li><p>出现问题时候的操做</p>
<ol>
<li><p>先拉下来，会自动合并的（不用操心）<br>git pull origin master</p>
</li>
<li><p>再上传<br><code>git push -u origin master</code></p>
</li>
</ol>
</li>
<li><p>出现错误：<br> fatal: remote origin already exists.<br> 先删除Git<br> <code>Git remote rm origin</code>  </p>
</li>
<li><p>注意事项<br> 一般来说，我都是新建项目之间进行关联，所以使用GitHub创建仓库时，不要生成readme.md就可以避免出现错误，因为生成之后两个文件就不一样了。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>git，小技巧</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5</title>
    <url>/2020/04/15/LeetCode-5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>82. 删除排序链表中的重复元素-II
86. 分割链表
87. 解码方法
</code></pre><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><ul>
<li>删除排序链表中的重复元素-II<ul>
<li>这题我的想法是我们可以先找到第一个不重复的元素，再找剩下的元素，重复就把他们删掉。</li>
</ul>
</li>
<li>分割链表<ul>
<li>首先将头部调整成正确的，然后找到正确顺序下头部后面的节点，进行调整，依次完成。</li>
</ul>
</li>
<li>解码方法<ul>
<li>这个我使用递归的，<span style="color:Tomato;">超时</span></li>
<li>使用动态规划，找个时间学习一下动态规划。  </li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-4</title>
    <url>/2020/04/12/LeetCode-4/</url>
    <content><![CDATA[<p><em><div align="right">---命都不要，就爱，就爱安逸。</div></em></p>
<div align="right" size="2">《我的团长我的团》</div>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>73. 矩阵置零
74. 搜索二维矩阵
75. 颜色分类
</code></pre><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><ol>
<li><p>矩阵置零<br> 由于题目有时间的限制，我的想法不好，就从网上参考了一下，主要的想法如下：<br> 首先利用两个bool来表示第一行，第一列时候存在0。然后在搜索其它的位置，遇到了0就将相应的位置的第一行和第一列置零。然后再遍历第一行和第一列，利用它们来设置其他位置是否为0。最后利用bool来确定第一行和第一列的值。</p>
</li>
<li><p>搜索二维矩阵<br>首先我的思路是利用了二次的二分查找，本来我以为效率挺高的了，结果看到了其他大神的解法直接是O（M+N）。说实话，思路确实很巧妙。思路是比较对角线的数字，从右上到左下。核心代码如下：  </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(row&lt;=M &amp;&amp; col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col]==target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col]&gt;target)&#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>颜色分块</p>
<ol>
<li>思路<br>这个比较常见，属于三色棋问题。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>一点感悟2020.4.11</title>
    <url>/2020/04/11/%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F2020-4-11/</url>
    <content><![CDATA[<a id="more"></a>
<p>&ensp; &ensp;&ensp;今天在赶中期检查的时候，感觉自己有点茫然，不知道自己在干啥。最近基本上处于一种有事情来了我就看着做，做的了就慢慢做，做不了更是慢慢做，没有动力。不知道自己要啥，自己在干啥。很无力，做什么都是。人呀，没有了追求，做起事情来就是这样的没有根。失去了力量的源泉。在尘世间飘啊飘的，有风了就飘的高一些，远一点，快一些；没有风了，就靠着惯性，在飘一飘；等到惯性也没了，人就开始下坠了，往下沉，沉下去的速度很快，很快，快到你没有力气再飞起来，就算你用尽了全力，你也飞不起来了。你只能勉强的撑着。到这里，你的人生还没有结束，不过，它的轨迹，你的未来，也没有了希望。</p>
<p>&ensp; &ensp;&ensp;你的一生，本不该如此。一个特别喜欢的励志视频:<a href="https://v.qq.com/x/page/h0797gtaozg.html" target="_blank" rel="noopener">Are you have a Dream !</a></p>
<blockquote>
<p>苏格拉底说：人类的幸福和欢乐在于奋斗，而最有价值的是为理想而奋斗。</p>
</blockquote>
<p>我有理想吗？<br>我的理想是什么？<br>我为了什么而奋斗？<br>我该怎么奋斗？<br>我的未来在哪里呀！！！！</p>
]]></content>
      <tags>
        <tag>悟与梦</tag>
      </tags>
  </entry>
  <entry>
    <title>powershell和cmd一次执行多个命令</title>
    <url>/2020/04/10/powershell%E5%92%8Ccmd%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>之前遇到很多需要依次输入的命令，有的命令需要等待时间。今天找到了如何一次输入多条命令的方法👍</p>
<ol>
<li>Powershell<br> 在powershell中命令后面加上‘|’<br> eg:<br> <code>hexo clean | hexo g | hexo d</code>此命令可以一步实现博客的部署。</li>
<li>cmd<br> 在cmd中将‘|’改为‘&amp;&amp;’即可。</li>
</ol>
]]></content>
      <tags>
        <tag>命令行</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-3</title>
    <url>/2020/04/10/LeetCode-3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>79.单词搜索
今天就一题，最近再忙中期检查
</code></pre><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><a id="more"></a>
<p>第一想法就是回溯，也就这么做了，四个方向分别探索，知道成功。时间空间效率极低😢.看来其他人的答案，主要是在判断上，我的是分开判断，人家的是||或了一下，这里有不同。再一个在确定是否探索过的问题上，我利用了一个tags二维数组，可以直接通过修改原数组来实现。这点我没有做导致空间不够。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2</title>
    <url>/2020/04/09/LeetCode-2/</url>
    <content><![CDATA[<div align="right">---命都不要，就爱，就爱安逸。</div>

<div align="right" size="2">《我的团长我的团》</div>

<hr>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>54.螺旋矩阵
55.跳跃游戏
</code></pre><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><ol>
<li>螺旋矩阵</li>
</ol>
<ul>
<li>思路：旋转矩阵就是绕着转，我的想法是按照每个循环左，下，右，上。一方面要考虑边界，一方面考虑是否被访问过，这里可以利用一个边界的标志，我采用了一个相同大小的tag矩阵来标志是否访问过。</li>
</ul>
<ol>
<li>跳跃游戏</li>
</ol>
<ul>
<li><p>思路：我自己的思路是利用递归，每次往前前进一次，不断递归，最终没有满足时间的要求。</p>
</li>
<li><p>网上的解决办法<br>  这里只要理解可以到达k处，那么k之前的位置都可以到达。所以一次遍历就满足要求了，而且时空效率都很高。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    k = <span class="built_in">max</span>(k, i+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1</title>
    <url>/2020/04/08/LeetCode-1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>33.搜索旋转数组
46.全排列
49.字母异位词分组
</code></pre><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><a id="more"></a>
<ul>
<li>搜索旋转数组<br>  主要是二分法。一半有序的数组，一半无序的数组。然后一次进行下去。</li>
<li>全排列<br>  方法是回溯法，可以想成一个树状图，不断搜索，然后到叶子节点停止。</li>
<li>字母异位词分组<br>  方法就是hash,自己先写的没有通过时间的限制。后面利用了网上的题解。思路就是使用unordered_map来存储，利用排序后的string作为关键字存贮，这样一次遍历就可以完成。</li>
</ul>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>开始我的博客之旅</title>
    <url>/2020/04/02/%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h2 id="为什么开始"><a href="#为什么开始" class="headerlink" title="为什么开始"></a>为什么开始</h2><p>怎么写自己的博客，我还没有想好，也还没有想到写哪些内容。我觉得这应该是一篇技术型的博客，所以在这里我将记录一些我的学习过程，比如我现在正在写的leetcode的题解，在看的《STL的源码剖析》。我也希望可<br>以在这里审视自己的能力和不足，如若可以，提升自己的书面表达能力也是一种收获。</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>test_my_site</title>
    <url>/2020/04/02/test-my-site/</url>
    <content><![CDATA[<p>dasd  </p>
<p>d ad as </p>
<p>das d </p>
]]></content>
  </entry>
</search>
